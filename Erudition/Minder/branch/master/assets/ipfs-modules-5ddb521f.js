import{U as X,W as kn,X as Rn,Y as zr,Z as T,$ as Ur,a0 as ce,a1 as Tn,a2 as K,a3 as H,a4 as qe,a5 as M,a6 as E,a7 as Lt,a8 as Kt,a9 as St,aa as In,ab as ue,ac as Mn,ad as ye,ae as te,af as Le,ag as se,ah as At,ai as yt,aj as Vt,ak as Bn,al as Nn,am as zn,an as Un,ao as Fr,ap as rr,aq as Fn,ar as Ke,as as nr,at as qn,au as Ln,av as Kn,aw as Vn,ax as Jn,ay as Wn,az as je,aA as Gn,aB as or,aC as Qn,aD as Yn,aE as sr,aF as Xn,M as qr,aG as Zn,aH as Hn,P as eo}from"./other-modules-6d20a545.js";import{R as to}from"./libp2p-modules-5be01019.js";import{_ as ro}from"./capacitor-modules-638c799f.js";function Nl(n){throw new Error('Could not dynamically require "'+n+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}function no(n,t){if(n.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),r=0;r<e.length;r++)e[r]=255;for(var o=0;o<n.length;o++){var s=n.charAt(o),i=s.charCodeAt(0);if(e[i]!==255)throw new TypeError(s+" is ambiguous");e[i]=o}var a=n.length,c=n.charAt(0),d=Math.log(a)/Math.log(256),l=Math.log(256)/Math.log(a);function f(u){if(u instanceof Uint8Array||(ArrayBuffer.isView(u)?u=new Uint8Array(u.buffer,u.byteOffset,u.byteLength):Array.isArray(u)&&(u=Uint8Array.from(u))),!(u instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(u.length===0)return"";for(var p=0,S=0,g=0,D=u.length;g!==D&&u[g]===0;)g++,p++;for(var v=(D-g)*l+1>>>0,b=new Uint8Array(v);g!==D;){for(var m=u[g],C=0,w=v-1;(m!==0||C<S)&&w!==-1;w--,C++)m+=256*b[w]>>>0,b[w]=m%a>>>0,m=m/a>>>0;if(m!==0)throw new Error("Non-zero carry");S=C,g++}for(var $=v-S;$!==v&&b[$]===0;)$++;for(var R=c.repeat(p);$<v;++$)R+=n.charAt(b[$]);return R}function h(u){if(typeof u!="string")throw new TypeError("Expected String");if(u.length===0)return new Uint8Array;var p=0;if(u[p]!==" "){for(var S=0,g=0;u[p]===c;)S++,p++;for(var D=(u.length-p)*d+1>>>0,v=new Uint8Array(D);u[p];){var b=e[u.charCodeAt(p)];if(b===255)return;for(var m=0,C=D-1;(b!==0||m<g)&&C!==-1;C--,m++)b+=a*v[C]>>>0,v[C]=b%256>>>0,b=b/256>>>0;if(b!==0)throw new Error("Non-zero carry");g=m,p++}if(u[p]!==" "){for(var w=D-g;w!==D&&v[w]===0;)w++;for(var $=new Uint8Array(S+(D-w)),R=S;w!==D;)$[R++]=v[w++];return $}}}function y(u){var p=h(u);if(p)return p;throw new Error(`Non-${t} character`)}return{encode:f,decodeUnsafe:h,decode:y}}var oo=no,so=oo;const io=(n,t)=>{if(n===t)return!0;if(n.byteLength!==t.byteLength)return!1;for(let e=0;e<n.byteLength;e++)if(n[e]!==t[e])return!1;return!0},Jt=n=>{if(n instanceof Uint8Array&&n.constructor.name==="Uint8Array")return n;if(n instanceof ArrayBuffer)return new Uint8Array(n);if(ArrayBuffer.isView(n))return new Uint8Array(n.buffer,n.byteOffset,n.byteLength);throw new Error("Unknown type, must be binary type")},ao=n=>new TextEncoder().encode(n),co=n=>new TextDecoder().decode(n);let uo=class{constructor(t,e,r){this.name=t,this.prefix=e,this.baseEncode=r}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}},lo=class{constructor(t,e,r){if(this.name=t,this.prefix=e,e.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=e.codePointAt(0),this.baseDecode=r}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return Lr(this,t)}},fo=class{constructor(t){this.decoders=t}or(t){return Lr(this,t)}decode(t){const e=t[0],r=this.decoders[e];if(r)return r.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};const Lr=(n,t)=>new fo({...n.decoders||{[n.prefix]:n},...t.decoders||{[t.prefix]:t}});let po=class{constructor(t,e,r,o){this.name=t,this.prefix=e,this.baseEncode=r,this.baseDecode=o,this.encoder=new uo(t,e,r),this.decoder=new lo(t,e,o)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}};const rt=({name:n,prefix:t,encode:e,decode:r})=>new po(n,t,e,r),Se=({prefix:n,name:t,alphabet:e})=>{const{encode:r,decode:o}=so(e,t);return rt({prefix:n,name:t,encode:r,decode:s=>Jt(o(s))})},ho=(n,t,e,r)=>{const o={};for(let l=0;l<t.length;++l)o[t[l]]=l;let s=n.length;for(;n[s-1]==="=";)--s;const i=new Uint8Array(s*e/8|0);let a=0,c=0,d=0;for(let l=0;l<s;++l){const f=o[n[l]];if(f===void 0)throw new SyntaxError(`Non-${r} character`);c=c<<e|f,a+=e,a>=8&&(a-=8,i[d++]=255&c>>a)}if(a>=e||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return i},yo=(n,t,e)=>{const r=t[t.length-1]==="=",o=(1<<e)-1;let s="",i=0,a=0;for(let c=0;c<n.length;++c)for(a=a<<8|n[c],i+=8;i>e;)i-=e,s+=t[o&a>>i];if(i&&(s+=t[o&a<<e-i]),r)for(;s.length*e&7;)s+="=";return s},B=({name:n,prefix:t,bitsPerChar:e,alphabet:r})=>rt({prefix:t,name:n,encode(o){return yo(o,r,e)},decode(o){return ho(o,r,e,n)}}),Q=Se({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),bo=Se({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),go=Object.freeze(Object.defineProperty({__proto__:null,base58btc:Q,base58flickr:bo},Symbol.toStringTag,{value:"Module"})),ae=B({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),wo=B({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Do=B({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),vo=B({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),mo=B({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Eo=B({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),$o=B({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Co=B({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Oo=B({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),So=Object.freeze(Object.defineProperty({__proto__:null,base32:ae,base32hex:mo,base32hexpad:$o,base32hexpadupper:Co,base32hexupper:Eo,base32pad:Do,base32padupper:vo,base32upper:wo,base32z:Oo},Symbol.toStringTag,{value:"Module"})),Ao=B({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),xo=B({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),_o=B({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Po=B({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),jo=Object.freeze(Object.defineProperty({__proto__:null,base64:Ao,base64pad:xo,base64url:_o,base64urlpad:Po},Symbol.toStringTag,{value:"Module"}));var ko=Kr,ir=128,Ro=127,To=~Ro,Io=Math.pow(2,31);function Kr(n,t,e){t=t||[],e=e||0;for(var r=e;n>=Io;)t[e++]=n&255|ir,n/=128;for(;n&To;)t[e++]=n&255|ir,n>>>=7;return t[e]=n|0,Kr.bytes=e-r+1,t}var Mo=xt,Bo=128,ar=127;function xt(n,r){var e=0,r=r||0,o=0,s=r,i,a=n.length;do{if(s>=a)throw xt.bytes=0,new RangeError("Could not decode varint");i=n[s++],e+=o<28?(i&ar)<<o:(i&ar)*Math.pow(2,o),o+=7}while(i>=Bo);return xt.bytes=s-r,e}var No=Math.pow(2,7),zo=Math.pow(2,14),Uo=Math.pow(2,21),Fo=Math.pow(2,28),qo=Math.pow(2,35),Lo=Math.pow(2,42),Ko=Math.pow(2,49),Vo=Math.pow(2,56),Jo=Math.pow(2,63),Wo=function(n){return n<No?1:n<zo?2:n<Uo?3:n<Fo?4:n<qo?5:n<Lo?6:n<Ko?7:n<Vo?8:n<Jo?9:10},Go={encode:ko,decode:Mo,encodingLength:Wo},Ve=Go;const _t=(n,t=0)=>[Ve.decode(n,t),Ve.decode.bytes],Je=(n,t,e=0)=>(Ve.encode(n,t,e),t),We=n=>Ve.encodingLength(n),Qo=(n,t)=>{const e=t.byteLength,r=We(n),o=r+We(e),s=new Uint8Array(o+e);return Je(n,s,0),Je(e,s,r),s.set(t,o),new Wt(n,e,t,s)},Vr=n=>{const t=Jt(n),[e,r]=_t(t),[o,s]=_t(t.subarray(r)),i=t.subarray(r+s);if(i.byteLength!==o)throw new Error("Incorrect length");return new Wt(e,o,i,t)},Yo=(n,t)=>{if(n===t)return!0;{const e=t;return n.code===e.code&&n.size===e.size&&e.bytes instanceof Uint8Array&&io(n.bytes,e.bytes)}};let Wt=class{constructor(t,e,r,o){this.code=t,this.size=e,this.digest=r,this.bytes=o}};const cr=(n,t)=>{const{bytes:e,version:r}=n;switch(r){case 0:return Zo(e,Pt(n),t||Q.encoder);default:return Ho(e,Pt(n),t||ae.encoder)}},ur=new WeakMap,Pt=n=>{const t=ur.get(n);if(t==null){const e=new Map;return ur.set(n,e),e}return t};let Jr=class F{constructor(t,e,r,o){this.code=e,this.version=t,this.multihash=r,this.bytes=o,this["/"]=o}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:t,multihash:e}=this;if(t!==we)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(e.code!==es)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return F.createV0(e)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:t,digest:e}=this.multihash,r=Qo(t,e);return F.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return F.equals(this,t)}static equals(t,e){const r=e;return r&&t.code===r.code&&t.version===r.version&&Yo(t.multihash,r.multihash)}toString(t){return cr(this,t)}toJSON(){return{"/":cr(this)}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(t){if(t==null)return null;const e=t;if(e instanceof F)return e;if(e["/"]!=null&&e["/"]===e.bytes||e.asCID===e){const{version:r,code:o,multihash:s,bytes:i}=e;return new F(r,o,s,i||lr(r,o,s.bytes))}else if(e[ts]===!0){const{version:r,multihash:o,code:s}=e,i=Vr(o);return F.create(r,s,i)}else return null}static create(t,e,r){if(typeof e!="number")throw new Error("String codecs are no longer supported");if(!(r.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:{if(e!==we)throw new Error(`Version 0 CID must use dag-pb (code: ${we}) block encoding`);return new F(t,e,r,r.bytes)}case 1:{const o=lr(t,e,r.bytes);return new F(t,e,r,o)}default:throw new Error("Invalid version")}}static createV0(t){return F.create(0,we,t)}static createV1(t,e){return F.create(1,t,e)}static decode(t){const[e,r]=F.decodeFirst(t);if(r.length)throw new Error("Incorrect length");return e}static decodeFirst(t){const e=F.inspectBytes(t),r=e.size-e.multihashSize,o=Jt(t.subarray(r,r+e.multihashSize));if(o.byteLength!==e.multihashSize)throw new Error("Incorrect length");const s=o.subarray(e.multihashSize-e.digestSize),i=new Wt(e.multihashCode,e.digestSize,s,o);return[e.version===0?F.createV0(i):F.createV1(e.codec,i),t.subarray(e.size)]}static inspectBytes(t){let e=0;const r=()=>{const[f,h]=_t(t.subarray(e));return e+=h,f};let o=r(),s=we;if(o===18?(o=0,e=0):s=r(),o!==0&&o!==1)throw new RangeError(`Invalid CID version ${o}`);const i=e,a=r(),c=r(),d=e+c,l=d-i;return{version:o,codec:s,multihashCode:a,digestSize:c,multihashSize:l,size:d}}static parse(t,e){const[r,o]=Xo(t,e),s=F.decode(o);if(s.version===0&&t[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return Pt(s).set(r,t),s}};const Xo=(n,t)=>{switch(n[0]){case"Q":{const e=t||Q;return[Q.prefix,e.decode(`${Q.prefix}${n}`)]}case Q.prefix:{const e=t||Q;return[Q.prefix,e.decode(n)]}case ae.prefix:{const e=t||ae;return[ae.prefix,e.decode(n)]}default:{if(t==null)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[n[0],t.decode(n)]}}},Zo=(n,t,e)=>{const{prefix:r}=e;if(r!==Q.prefix)throw Error(`Cannot string encode V0 in ${e.name} encoding`);const o=t.get(r);if(o==null){const s=e.encode(n).slice(1);return t.set(r,s),s}else return o},Ho=(n,t,e)=>{const{prefix:r}=e,o=t.get(r);if(o==null){const s=e.encode(n);return t.set(r,s),s}else return o},we=112,es=18,lr=(n,t,e)=>{const r=We(n),o=r+We(t),s=new Uint8Array(o+e.byteLength);return Je(n,s,0),Je(t,s,r),s.set(e,o),s},ts=Symbol.for("@ipld/js-cid/CID"),rs=rt({prefix:"\0",name:"identity",encode:n=>co(n),decode:n=>ao(n)}),ns=Object.freeze(Object.defineProperty({__proto__:null,identity:rs},Symbol.toStringTag,{value:"Module"})),os=B({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),ss=Object.freeze(Object.defineProperty({__proto__:null,base2:os},Symbol.toStringTag,{value:"Module"})),is=B({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),as=Object.freeze(Object.defineProperty({__proto__:null,base8:is},Symbol.toStringTag,{value:"Module"})),cs=Se({prefix:"9",name:"base10",alphabet:"0123456789"}),us=Object.freeze(Object.defineProperty({__proto__:null,base10:cs},Symbol.toStringTag,{value:"Module"})),ls=B({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),ds=B({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),fs=Object.freeze(Object.defineProperty({__proto__:null,base16:ls,base16upper:ds},Symbol.toStringTag,{value:"Module"})),ps=Se({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),hs=Se({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),ys=Object.freeze(Object.defineProperty({__proto__:null,base36:ps,base36upper:hs},Symbol.toStringTag,{value:"Module"})),Wr=Array.from("ðŸš€ðŸªâ˜„ðŸ›°ðŸŒŒðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜ðŸŒðŸŒðŸŒŽðŸ‰â˜€ðŸ’»ðŸ–¥ðŸ’¾ðŸ’¿ðŸ˜‚â¤ðŸ˜ðŸ¤£ðŸ˜ŠðŸ™ðŸ’•ðŸ˜­ðŸ˜˜ðŸ‘ðŸ˜…ðŸ‘ðŸ˜ðŸ”¥ðŸ¥°ðŸ’”ðŸ’–ðŸ’™ðŸ˜¢ðŸ¤”ðŸ˜†ðŸ™„ðŸ’ªðŸ˜‰â˜ºðŸ‘ŒðŸ¤—ðŸ’œðŸ˜”ðŸ˜ŽðŸ˜‡ðŸŒ¹ðŸ¤¦ðŸŽ‰ðŸ’žâœŒâœ¨ðŸ¤·ðŸ˜±ðŸ˜ŒðŸŒ¸ðŸ™ŒðŸ˜‹ðŸ’—ðŸ’šðŸ˜ðŸ’›ðŸ™‚ðŸ’“ðŸ¤©ðŸ˜„ðŸ˜€ðŸ–¤ðŸ˜ƒðŸ’¯ðŸ™ˆðŸ‘‡ðŸŽ¶ðŸ˜’ðŸ¤­â£ðŸ˜œðŸ’‹ðŸ‘€ðŸ˜ªðŸ˜‘ðŸ’¥ðŸ™‹ðŸ˜žðŸ˜©ðŸ˜¡ðŸ¤ªðŸ‘ŠðŸ¥³ðŸ˜¥ðŸ¤¤ðŸ‘‰ðŸ’ƒðŸ˜³âœ‹ðŸ˜šðŸ˜ðŸ˜´ðŸŒŸðŸ˜¬ðŸ™ƒðŸ€ðŸŒ·ðŸ˜»ðŸ˜“â­âœ…ðŸ¥ºðŸŒˆðŸ˜ˆðŸ¤˜ðŸ’¦âœ”ðŸ˜£ðŸƒðŸ’â˜¹ðŸŽŠðŸ’˜ðŸ˜ â˜ðŸ˜•ðŸŒºðŸŽ‚ðŸŒ»ðŸ˜ðŸ–•ðŸ’ðŸ™ŠðŸ˜¹ðŸ—£ðŸ’«ðŸ’€ðŸ‘‘ðŸŽµðŸ¤žðŸ˜›ðŸ”´ðŸ˜¤ðŸŒ¼ðŸ˜«âš½ðŸ¤™â˜•ðŸ†ðŸ¤«ðŸ‘ˆðŸ˜®ðŸ™†ðŸ»ðŸƒðŸ¶ðŸ’ðŸ˜²ðŸŒ¿ðŸ§¡ðŸŽâš¡ðŸŒžðŸŽˆâŒâœŠðŸ‘‹ðŸ˜°ðŸ¤¨ðŸ˜¶ðŸ¤ðŸš¶ðŸ’°ðŸ“ðŸ’¢ðŸ¤ŸðŸ™ðŸš¨ðŸ’¨ðŸ¤¬âœˆðŸŽ€ðŸºðŸ¤“ðŸ˜™ðŸ’ŸðŸŒ±ðŸ˜–ðŸ‘¶ðŸ¥´â–¶âž¡â“ðŸ’ŽðŸ’¸â¬‡ðŸ˜¨ðŸŒšðŸ¦‹ðŸ˜·ðŸ•ºâš ðŸ™…ðŸ˜ŸðŸ˜µðŸ‘ŽðŸ¤²ðŸ¤ ðŸ¤§ðŸ“ŒðŸ”µðŸ’…ðŸ§ðŸ¾ðŸ’ðŸ˜—ðŸ¤‘ðŸŒŠðŸ¤¯ðŸ·â˜ŽðŸ’§ðŸ˜¯ðŸ’†ðŸ‘†ðŸŽ¤ðŸ™‡ðŸ‘â„ðŸŒ´ðŸ’£ðŸ¸ðŸ’ŒðŸ“ðŸ¥€ðŸ¤¢ðŸ‘…ðŸ’¡ðŸ’©ðŸ‘ðŸ“¸ðŸ‘»ðŸ¤ðŸ¤®ðŸŽ¼ðŸ¥µðŸš©ðŸŽðŸŠðŸ‘¼ðŸ’ðŸ“£ðŸ¥‚"),bs=Wr.reduce((n,t,e)=>(n[e]=t,n),[]),gs=Wr.reduce((n,t,e)=>(n[t.codePointAt(0)]=e,n),[]);function ws(n){return n.reduce((t,e)=>(t+=bs[e],t),"")}function Ds(n){const t=[];for(const e of n){const r=gs[e.codePointAt(0)];if(r===void 0)throw new Error(`Non-base256emoji character: ${e}`);t.push(r)}return new Uint8Array(t)}const vs=rt({prefix:"ðŸš€",name:"base256emoji",encode:ws,decode:Ds}),ms=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:vs},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;const Es={...ns,...ss,...as,...us,...fs,...So,...ys,...go,...jo,...ms};function $s(n,t){if(n.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),r=0;r<e.length;r++)e[r]=255;for(var o=0;o<n.length;o++){var s=n.charAt(o),i=s.charCodeAt(0);if(e[i]!==255)throw new TypeError(s+" is ambiguous");e[i]=o}var a=n.length,c=n.charAt(0),d=Math.log(a)/Math.log(256),l=Math.log(256)/Math.log(a);function f(u){if(u instanceof Uint8Array||(ArrayBuffer.isView(u)?u=new Uint8Array(u.buffer,u.byteOffset,u.byteLength):Array.isArray(u)&&(u=Uint8Array.from(u))),!(u instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(u.length===0)return"";for(var p=0,S=0,g=0,D=u.length;g!==D&&u[g]===0;)g++,p++;for(var v=(D-g)*l+1>>>0,b=new Uint8Array(v);g!==D;){for(var m=u[g],C=0,w=v-1;(m!==0||C<S)&&w!==-1;w--,C++)m+=256*b[w]>>>0,b[w]=m%a>>>0,m=m/a>>>0;if(m!==0)throw new Error("Non-zero carry");S=C,g++}for(var $=v-S;$!==v&&b[$]===0;)$++;for(var R=c.repeat(p);$<v;++$)R+=n.charAt(b[$]);return R}function h(u){if(typeof u!="string")throw new TypeError("Expected String");if(u.length===0)return new Uint8Array;var p=0;if(u[p]!==" "){for(var S=0,g=0;u[p]===c;)S++,p++;for(var D=(u.length-p)*d+1>>>0,v=new Uint8Array(D);u[p];){var b=e[u.charCodeAt(p)];if(b===255)return;for(var m=0,C=D-1;(b!==0||m<g)&&C!==-1;C--,m++)b+=a*v[C]>>>0,v[C]=b%256>>>0,b=b/256>>>0;if(b!==0)throw new Error("Non-zero carry");g=m,p++}if(u[p]!==" "){for(var w=D-g;w!==D&&v[w]===0;)w++;for(var $=new Uint8Array(S+(D-w)),R=S;w!==D;)$[R++]=v[w++];return $}}}function y(u){var p=h(u);if(p)return p;throw new Error(`Non-${t} character`)}return{encode:f,decodeUnsafe:h,decode:y}}var Cs=$s,Os=Cs;const Ss=n=>{if(n instanceof Uint8Array&&n.constructor.name==="Uint8Array")return n;if(n instanceof ArrayBuffer)return new Uint8Array(n);if(ArrayBuffer.isView(n))return new Uint8Array(n.buffer,n.byteOffset,n.byteLength);throw new Error("Unknown type, must be binary type")},As=n=>new TextEncoder().encode(n),xs=n=>new TextDecoder().decode(n);let _s=class{constructor(t,e,r){this.name=t,this.prefix=e,this.baseEncode=r}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}},Ps=class{constructor(t,e,r){if(this.name=t,this.prefix=e,e.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=e.codePointAt(0),this.baseDecode=r}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return Gr(this,t)}},js=class{constructor(t){this.decoders=t}or(t){return Gr(this,t)}decode(t){const e=t[0],r=this.decoders[e];if(r)return r.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};const Gr=(n,t)=>new js({...n.decoders||{[n.prefix]:n},...t.decoders||{[t.prefix]:t}});let ks=class{constructor(t,e,r,o){this.name=t,this.prefix=e,this.baseEncode=r,this.baseDecode=o,this.encoder=new _s(t,e,r),this.decoder=new Ps(t,e,o)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}};const nt=({name:n,prefix:t,encode:e,decode:r})=>new ks(n,t,e,r),Ae=({prefix:n,name:t,alphabet:e})=>{const{encode:r,decode:o}=Os(e,t);return nt({prefix:n,name:t,encode:r,decode:s=>Ss(o(s))})},Rs=(n,t,e,r)=>{const o={};for(let l=0;l<t.length;++l)o[t[l]]=l;let s=n.length;for(;n[s-1]==="=";)--s;const i=new Uint8Array(s*e/8|0);let a=0,c=0,d=0;for(let l=0;l<s;++l){const f=o[n[l]];if(f===void 0)throw new SyntaxError(`Non-${r} character`);c=c<<e|f,a+=e,a>=8&&(a-=8,i[d++]=255&c>>a)}if(a>=e||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return i},Ts=(n,t,e)=>{const r=t[t.length-1]==="=",o=(1<<e)-1;let s="",i=0,a=0;for(let c=0;c<n.length;++c)for(a=a<<8|n[c],i+=8;i>e;)i-=e,s+=t[o&a>>i];if(i&&(s+=t[o&a<<e-i]),r)for(;s.length*e&7;)s+="=";return s},N=({name:n,prefix:t,bitsPerChar:e,alphabet:r})=>nt({prefix:t,name:n,encode(o){return Ts(o,r,e)},decode(o){return Rs(o,r,e,n)}}),Is=Ae({prefix:"9",name:"base10",alphabet:"0123456789"}),Ms=Object.freeze(Object.defineProperty({__proto__:null,base10:Is},Symbol.toStringTag,{value:"Module"})),Bs=N({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Ns=N({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),zs=Object.freeze(Object.defineProperty({__proto__:null,base16:Bs,base16upper:Ns},Symbol.toStringTag,{value:"Module"})),Us=N({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),Fs=Object.freeze(Object.defineProperty({__proto__:null,base2:Us},Symbol.toStringTag,{value:"Module"})),Qr=Array.from("ðŸš€ðŸªâ˜„ðŸ›°ðŸŒŒðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜ðŸŒðŸŒðŸŒŽðŸ‰â˜€ðŸ’»ðŸ–¥ðŸ’¾ðŸ’¿ðŸ˜‚â¤ðŸ˜ðŸ¤£ðŸ˜ŠðŸ™ðŸ’•ðŸ˜­ðŸ˜˜ðŸ‘ðŸ˜…ðŸ‘ðŸ˜ðŸ”¥ðŸ¥°ðŸ’”ðŸ’–ðŸ’™ðŸ˜¢ðŸ¤”ðŸ˜†ðŸ™„ðŸ’ªðŸ˜‰â˜ºðŸ‘ŒðŸ¤—ðŸ’œðŸ˜”ðŸ˜ŽðŸ˜‡ðŸŒ¹ðŸ¤¦ðŸŽ‰ðŸ’žâœŒâœ¨ðŸ¤·ðŸ˜±ðŸ˜ŒðŸŒ¸ðŸ™ŒðŸ˜‹ðŸ’—ðŸ’šðŸ˜ðŸ’›ðŸ™‚ðŸ’“ðŸ¤©ðŸ˜„ðŸ˜€ðŸ–¤ðŸ˜ƒðŸ’¯ðŸ™ˆðŸ‘‡ðŸŽ¶ðŸ˜’ðŸ¤­â£ðŸ˜œðŸ’‹ðŸ‘€ðŸ˜ªðŸ˜‘ðŸ’¥ðŸ™‹ðŸ˜žðŸ˜©ðŸ˜¡ðŸ¤ªðŸ‘ŠðŸ¥³ðŸ˜¥ðŸ¤¤ðŸ‘‰ðŸ’ƒðŸ˜³âœ‹ðŸ˜šðŸ˜ðŸ˜´ðŸŒŸðŸ˜¬ðŸ™ƒðŸ€ðŸŒ·ðŸ˜»ðŸ˜“â­âœ…ðŸ¥ºðŸŒˆðŸ˜ˆðŸ¤˜ðŸ’¦âœ”ðŸ˜£ðŸƒðŸ’â˜¹ðŸŽŠðŸ’˜ðŸ˜ â˜ðŸ˜•ðŸŒºðŸŽ‚ðŸŒ»ðŸ˜ðŸ–•ðŸ’ðŸ™ŠðŸ˜¹ðŸ—£ðŸ’«ðŸ’€ðŸ‘‘ðŸŽµðŸ¤žðŸ˜›ðŸ”´ðŸ˜¤ðŸŒ¼ðŸ˜«âš½ðŸ¤™â˜•ðŸ†ðŸ¤«ðŸ‘ˆðŸ˜®ðŸ™†ðŸ»ðŸƒðŸ¶ðŸ’ðŸ˜²ðŸŒ¿ðŸ§¡ðŸŽâš¡ðŸŒžðŸŽˆâŒâœŠðŸ‘‹ðŸ˜°ðŸ¤¨ðŸ˜¶ðŸ¤ðŸš¶ðŸ’°ðŸ“ðŸ’¢ðŸ¤ŸðŸ™ðŸš¨ðŸ’¨ðŸ¤¬âœˆðŸŽ€ðŸºðŸ¤“ðŸ˜™ðŸ’ŸðŸŒ±ðŸ˜–ðŸ‘¶ðŸ¥´â–¶âž¡â“ðŸ’ŽðŸ’¸â¬‡ðŸ˜¨ðŸŒšðŸ¦‹ðŸ˜·ðŸ•ºâš ðŸ™…ðŸ˜ŸðŸ˜µðŸ‘ŽðŸ¤²ðŸ¤ ðŸ¤§ðŸ“ŒðŸ”µðŸ’…ðŸ§ðŸ¾ðŸ’ðŸ˜—ðŸ¤‘ðŸŒŠðŸ¤¯ðŸ·â˜ŽðŸ’§ðŸ˜¯ðŸ’†ðŸ‘†ðŸŽ¤ðŸ™‡ðŸ‘â„ðŸŒ´ðŸ’£ðŸ¸ðŸ’ŒðŸ“ðŸ¥€ðŸ¤¢ðŸ‘…ðŸ’¡ðŸ’©ðŸ‘ðŸ“¸ðŸ‘»ðŸ¤ðŸ¤®ðŸŽ¼ðŸ¥µðŸš©ðŸŽðŸŠðŸ‘¼ðŸ’ðŸ“£ðŸ¥‚"),qs=Qr.reduce((n,t,e)=>(n[e]=t,n),[]),Ls=Qr.reduce((n,t,e)=>(n[t.codePointAt(0)]=e,n),[]);function Ks(n){return n.reduce((t,e)=>(t+=qs[e],t),"")}function Vs(n){const t=[];for(const e of n){const r=Ls[e.codePointAt(0)];if(r===void 0)throw new Error(`Non-base256emoji character: ${e}`);t.push(r)}return new Uint8Array(t)}const Js=nt({prefix:"ðŸš€",name:"base256emoji",encode:Ks,decode:Vs}),Ws=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:Js},Symbol.toStringTag,{value:"Module"})),Gs=N({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Qs=N({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Ys=N({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Xs=N({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Zs=N({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Hs=N({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),ei=N({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),ti=N({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),ri=N({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),ni=Object.freeze(Object.defineProperty({__proto__:null,base32:Gs,base32hex:Zs,base32hexpad:ei,base32hexpadupper:ti,base32hexupper:Hs,base32pad:Ys,base32padupper:Xs,base32upper:Qs,base32z:ri},Symbol.toStringTag,{value:"Module"})),oi=Ae({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),si=Ae({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),ii=Object.freeze(Object.defineProperty({__proto__:null,base36:oi,base36upper:si},Symbol.toStringTag,{value:"Module"})),ai=Ae({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),ci=Ae({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),ui=Object.freeze(Object.defineProperty({__proto__:null,base58btc:ai,base58flickr:ci},Symbol.toStringTag,{value:"Module"})),li=N({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),di=N({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),fi=N({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),pi=N({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),hi=Object.freeze(Object.defineProperty({__proto__:null,base64:li,base64pad:di,base64url:fi,base64urlpad:pi},Symbol.toStringTag,{value:"Module"})),yi=N({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),bi=Object.freeze(Object.defineProperty({__proto__:null,base8:yi},Symbol.toStringTag,{value:"Module"})),gi=nt({prefix:"\0",name:"identity",encode:n=>xs(n),decode:n=>As(n)}),wi=Object.freeze(Object.defineProperty({__proto__:null,identity:gi},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;const Gl={...wi,...Fs,...bi,...Ms,...zs,...ni,...ii,...ui,...hi,...Ws},dr=kn,Di=Rn,Yr=function(n){let t=0;if(n=n.toString().trim(),dr(n)){const e=new Uint8Array(t+4);return n.split(/\./g).forEach(r=>{e[t++]=parseInt(r,10)&255}),e}if(Di(n)){const e=n.split(":",8);let r;for(r=0;r<e.length;r++){const s=dr(e[r]);let i;s&&(i=Yr(e[r]),e[r]=X(i.slice(0,2),"base16")),i!=null&&++r<8&&e.splice(r,0,X(i.slice(2,4),"base16"))}if(e[0]==="")for(;e.length<8;)e.unshift("0");else if(e[e.length-1]==="")for(;e.length<8;)e.push("0");else if(e.length<8){for(r=0;r<e.length&&e[r]!=="";r++);const s=[r,1];for(r=9-e.length;r>0;r--)s.push("0");e.splice.apply(e,s)}const o=new Uint8Array(t+16);for(r=0;r<e.length;r++){const s=parseInt(e[r],16);o[t++]=s>>8&255,o[t++]=s&255}return o}throw new Error("invalid ip address")},vi=function(n,t=0,e){t=~~t,e=e??n.length-t;const r=new DataView(n.buffer);if(e===4){const o=[];for(let s=0;s<e;s++)o.push(n[t+s]);return o.join(".")}if(e===16){const o=[];for(let s=0;s<e;s+=2)o.push(r.getUint16(t+s).toString(16));return o.join(":").replace(/(^|:)0(:0)*:0(:|$)/,"$1::$3").replace(/:{3,4}/,"::")}return""},V=-1,Ge={},jt={},mi=[[4,32,"ip4"],[6,16,"tcp"],[33,16,"dccp"],[41,128,"ip6"],[42,V,"ip6zone"],[43,8,"ipcidr"],[53,V,"dns",!0],[54,V,"dns4",!0],[55,V,"dns6",!0],[56,V,"dnsaddr",!0],[132,16,"sctp"],[273,16,"udp"],[275,0,"p2p-webrtc-star"],[276,0,"p2p-webrtc-direct"],[277,0,"p2p-stardust"],[280,0,"webrtc"],[281,0,"webrtc-w3c"],[290,0,"p2p-circuit"],[301,0,"udt"],[302,0,"utp"],[400,V,"unix",!1,!0],[421,V,"ipfs"],[421,V,"p2p"],[443,0,"https"],[444,96,"onion"],[445,296,"onion3"],[446,V,"garlic64"],[448,0,"tls"],[449,V,"sni"],[460,0,"quic"],[461,0,"quic-v1"],[465,0,"webtransport"],[466,V,"certhash"],[477,0,"ws"],[478,0,"wss"],[479,0,"p2p-websocket-star"],[480,0,"http"],[777,V,"memory"]];mi.forEach(n=>{const t=Ei(...n);jt[t.code]=t,Ge[t.name]=t});function Ei(n,t,e,r,o){return{code:n,size:t,name:e,resolvable:!!r,path:!!o}}function k(n){if(typeof n=="number"){if(jt[n]!=null)return jt[n];throw new Error(`no protocol with code: ${n}`)}else if(typeof n=="string"){if(Ge[n]!=null)return Ge[n];throw new Error(`no protocol with name: ${n}`)}throw new Error(`invalid protocol id type: ${typeof n}`)}function $i(n,t){switch(k(n).code){case 4:case 41:return Si(t);case 42:return hr(t);case 6:case 273:case 33:case 132:return Xr(t).toString();case 53:case 54:case 55:case 56:case 400:case 449:case 777:return hr(t);case 421:return Pi(t);case 444:return yr(t);case 445:return yr(t);case 466:return _i(t);default:return X(t,"base16")}}function Ci(n,t){switch(k(n).code){case 4:return fr(t);case 41:return fr(t);case 42:return pr(t);case 6:case 273:case 33:case 132:return Gt(parseInt(t,10));case 53:case 54:case 55:case 56:case 400:case 449:case 777:return pr(t);case 421:return Ai(t);case 444:return ji(t);case 445:return ki(t);case 466:return xi(t);default:return Ur(t,"base16")}}const bt=Object.values(Es).map(n=>n.decoder),Oi=function(){let n=bt[0].or(bt[1]);return bt.slice(2).forEach(t=>n=n.or(t)),n}();function fr(n){if(!zr(n))throw new Error("invalid ip address");return Yr(n)}function Si(n){const t=vi(n,0,n.length);if(t==null)throw new Error("ipBuff is required");if(!zr(t))throw new Error("invalid ip address");return t}function Gt(n){const t=new ArrayBuffer(2);return new DataView(t).setUint16(0,n),new Uint8Array(t)}function Xr(n){return new DataView(n.buffer).getUint16(n.byteOffset)}function pr(n){const t=Ur(n),e=Uint8Array.from(T.encode(t.length));return ce([e,t],e.length+t.length)}function hr(n){const t=T.decode(n);if(n=n.slice(T.decode.bytes),n.length!==t)throw new Error("inconsistent lengths");return X(n)}function Ai(n){let t;n[0]==="Q"||n[0]==="1"?t=Vr(Q.decode(`z${n}`)).bytes:t=Jr.parse(n).multihash.bytes;const e=Uint8Array.from(T.encode(t.length));return ce([e,t],e.length+t.length)}function xi(n){const t=Oi.decode(n),e=Uint8Array.from(T.encode(t.length));return ce([e,t],e.length+t.length)}function _i(n){const t=T.decode(n),e=n.slice(T.decode.bytes);if(e.length!==t)throw new Error("inconsistent lengths");return"u"+X(e,"base64url")}function Pi(n){const t=T.decode(n),e=n.slice(T.decode.bytes);if(e.length!==t)throw new Error("inconsistent lengths");return X(e,"base58btc")}function ji(n){const t=n.split(":");if(t.length!==2)throw new Error(`failed to parse onion addr: ["'${t.join('", "')}'"]' does not contain a port number`);if(t[0].length!==16)throw new Error(`failed to parse onion addr: ${t[0]} not a Tor onion address.`);const e=ae.decode("b"+t[0]),r=parseInt(t[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const o=Gt(r);return ce([e,o],e.length+o.length)}function ki(n){const t=n.split(":");if(t.length!==2)throw new Error(`failed to parse onion addr: ["'${t.join('", "')}'"]' does not contain a port number`);if(t[0].length!==56)throw new Error(`failed to parse onion addr: ${t[0]} not a Tor onion3 address.`);const e=ae.decode(`b${t[0]}`),r=parseInt(t[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const o=Gt(r);return ce([e,o],e.length+o.length)}function yr(n){const t=n.slice(0,n.length-2),e=n.slice(n.length-2),r=X(t,"base32"),o=Xr(e);return`${r}:${o}`}function Ri(n){const t=[],e=n.split("/").slice(1);if(e.length===1&&e[0]==="")return[];for(let r=0;r<e.length;r++){const o=e[r],s=k(o);if(s.size===0){t.push([o]);continue}if(r++,r>=e.length)throw tn("invalid address: "+n);if(s.path===!0){t.push([o,Yt(e.slice(r).join("/"))]);break}t.push([o,e[r]])}return t}function Ti(n){const t=[];return n.map(e=>{const r=ot(e);return t.push(r.name),e.length>1&&e[1]!=null&&t.push(e[1]),null}),Yt(t.join("/"))}function Ii(n){return n.map(t=>{Array.isArray(t)||(t=[t]);const e=ot(t);return t.length>1?[e.code,Ci(e.code,t[1])]:[e.code]})}function Zr(n){return n.map(t=>{const e=ot(t);return t[1]!=null?[e.code,$i(e.code,t[1])]:[e.code]})}function Hr(n){return kt(ce(n.map(t=>{const e=ot(t);let r=Uint8Array.from(T.encode(e.code));return t.length>1&&t[1]!=null&&(r=ce([r,t[1]])),r})))}function en(n,t){return n.size>0?n.size/8:n.size===0?0:T.decode(t)+(T.decode.bytes??0)}function Qt(n){const t=[];let e=0;for(;e<n.length;){const r=T.decode(n,e),o=T.decode.bytes??0,s=k(r),i=en(s,n.slice(e+o));if(i===0){t.push([r]),e+=o;continue}const a=n.slice(e+o,e+o+i);if(e+=i+o,e>n.length)throw tn("Invalid address Uint8Array: "+X(n,"base16"));t.push([r,a])}return t}function br(n){const t=Qt(n),e=Zr(t);return Ti(e)}function Mi(n){n=Yt(n);const t=Ri(n),e=Ii(t);return Hr(e)}function Bi(n){return Mi(n)}function kt(n){const t=Ni(n);if(t!=null)throw t;return Uint8Array.from(n)}function Ni(n){try{Qt(n)}catch(t){return t}}function Yt(n){return"/"+n.trim().split("/").filter(t=>t).join("/")}function tn(n){return new Error("Error parsing address: "+n)}function ot(n){return k(n[0])}var le=globalThis&&globalThis.__classPrivateFieldGet||function(n,t,e,r){if(e==="a"&&!r)throw new TypeError("Private accessor was defined without a getter");if(typeof t=="function"?n!==t||!r:!t.has(n))throw new TypeError("Cannot read private member from an object whose class did not declare it");return e==="m"?r:e==="a"?r.call(n):r?r.value:t.get(n)},gt=globalThis&&globalThis.__classPrivateFieldSet||function(n,t,e,r,o){if(r==="m")throw new TypeError("Private method is not writable");if(r==="a"&&!o)throw new TypeError("Private accessor was defined without a setter");if(typeof t=="function"?n!==t||!o:!t.has(n))throw new TypeError("Cannot write private member to an object whose class did not declare it");return r==="a"?o.call(n,e):o?o.value=e:t.set(n,e),e},De,ve,me,gr;const zi=Symbol.for("nodejs.util.inspect.custom"),Ui=[k("dns").code,k("dns4").code,k("dns6").code,k("dnsaddr").code],Fi=new Map,rn=Symbol.for("@multiformats/js-multiaddr/multiaddr");function qi(n){return!!n?.[rn]}class ie{constructor(t){if(De.set(this,void 0),ve.set(this,void 0),me.set(this,void 0),this[gr]=!0,t==null&&(t=""),t instanceof Uint8Array)this.bytes=kt(t);else if(typeof t=="string"){if(t.length>0&&t.charAt(0)!=="/")throw new Error(`multiaddr "${t}" must start with a "/"`);this.bytes=Bi(t)}else if(qi(t))this.bytes=kt(t.bytes);else throw new Error("addr must be a string, Buffer, or another Multiaddr")}toString(){return le(this,De,"f")==null&&gt(this,De,br(this.bytes),"f"),le(this,De,"f")}toJSON(){return this.toString()}toOptions(){let t,e,r,o,s="";const i=k("tcp"),a=k("udp"),c=k("ip4"),d=k("ip6"),l=k("dns6"),f=k("ip6zone");for(const[y,u]of this.stringTuples())y===f.code&&(s=`%${u??""}`),Ui.includes(y)&&(e=i.name,o=443,r=`${u??""}${s}`,t=y===l.code?6:4),(y===i.code||y===a.code)&&(e=k(y).name,o=parseInt(u??"")),(y===c.code||y===d.code)&&(e=k(y).name,r=`${u??""}${s}`,t=y===d.code?6:4);if(t==null||e==null||r==null||o==null)throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');return{family:t,host:r,transport:e,port:o}}protos(){return this.protoCodes().map(t=>Object.assign({},k(t)))}protoCodes(){const t=[],e=this.bytes;let r=0;for(;r<e.length;){const o=T.decode(e,r),s=T.decode.bytes??0,i=k(o),a=en(i,e.slice(r+s));r+=a+s,t.push(o)}return t}protoNames(){return this.protos().map(t=>t.name)}tuples(){return le(this,ve,"f")==null&&gt(this,ve,Qt(this.bytes),"f"),le(this,ve,"f")}stringTuples(){return le(this,me,"f")==null&&gt(this,me,Zr(this.tuples()),"f"),le(this,me,"f")}encapsulate(t){return t=new ie(t),new ie(this.toString()+t.toString())}decapsulate(t){const e=t.toString(),r=this.toString(),o=r.lastIndexOf(e);if(o<0)throw new Error(`Address ${this.toString()} does not contain subaddress: ${t.toString()}`);return new ie(r.slice(0,o))}decapsulateCode(t){const e=this.tuples();for(let r=e.length-1;r>=0;r--)if(e[r][0]===t)return new ie(Hr(e.slice(0,r)));return this}getPeerId(){try{const e=this.stringTuples().filter(r=>r[0]===Ge.ipfs.code).pop();if(e?.[1]!=null){const r=e[1];return r[0]==="Q"||r[0]==="1"?X(Q.decode(`z${r}`),"base58btc"):X(Jr.parse(r).multihash.bytes,"base58btc")}return null}catch{return null}}getPath(){let t=null;try{t=this.stringTuples().filter(e=>k(e[0]).path===!0)[0][1],t==null&&(t=null)}catch{t=null}return t}equals(t){return Tn(this.bytes,t.bytes)}async resolve(t){const e=this.protos().find(s=>s.resolvable);if(e==null)return[this];const r=Fi.get(e.name);if(r==null)throw K(new Error(`no available resolver for ${e.name}`),"ERR_NO_AVAILABLE_RESOLVER");return(await r(this,t)).map(s=>new ie(s))}nodeAddress(){const t=this.toOptions();if(t.transport!=="tcp"&&t.transport!=="udp")throw new Error(`multiaddr must have a valid format - no protocol with name: "${t.transport}". Must have a valid transport protocol: "{tcp, udp}"`);return{family:t.family,address:t.host,port:t.port}}isThinWaistAddress(t){const e=(t??this).protos();return!(e.length!==2||e[0].code!==4&&e[0].code!==41||e[1].code!==6&&e[1].code!==273)}[(De=new WeakMap,ve=new WeakMap,me=new WeakMap,gr=rn,zi)](){return`Multiaddr(${br(this.bytes)})`}}function Rt(n){return new ie(n)}function Li(n,t){if(n.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),r=0;r<e.length;r++)e[r]=255;for(var o=0;o<n.length;o++){var s=n.charAt(o),i=s.charCodeAt(0);if(e[i]!==255)throw new TypeError(s+" is ambiguous");e[i]=o}var a=n.length,c=n.charAt(0),d=Math.log(a)/Math.log(256),l=Math.log(256)/Math.log(a);function f(u){if(u instanceof Uint8Array||(ArrayBuffer.isView(u)?u=new Uint8Array(u.buffer,u.byteOffset,u.byteLength):Array.isArray(u)&&(u=Uint8Array.from(u))),!(u instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(u.length===0)return"";for(var p=0,S=0,g=0,D=u.length;g!==D&&u[g]===0;)g++,p++;for(var v=(D-g)*l+1>>>0,b=new Uint8Array(v);g!==D;){for(var m=u[g],C=0,w=v-1;(m!==0||C<S)&&w!==-1;w--,C++)m+=256*b[w]>>>0,b[w]=m%a>>>0,m=m/a>>>0;if(m!==0)throw new Error("Non-zero carry");S=C,g++}for(var $=v-S;$!==v&&b[$]===0;)$++;for(var R=c.repeat(p);$<v;++$)R+=n.charAt(b[$]);return R}function h(u){if(typeof u!="string")throw new TypeError("Expected String");if(u.length===0)return new Uint8Array;var p=0;if(u[p]!==" "){for(var S=0,g=0;u[p]===c;)S++,p++;for(var D=(u.length-p)*d+1>>>0,v=new Uint8Array(D);u[p];){var b=e[u.charCodeAt(p)];if(b===255)return;for(var m=0,C=D-1;(b!==0||m<g)&&C!==-1;C--,m++)b+=a*v[C]>>>0,v[C]=b%256>>>0,b=b/256>>>0;if(b!==0)throw new Error("Non-zero carry");g=m,p++}if(u[p]!==" "){for(var w=D-g;w!==D&&v[w]===0;)w++;for(var $=new Uint8Array(S+(D-w)),R=S;w!==D;)$[R++]=v[w++];return $}}}function y(u){var p=h(u);if(p)return p;throw new Error(`Non-${t} character`)}return{encode:f,decodeUnsafe:h,decode:y}}var Ki=Li,Vi=Ki;const Ji=n=>{if(n instanceof Uint8Array&&n.constructor.name==="Uint8Array")return n;if(n instanceof ArrayBuffer)return new Uint8Array(n);if(ArrayBuffer.isView(n))return new Uint8Array(n.buffer,n.byteOffset,n.byteLength);throw new Error("Unknown type, must be binary type")},Wi=n=>new TextEncoder().encode(n),Gi=n=>new TextDecoder().decode(n);let Qi=class{constructor(t,e,r){this.name=t,this.prefix=e,this.baseEncode=r}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}},Yi=class{constructor(t,e,r){if(this.name=t,this.prefix=e,e.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=e.codePointAt(0),this.baseDecode=r}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return nn(this,t)}},Xi=class{constructor(t){this.decoders=t}or(t){return nn(this,t)}decode(t){const e=t[0],r=this.decoders[e];if(r)return r.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};const nn=(n,t)=>new Xi({...n.decoders||{[n.prefix]:n},...t.decoders||{[t.prefix]:t}});let Zi=class{constructor(t,e,r,o){this.name=t,this.prefix=e,this.baseEncode=r,this.baseDecode=o,this.encoder=new Qi(t,e,r),this.decoder=new Yi(t,e,o)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}};const st=({name:n,prefix:t,encode:e,decode:r})=>new Zi(n,t,e,r),xe=({prefix:n,name:t,alphabet:e})=>{const{encode:r,decode:o}=Vi(e,t);return st({prefix:n,name:t,encode:r,decode:s=>Ji(o(s))})},Hi=(n,t,e,r)=>{const o={};for(let l=0;l<t.length;++l)o[t[l]]=l;let s=n.length;for(;n[s-1]==="=";)--s;const i=new Uint8Array(s*e/8|0);let a=0,c=0,d=0;for(let l=0;l<s;++l){const f=o[n[l]];if(f===void 0)throw new SyntaxError(`Non-${r} character`);c=c<<e|f,a+=e,a>=8&&(a-=8,i[d++]=255&c>>a)}if(a>=e||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return i},ea=(n,t,e)=>{const r=t[t.length-1]==="=",o=(1<<e)-1;let s="",i=0,a=0;for(let c=0;c<n.length;++c)for(a=a<<8|n[c],i+=8;i>e;)i-=e,s+=t[o&a>>i];if(i&&(s+=t[o&a<<e-i]),r)for(;s.length*e&7;)s+="=";return s},z=({name:n,prefix:t,bitsPerChar:e,alphabet:r})=>st({prefix:t,name:n,encode(o){return ea(o,r,e)},decode(o){return Hi(o,r,e,n)}}),ta=st({prefix:"\0",name:"identity",encode:n=>Gi(n),decode:n=>Wi(n)}),ra=Object.freeze(Object.defineProperty({__proto__:null,identity:ta},Symbol.toStringTag,{value:"Module"})),na=z({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),oa=Object.freeze(Object.defineProperty({__proto__:null,base2:na},Symbol.toStringTag,{value:"Module"})),sa=z({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),ia=Object.freeze(Object.defineProperty({__proto__:null,base8:sa},Symbol.toStringTag,{value:"Module"})),aa=xe({prefix:"9",name:"base10",alphabet:"0123456789"}),ca=Object.freeze(Object.defineProperty({__proto__:null,base10:aa},Symbol.toStringTag,{value:"Module"})),ua=z({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),la=z({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),da=Object.freeze(Object.defineProperty({__proto__:null,base16:ua,base16upper:la},Symbol.toStringTag,{value:"Module"})),fa=z({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),pa=z({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),ha=z({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),ya=z({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),ba=z({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),ga=z({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),wa=z({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Da=z({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),va=z({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),ma=Object.freeze(Object.defineProperty({__proto__:null,base32:fa,base32hex:ba,base32hexpad:wa,base32hexpadupper:Da,base32hexupper:ga,base32pad:ha,base32padupper:ya,base32upper:pa,base32z:va},Symbol.toStringTag,{value:"Module"})),Ea=xe({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),$a=xe({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),Ca=Object.freeze(Object.defineProperty({__proto__:null,base36:Ea,base36upper:$a},Symbol.toStringTag,{value:"Module"})),Oa=xe({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Sa=xe({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),Aa=Object.freeze(Object.defineProperty({__proto__:null,base58btc:Oa,base58flickr:Sa},Symbol.toStringTag,{value:"Module"})),xa=z({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),_a=z({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Pa=z({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),ja=z({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),ka=Object.freeze(Object.defineProperty({__proto__:null,base64:xa,base64pad:_a,base64url:Pa,base64urlpad:ja},Symbol.toStringTag,{value:"Module"})),on=Array.from("ðŸš€ðŸªâ˜„ðŸ›°ðŸŒŒðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜ðŸŒðŸŒðŸŒŽðŸ‰â˜€ðŸ’»ðŸ–¥ðŸ’¾ðŸ’¿ðŸ˜‚â¤ðŸ˜ðŸ¤£ðŸ˜ŠðŸ™ðŸ’•ðŸ˜­ðŸ˜˜ðŸ‘ðŸ˜…ðŸ‘ðŸ˜ðŸ”¥ðŸ¥°ðŸ’”ðŸ’–ðŸ’™ðŸ˜¢ðŸ¤”ðŸ˜†ðŸ™„ðŸ’ªðŸ˜‰â˜ºðŸ‘ŒðŸ¤—ðŸ’œðŸ˜”ðŸ˜ŽðŸ˜‡ðŸŒ¹ðŸ¤¦ðŸŽ‰ðŸ’žâœŒâœ¨ðŸ¤·ðŸ˜±ðŸ˜ŒðŸŒ¸ðŸ™ŒðŸ˜‹ðŸ’—ðŸ’šðŸ˜ðŸ’›ðŸ™‚ðŸ’“ðŸ¤©ðŸ˜„ðŸ˜€ðŸ–¤ðŸ˜ƒðŸ’¯ðŸ™ˆðŸ‘‡ðŸŽ¶ðŸ˜’ðŸ¤­â£ðŸ˜œðŸ’‹ðŸ‘€ðŸ˜ªðŸ˜‘ðŸ’¥ðŸ™‹ðŸ˜žðŸ˜©ðŸ˜¡ðŸ¤ªðŸ‘ŠðŸ¥³ðŸ˜¥ðŸ¤¤ðŸ‘‰ðŸ’ƒðŸ˜³âœ‹ðŸ˜šðŸ˜ðŸ˜´ðŸŒŸðŸ˜¬ðŸ™ƒðŸ€ðŸŒ·ðŸ˜»ðŸ˜“â­âœ…ðŸ¥ºðŸŒˆðŸ˜ˆðŸ¤˜ðŸ’¦âœ”ðŸ˜£ðŸƒðŸ’â˜¹ðŸŽŠðŸ’˜ðŸ˜ â˜ðŸ˜•ðŸŒºðŸŽ‚ðŸŒ»ðŸ˜ðŸ–•ðŸ’ðŸ™ŠðŸ˜¹ðŸ—£ðŸ’«ðŸ’€ðŸ‘‘ðŸŽµðŸ¤žðŸ˜›ðŸ”´ðŸ˜¤ðŸŒ¼ðŸ˜«âš½ðŸ¤™â˜•ðŸ†ðŸ¤«ðŸ‘ˆðŸ˜®ðŸ™†ðŸ»ðŸƒðŸ¶ðŸ’ðŸ˜²ðŸŒ¿ðŸ§¡ðŸŽâš¡ðŸŒžðŸŽˆâŒâœŠðŸ‘‹ðŸ˜°ðŸ¤¨ðŸ˜¶ðŸ¤ðŸš¶ðŸ’°ðŸ“ðŸ’¢ðŸ¤ŸðŸ™ðŸš¨ðŸ’¨ðŸ¤¬âœˆðŸŽ€ðŸºðŸ¤“ðŸ˜™ðŸ’ŸðŸŒ±ðŸ˜–ðŸ‘¶ðŸ¥´â–¶âž¡â“ðŸ’ŽðŸ’¸â¬‡ðŸ˜¨ðŸŒšðŸ¦‹ðŸ˜·ðŸ•ºâš ðŸ™…ðŸ˜ŸðŸ˜µðŸ‘ŽðŸ¤²ðŸ¤ ðŸ¤§ðŸ“ŒðŸ”µðŸ’…ðŸ§ðŸ¾ðŸ’ðŸ˜—ðŸ¤‘ðŸŒŠðŸ¤¯ðŸ·â˜ŽðŸ’§ðŸ˜¯ðŸ’†ðŸ‘†ðŸŽ¤ðŸ™‡ðŸ‘â„ðŸŒ´ðŸ’£ðŸ¸ðŸ’ŒðŸ“ðŸ¥€ðŸ¤¢ðŸ‘…ðŸ’¡ðŸ’©ðŸ‘ðŸ“¸ðŸ‘»ðŸ¤ðŸ¤®ðŸŽ¼ðŸ¥µðŸš©ðŸŽðŸŠðŸ‘¼ðŸ’ðŸ“£ðŸ¥‚"),Ra=on.reduce((n,t,e)=>(n[e]=t,n),[]),Ta=on.reduce((n,t,e)=>(n[t.codePointAt(0)]=e,n),[]);function Ia(n){return n.reduce((t,e)=>(t+=Ra[e],t),"")}function Ma(n){const t=[];for(const e of n){const r=Ta[e.codePointAt(0)];if(r===void 0)throw new Error(`Non-base256emoji character: ${e}`);t.push(r)}return new Uint8Array(t)}const Ba=st({prefix:"ðŸš€",name:"base256emoji",encode:Ia,decode:Ma}),Na=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:Ba},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;const Hl={...ra,...oa,...ia,...ca,...da,...ma,...Ca,...Aa,...ka,...Na};var za=sn,wr=128,Ua=127,Fa=~Ua,qa=Math.pow(2,31);function sn(n,t,e){t=t||[],e=e||0;for(var r=e;n>=qa;)t[e++]=n&255|wr,n/=128;for(;n&Fa;)t[e++]=n&255|wr,n>>>=7;return t[e]=n|0,sn.bytes=e-r+1,t}var La=Tt,Ka=128,Dr=127;function Tt(n,r){var e=0,r=r||0,o=0,s=r,i,a=n.length;do{if(s>=a)throw Tt.bytes=0,new RangeError("Could not decode varint");i=n[s++],e+=o<28?(i&Dr)<<o:(i&Dr)*Math.pow(2,o),o+=7}while(i>=Ka);return Tt.bytes=s-r,e}var Va=Math.pow(2,7),Ja=Math.pow(2,14),Wa=Math.pow(2,21),Ga=Math.pow(2,28),Qa=Math.pow(2,35),Ya=Math.pow(2,42),Xa=Math.pow(2,49),Za=Math.pow(2,56),Ha=Math.pow(2,63),ec=function(n){return n<Va?1:n<Ja?2:n<Wa?3:n<Ga?4:n<Qa?5:n<Ya?6:n<Xa?7:n<Za?8:n<Ha?9:10},tc={encode:za,decode:La,encodingLength:ec},Qe=tc;const It=(n,t=0)=>[Qe.decode(n,t),Qe.decode.bytes],Ye=(n,t,e=0)=>(Qe.encode(n,t,e),t),Xe=n=>Qe.encodingLength(n),rc=(n,t)=>{if(n===t)return!0;if(n.byteLength!==t.byteLength)return!1;for(let e=0;e<n.byteLength;e++)if(n[e]!==t[e])return!1;return!0},be=n=>{if(n instanceof Uint8Array&&n.constructor.name==="Uint8Array")return n;if(n instanceof ArrayBuffer)return new Uint8Array(n);if(ArrayBuffer.isView(n))return new Uint8Array(n.buffer,n.byteOffset,n.byteLength);throw new Error("Unknown type, must be binary type")},nc=n=>new TextEncoder().encode(n),oc=n=>new TextDecoder().decode(n),Ze=(n,t)=>{const e=t.byteLength,r=Xe(n),o=r+Xe(e),s=new Uint8Array(o+e);return Ye(n,s,0),Ye(e,s,r),s.set(t,o),new Xt(n,e,t,s)},it=n=>{const t=be(n),[e,r]=It(t),[o,s]=It(t.subarray(r)),i=t.subarray(r+s);if(i.byteLength!==o)throw new Error("Incorrect length");return new Xt(e,o,i,t)},sc=(n,t)=>{if(n===t)return!0;{const e=t;return n.code===e.code&&n.size===e.size&&e.bytes instanceof Uint8Array&&rc(n.bytes,e.bytes)}};class Xt{constructor(t,e,r,o){this.code=t,this.size=e,this.digest=r,this.bytes=o}}function ic(n,t){if(n.length>=255)throw new TypeError("Alphabet too long");for(var e=new Uint8Array(256),r=0;r<e.length;r++)e[r]=255;for(var o=0;o<n.length;o++){var s=n.charAt(o),i=s.charCodeAt(0);if(e[i]!==255)throw new TypeError(s+" is ambiguous");e[i]=o}var a=n.length,c=n.charAt(0),d=Math.log(a)/Math.log(256),l=Math.log(256)/Math.log(a);function f(u){if(u instanceof Uint8Array||(ArrayBuffer.isView(u)?u=new Uint8Array(u.buffer,u.byteOffset,u.byteLength):Array.isArray(u)&&(u=Uint8Array.from(u))),!(u instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(u.length===0)return"";for(var p=0,S=0,g=0,D=u.length;g!==D&&u[g]===0;)g++,p++;for(var v=(D-g)*l+1>>>0,b=new Uint8Array(v);g!==D;){for(var m=u[g],C=0,w=v-1;(m!==0||C<S)&&w!==-1;w--,C++)m+=256*b[w]>>>0,b[w]=m%a>>>0,m=m/a>>>0;if(m!==0)throw new Error("Non-zero carry");S=C,g++}for(var $=v-S;$!==v&&b[$]===0;)$++;for(var R=c.repeat(p);$<v;++$)R+=n.charAt(b[$]);return R}function h(u){if(typeof u!="string")throw new TypeError("Expected String");if(u.length===0)return new Uint8Array;var p=0;if(u[p]!==" "){for(var S=0,g=0;u[p]===c;)S++,p++;for(var D=(u.length-p)*d+1>>>0,v=new Uint8Array(D);u[p];){var b=e[u.charCodeAt(p)];if(b===255)return;for(var m=0,C=D-1;(b!==0||m<g)&&C!==-1;C--,m++)b+=a*v[C]>>>0,v[C]=b%256>>>0,b=b/256>>>0;if(b!==0)throw new Error("Non-zero carry");g=m,p++}if(u[p]!==" "){for(var w=D-g;w!==D&&v[w]===0;)w++;for(var $=new Uint8Array(S+(D-w)),R=S;w!==D;)$[R++]=v[w++];return $}}}function y(u){var p=h(u);if(p)return p;throw new Error(`Non-${t} character`)}return{encode:f,decodeUnsafe:h,decode:y}}var ac=ic,cc=ac;class uc{constructor(t,e,r){this.name=t,this.prefix=e,this.baseEncode=r}encode(t){if(t instanceof Uint8Array)return`${this.prefix}${this.baseEncode(t)}`;throw Error("Unknown type, must be binary type")}}class lc{constructor(t,e,r){if(this.name=t,this.prefix=e,e.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=e.codePointAt(0),this.baseDecode=r}decode(t){if(typeof t=="string"){if(t.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(t.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(t){return an(this,t)}}class dc{constructor(t){this.decoders=t}or(t){return an(this,t)}decode(t){const e=t[0],r=this.decoders[e];if(r)return r.decode(t);throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const an=(n,t)=>new dc({...n.decoders||{[n.prefix]:n},...t.decoders||{[t.prefix]:t}});class fc{constructor(t,e,r,o){this.name=t,this.prefix=e,this.baseEncode=r,this.baseDecode=o,this.encoder=new uc(t,e,r),this.decoder=new lc(t,e,o)}encode(t){return this.encoder.encode(t)}decode(t){return this.decoder.decode(t)}}const at=({name:n,prefix:t,encode:e,decode:r})=>new fc(n,t,e,r),_e=({prefix:n,name:t,alphabet:e})=>{const{encode:r,decode:o}=cc(e,t);return at({prefix:n,name:t,encode:r,decode:s=>be(o(s))})},pc=(n,t,e,r)=>{const o={};for(let l=0;l<t.length;++l)o[t[l]]=l;let s=n.length;for(;n[s-1]==="=";)--s;const i=new Uint8Array(s*e/8|0);let a=0,c=0,d=0;for(let l=0;l<s;++l){const f=o[n[l]];if(f===void 0)throw new SyntaxError(`Non-${r} character`);c=c<<e|f,a+=e,a>=8&&(a-=8,i[d++]=255&c>>a)}if(a>=e||255&c<<8-a)throw new SyntaxError("Unexpected end of data");return i},hc=(n,t,e)=>{const r=t[t.length-1]==="=",o=(1<<e)-1;let s="",i=0,a=0;for(let c=0;c<n.length;++c)for(a=a<<8|n[c],i+=8;i>e;)i-=e,s+=t[o&a>>i];if(i&&(s+=t[o&a<<e-i]),r)for(;s.length*e&7;)s+="=";return s},U=({name:n,prefix:t,bitsPerChar:e,alphabet:r})=>at({prefix:t,name:n,encode(o){return hc(o,r,e)},decode(o){return pc(o,r,e,n)}}),Z=_e({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),yc=_e({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),bc=Object.freeze(Object.defineProperty({__proto__:null,base58btc:Z,base58flickr:yc},Symbol.toStringTag,{value:"Module"})),q=U({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),gc=U({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),wc=U({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Dc=U({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),vc=U({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),mc=U({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),Ec=U({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),$c=U({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Cc=U({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),Oc=Object.freeze(Object.defineProperty({__proto__:null,base32:q,base32hex:vc,base32hexpad:Ec,base32hexpadupper:$c,base32hexupper:mc,base32pad:wc,base32padupper:Dc,base32upper:gc,base32z:Cc},Symbol.toStringTag,{value:"Module"})),Sc=(n,t)=>{const{bytes:e,version:r}=n;switch(r){case 0:return xc(e,Mt(n),t||Z.encoder);default:return _c(e,Mt(n),t||q.encoder)}},vr=new WeakMap,Mt=n=>{const t=vr.get(n);if(t==null){const e=new Map;return vr.set(n,e),e}return t};class O{constructor(t,e,r,o){this.code=e,this.version=t,this.multihash=r,this.bytes=o,this["/"]=o}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:t,multihash:e}=this;if(t!==Ee)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(e.code!==Pc)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return O.createV0(e)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:t,digest:e}=this.multihash,r=Ze(t,e);return O.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(t){return O.equals(this,t)}static equals(t,e){const r=e;return r&&t.code===r.code&&t.version===r.version&&sc(t.multihash,r.multihash)}toString(t){return Sc(this,t)}toJSON(){return{code:this.code,version:this.version,hash:this.multihash.bytes}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(t){if(t==null)return null;const e=t;if(e instanceof O)return e;if(e["/"]!=null&&e["/"]===e.bytes||e.asCID===e){const{version:r,code:o,multihash:s,bytes:i}=e;return new O(r,o,s,i||mr(r,o,s.bytes))}else if(e[jc]===!0){const{version:r,multihash:o,code:s}=e,i=it(o);return O.create(r,s,i)}else return null}static create(t,e,r){if(typeof e!="number")throw new Error("String codecs are no longer supported");if(!(r.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(t){case 0:{if(e!==Ee)throw new Error(`Version 0 CID must use dag-pb (code: ${Ee}) block encoding`);return new O(t,e,r,r.bytes)}case 1:{const o=mr(t,e,r.bytes);return new O(t,e,r,o)}default:throw new Error("Invalid version")}}static createV0(t){return O.create(0,Ee,t)}static createV1(t,e){return O.create(1,t,e)}static decode(t){const[e,r]=O.decodeFirst(t);if(r.length)throw new Error("Incorrect length");return e}static decodeFirst(t){const e=O.inspectBytes(t),r=e.size-e.multihashSize,o=be(t.subarray(r,r+e.multihashSize));if(o.byteLength!==e.multihashSize)throw new Error("Incorrect length");const s=o.subarray(e.multihashSize-e.digestSize),i=new Xt(e.multihashCode,e.digestSize,s,o);return[e.version===0?O.createV0(i):O.createV1(e.codec,i),t.subarray(e.size)]}static inspectBytes(t){let e=0;const r=()=>{const[f,h]=It(t.subarray(e));return e+=h,f};let o=r(),s=Ee;if(o===18?(o=0,e=0):s=r(),o!==0&&o!==1)throw new RangeError(`Invalid CID version ${o}`);const i=e,a=r(),c=r(),d=e+c,l=d-i;return{version:o,codec:s,multihashCode:a,digestSize:c,multihashSize:l,size:d}}static parse(t,e){const[r,o]=Ac(t,e),s=O.decode(o);return Mt(s).set(r,t),s}}const Ac=(n,t)=>{switch(n[0]){case"Q":{const e=t||Z;return[Z.prefix,e.decode(`${Z.prefix}${n}`)]}case Z.prefix:{const e=t||Z;return[Z.prefix,e.decode(n)]}case q.prefix:{const e=t||q;return[q.prefix,e.decode(n)]}default:{if(t==null)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[n[0],t.decode(n)]}}},xc=(n,t,e)=>{const{prefix:r}=e;if(r!==Z.prefix)throw Error(`Cannot string encode V0 in ${e.name} encoding`);const o=t.get(r);if(o==null){const s=e.encode(n).slice(1);return t.set(r,s),s}else return o},_c=(n,t,e)=>{const{prefix:r}=e,o=t.get(r);if(o==null){const s=e.encode(n);return t.set(r,s),s}else return o},Ee=112,Pc=18,mr=(n,t,e)=>{const r=Xe(n),o=r+Xe(t),s=new Uint8Array(o+e.byteLength);return Ye(n,s,0),Ye(t,s,r),s.set(e,o),s},jc=Symbol.for("@ipld/js-cid/CID"),cn="raw",Zt=85,kc=n=>be(n),Rc=n=>be(n),Er=Object.freeze(Object.defineProperty({__proto__:null,code:Zt,decode:Rc,encode:kc,name:cn},Symbol.toStringTag,{value:"Module"})),Tc=({name:n,code:t,encode:e})=>new Ic(n,t,e);class Ic{constructor(t,e,r){this.name=t,this.code=e,this.encode=r}digest(t){if(t instanceof Uint8Array){const e=this.encode(t);return e instanceof Uint8Array?Ze(this.code,e):e.then(r=>Ze(this.code,r))}else throw Error("Unknown type, must be binary type")}}const Mc=at({prefix:"\0",name:"identity",encode:n=>oc(n),decode:n=>nc(n)}),Bc=Object.freeze(Object.defineProperty({__proto__:null,identity:Mc},Symbol.toStringTag,{value:"Module"})),Nc=U({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),zc=Object.freeze(Object.defineProperty({__proto__:null,base2:Nc},Symbol.toStringTag,{value:"Module"})),Uc=U({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),Fc=Object.freeze(Object.defineProperty({__proto__:null,base8:Uc},Symbol.toStringTag,{value:"Module"})),qc=_e({prefix:"9",name:"base10",alphabet:"0123456789"}),Lc=Object.freeze(Object.defineProperty({__proto__:null,base10:qc},Symbol.toStringTag,{value:"Module"})),Kc=U({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Vc=U({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),Jc=Object.freeze(Object.defineProperty({__proto__:null,base16:Kc,base16upper:Vc},Symbol.toStringTag,{value:"Module"})),Wc=_e({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Gc=_e({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),Qc=Object.freeze(Object.defineProperty({__proto__:null,base36:Wc,base36upper:Gc},Symbol.toStringTag,{value:"Module"})),Yc=U({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Xc=U({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Zc=U({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Hc=U({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),eu=Object.freeze(Object.defineProperty({__proto__:null,base64:Yc,base64pad:Xc,base64url:Zc,base64urlpad:Hc},Symbol.toStringTag,{value:"Module"})),un=Array.from("ðŸš€ðŸªâ˜„ðŸ›°ðŸŒŒðŸŒ‘ðŸŒ’ðŸŒ“ðŸŒ”ðŸŒ•ðŸŒ–ðŸŒ—ðŸŒ˜ðŸŒðŸŒðŸŒŽðŸ‰â˜€ðŸ’»ðŸ–¥ðŸ’¾ðŸ’¿ðŸ˜‚â¤ðŸ˜ðŸ¤£ðŸ˜ŠðŸ™ðŸ’•ðŸ˜­ðŸ˜˜ðŸ‘ðŸ˜…ðŸ‘ðŸ˜ðŸ”¥ðŸ¥°ðŸ’”ðŸ’–ðŸ’™ðŸ˜¢ðŸ¤”ðŸ˜†ðŸ™„ðŸ’ªðŸ˜‰â˜ºðŸ‘ŒðŸ¤—ðŸ’œðŸ˜”ðŸ˜ŽðŸ˜‡ðŸŒ¹ðŸ¤¦ðŸŽ‰ðŸ’žâœŒâœ¨ðŸ¤·ðŸ˜±ðŸ˜ŒðŸŒ¸ðŸ™ŒðŸ˜‹ðŸ’—ðŸ’šðŸ˜ðŸ’›ðŸ™‚ðŸ’“ðŸ¤©ðŸ˜„ðŸ˜€ðŸ–¤ðŸ˜ƒðŸ’¯ðŸ™ˆðŸ‘‡ðŸŽ¶ðŸ˜’ðŸ¤­â£ðŸ˜œðŸ’‹ðŸ‘€ðŸ˜ªðŸ˜‘ðŸ’¥ðŸ™‹ðŸ˜žðŸ˜©ðŸ˜¡ðŸ¤ªðŸ‘ŠðŸ¥³ðŸ˜¥ðŸ¤¤ðŸ‘‰ðŸ’ƒðŸ˜³âœ‹ðŸ˜šðŸ˜ðŸ˜´ðŸŒŸðŸ˜¬ðŸ™ƒðŸ€ðŸŒ·ðŸ˜»ðŸ˜“â­âœ…ðŸ¥ºðŸŒˆðŸ˜ˆðŸ¤˜ðŸ’¦âœ”ðŸ˜£ðŸƒðŸ’â˜¹ðŸŽŠðŸ’˜ðŸ˜ â˜ðŸ˜•ðŸŒºðŸŽ‚ðŸŒ»ðŸ˜ðŸ–•ðŸ’ðŸ™ŠðŸ˜¹ðŸ—£ðŸ’«ðŸ’€ðŸ‘‘ðŸŽµðŸ¤žðŸ˜›ðŸ”´ðŸ˜¤ðŸŒ¼ðŸ˜«âš½ðŸ¤™â˜•ðŸ†ðŸ¤«ðŸ‘ˆðŸ˜®ðŸ™†ðŸ»ðŸƒðŸ¶ðŸ’ðŸ˜²ðŸŒ¿ðŸ§¡ðŸŽâš¡ðŸŒžðŸŽˆâŒâœŠðŸ‘‹ðŸ˜°ðŸ¤¨ðŸ˜¶ðŸ¤ðŸš¶ðŸ’°ðŸ“ðŸ’¢ðŸ¤ŸðŸ™ðŸš¨ðŸ’¨ðŸ¤¬âœˆðŸŽ€ðŸºðŸ¤“ðŸ˜™ðŸ’ŸðŸŒ±ðŸ˜–ðŸ‘¶ðŸ¥´â–¶âž¡â“ðŸ’ŽðŸ’¸â¬‡ðŸ˜¨ðŸŒšðŸ¦‹ðŸ˜·ðŸ•ºâš ðŸ™…ðŸ˜ŸðŸ˜µðŸ‘ŽðŸ¤²ðŸ¤ ðŸ¤§ðŸ“ŒðŸ”µðŸ’…ðŸ§ðŸ¾ðŸ’ðŸ˜—ðŸ¤‘ðŸŒŠðŸ¤¯ðŸ·â˜ŽðŸ’§ðŸ˜¯ðŸ’†ðŸ‘†ðŸŽ¤ðŸ™‡ðŸ‘â„ðŸŒ´ðŸ’£ðŸ¸ðŸ’ŒðŸ“ðŸ¥€ðŸ¤¢ðŸ‘…ðŸ’¡ðŸ’©ðŸ‘ðŸ“¸ðŸ‘»ðŸ¤ðŸ¤®ðŸŽ¼ðŸ¥µðŸš©ðŸŽðŸŠðŸ‘¼ðŸ’ðŸ“£ðŸ¥‚"),tu=un.reduce((n,t,e)=>(n[e]=t,n),[]),ru=un.reduce((n,t,e)=>(n[t.codePointAt(0)]=e,n),[]);function nu(n){return n.reduce((t,e)=>(t+=tu[e],t),"")}function ou(n){const t=[];for(const e of n){const r=ru[e.codePointAt(0)];if(r===void 0)throw new Error(`Non-base256emoji character: ${e}`);t.push(r)}return new Uint8Array(t)}const su=at({prefix:"ðŸš€",name:"base256emoji",encode:nu,decode:ou}),iu=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:su},Symbol.toStringTag,{value:"Module"})),au=n=>async t=>new Uint8Array(await crypto.subtle.digest(n,t)),ct=Tc({name:"sha2-256",code:18,encode:au("SHA-256")}),ln=0,cu="identity",dn=be,uu=n=>Ze(ln,dn(n)),lu={code:ln,name:cu,encode:dn,digest:uu};new TextEncoder;new TextDecoder;const ed={...Bc,...zc,...Fc,...Lc,...Jc,...Oc,...Qc,...bc,...eu,...iu},du=H("ipfs:repo:migrator:migration-8");function fn(n){return n.child?fn(n.child):n}function fu(n){try{const t=q.decode(`b${n.toString().toLowerCase().slice(1)}`),e=O.decode(t).multihash.bytes,r=q.encode(e).slice(1).toUpperCase();return new M(`/${r}`,!1)}catch{return n}}function pu(n){try{const t=q.decode(`b${n.toString().toLowerCase().slice(1)}`),e=it(t),r=q.encode(O.createV1(Zt,e).bytes).slice(1);return new M(`/${r.toUpperCase()}`,!1)}catch{return n}}async function $r(n,t,e){const r=n.blocks;await r.open();const o=fn(r),s=await qe(o.queryKeys({filters:[i=>e(i).toString()!==i.toString()]}));try{let i=0;for await(const a of o.query({})){const c=e(a.key);c.toString()!==a.key.toString()&&(i+=1,du(`Migrating Block from ${a.key} to ${c}`,await o.has(a.key)),await o.delete(a.key),await o.put(c,a.value),t(i/s*100,`Migrated Block from ${a.key} to ${c}`))}}finally{await r.close()}}const hu={version:8,description:"Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32",migrate:(n,t=()=>{})=>$r(n,t,fu),revert:(n,t=()=>{})=>$r(n,t,pu)},Cr=E.Reader,yu=E.Writer;E.util;const ke=E.roots.default||(E.roots.default={}),bu=ke.ipfs=(()=>{const n={};return n.pin=function(){const t={};return t.Set=function(){function e(r){if(r)for(var o=Object.keys(r),s=0;s<o.length;++s)r[o[s]]!=null&&(this[o[s]]=r[o[s]])}return e.prototype.version=0,e.prototype.fanout=0,e.prototype.seed=0,e.encode=function(o,s){return s||(s=yu.create()),o.version!=null&&Object.hasOwnProperty.call(o,"version")&&s.uint32(8).uint32(o.version),o.fanout!=null&&Object.hasOwnProperty.call(o,"fanout")&&s.uint32(16).uint32(o.fanout),o.seed!=null&&Object.hasOwnProperty.call(o,"seed")&&s.uint32(29).fixed32(o.seed),s},e.decode=function(o,s){o instanceof Cr||(o=Cr.create(o));for(var i=s===void 0?o.len:o.pos+s,a=new ke.ipfs.pin.Set;o.pos<i;){var c=o.uint32();switch(c>>>3){case 1:a.version=o.uint32();break;case 2:a.fanout=o.uint32();break;case 3:a.seed=o.fixed32();break;default:o.skipType(c&7);break}}return a},e.fromObject=function(o){if(o instanceof ke.ipfs.pin.Set)return o;var s=new ke.ipfs.pin.Set;return o.version!=null&&(s.version=o.version>>>0),o.fanout!=null&&(s.fanout=o.fanout>>>0),o.seed!=null&&(s.seed=o.seed>>>0),s},e.toObject=function(o,s){s||(s={});var i={};return s.defaults&&(i.version=0,i.fanout=0,i.seed=0),o.version!=null&&o.hasOwnProperty("version")&&(i.version=o.version),o.fanout!=null&&o.hasOwnProperty("fanout")&&(i.fanout=o.fanout),o.seed!=null&&o.hasOwnProperty("seed")&&(i.seed=o.seed),i},e.prototype.toJSON=function(){return this.constructor.toObject(this,E.util.toJSONOptions)},e}(),t}(),n})(),Fe=new M("/local/pins"),wt=256,gu=8192,pn=O.parse("QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n"),pe={direct:"direct",recursive:"recursive"};function Or(n){return new M(`/${q.encode(n.multihash.bytes).toUpperCase().substring(1)}`)}const Bt=bu.pin.Set;function wu(n){const t=n.Data;if(!t)throw new Error("No data present");const e=T.decode(t),r=T.decode.bytes;if(r<=0)throw new Error("Invalid Set header length");if(r+e>t.length)throw new Error("Impossibly large set header length");const o=t.slice(r,e+r),s=Bt.toObject(Bt.decode(o),{defaults:!1,arrays:!0,longs:Number,objects:!1});if(s.version!==1)throw new Error(`Unsupported Set version: ${s.version}`);if(s.fanout>n.Links.length)throw new Error("Impossibly large fanout");return{header:s,data:t.slice(e+r)}}function Du(n,t){const e=new Uint8Array(4);new DataView(e.buffer).setUint32(0,n,!0);const o=ue(t.toString()),s=St([e,o],e.byteLength+o.byteLength);return Mn(ye(s))}async function*hn(n,t){const e=wu(t);let r=0;for(const o of t.Links){if(r<e.header.fanout){const s=o.Hash;if(!pn.equals(s)){const i=await n.get(s),a=Lt(i);yield*hn(n,a)}}else yield o.Hash;r++}}async function*Re(n,t,e){const r=t.Links.find(i=>i.Name===e);if(!r)throw new Error("No link found with name "+e);const o=await n.get(r.Hash),s=Lt(o);yield*hn(n,s)}function vu(n,t){return e(t,0);async function e(r,o){const s=Bt.encode({version:1,fanout:wt,seed:o}).finish(),i=T.encode(s.length),a=St([i,s]),c=[];for(let l=0;l<wt;l++)c.push({Name:"",Tsize:1,Hash:pn});if(r.length<=gu){const l=r.map(y=>({link:{Name:"",Tsize:1,Hash:y.key},data:y.data||new Uint8Array})).sort((y,u)=>In(y.link.Hash.bytes,u.link.Hash.bytes)),f=c.concat(l.map(y=>y.link));return{Data:St([a,...l.map(y=>y.data)]),Links:f}}else{const l=r.reduce((h,y)=>{const u=Du(o,y.key)%wt;return h[u]=u in h?h[u].concat([y]):[y],h},[]);let f=0;for(const h of l){const y=await e(h,o+1);await d(y,f),f++}return{Data:a,Links:c}}async function d(l,f){const h=Kt(l),y=await ct.digest(h),u=O.createV0(y);await n.put(u,h);const p=l.Links.reduce((S,g)=>S+(g.Tsize||0),0)+h.length;c[f]={Name:"",Tsize:p,Hash:u}}}}async function Sr(n,t,e){const r=await vu(n,e.map(c=>({key:c}))),o=Kt(r),s=await ct.digest(o),i=O.createV0(s);await n.put(i,o);const a=r.Links.reduce((c,d)=>c+d.Tsize,0)+o.length;return{Name:t,Tsize:a,Hash:i}}async function mu(n,t,e,r){if(!await t.has(Fe))return;const o=await t.get(Fe),s=O.decode(o),i=await n.get(s),a=Lt(i);let c=0;const d=await qe(Re(n,a,pe.recursive))+await qe(Re(n,a,pe.direct));for await(const l of Re(n,a,pe.recursive)){c++;const f={depth:1/0};l.version!==0&&(f.version=l.version),l.code!==te&&(f.codec=l.code),await e.put(Or(l),Le(f)),r(c/d*100,`Migrated recursive pin ${l}`)}for await(const l of Re(n,a,pe.direct)){c++;const f={depth:0};l.version!==0&&(f.version=l.version),l.code!==te&&(f.codec=l.code),await e.put(Or(l),Le(f)),r(c/d*100,`Migrated direct pin ${l}`)}await n.delete(s),await t.delete(Fe)}async function Eu(n,t,e,r){const o=[],s=[];let i=0;const a=await qe(e.queryKeys({}));for await(const{key:h,value:y}of e.query({})){i++;const u=se(y),p=O.create(u.version||0,u.codec||te,it(q.decode("b"+h.toString().toLowerCase().split("/").pop())));u.depth===0?(r(i/a*100,`Reverted direct pin ${p}`),s.push(p)):(r(i/a*100,`Reverted recursive pin ${p}`),o.push(p))}r(100,"Updating pin root");const c={Links:[await Sr(n,pe.direct,s),await Sr(n,pe.recursive,o)]},d=Kt(c),l=await ct.digest(d),f=O.createV0(l);await n.put(f,d),await t.put(Fe,f.bytes)}async function Ar(n,t,e){const r=n.blocks,o=n.datastore,s=n.pins;await r.open(),await o.open(),await s.open();try{await e(r,o,s,t)}finally{await s.close(),await o.close(),await r.close()}}const $u={version:9,description:"Migrates pins to datastore",migrate:(n,t=()=>{})=>Ar(n,t,mu),revert:(n,t=()=>{})=>Ar(n,t,Eu)},Cu=new M("/config"),Ht=new M("/version");function ut(n){let t=n;for(;t.db||t.child;)if(t=t.db||t.child,t.type==="level-js"||t.constructor.name==="Level")return t}async function Ou(n,t,e){const r=await t(n);if(r)return r;const o=ut(e);return o?new Promise((s,i)=>{const a=o.store("readonly").get(n.toString());a.transaction.onabort=()=>{i(a.transaction.error)},a.transaction.oncomplete=()=>{s(!!a.result)}}):!1}async function Su(n,t,e,r){if(await e(n))return t(n);const o=ut(r);if(!o)throw At();return new Promise((s,i)=>{const a=o.store("readonly").get(n.toString());a.transaction.onabort=()=>{i(a.transaction.error)},a.transaction.oncomplete=()=>{if(a.result)return s(a.result);i(At())}})}function Te(n){const t=n.get.bind(n),e=n.has.bind(n);return n.get=r=>Su(r,t,e,n),n.has=r=>Ou(r,e,n),n}function yn(n){return{...n,root:Te(n.root),datastore:Te(n.datastore),pins:Te(n.pins),keys:Te(n.keys)}}async function Au(n,t,e=()=>{}){const r=ut(t);if(!r){e(`${n} did not need an upgrade`);return}e(`Upgrading ${n}`),await gn(r,(s,i)=>[{type:"del",key:s},{type:"put",key:ue(s),value:i}])}async function xu(n,t,e=()=>{}){const r=ut(t);if(!r){e(`${n} did not need a downgrade`);return}e(`Downgrading ${n}`),await gn(r,(s,i)=>[{type:"del",key:s},{type:"put",key:ye(s),value:i}])}function bn(n){return n.child?bn(n.child):n}async function xr(n,t,e){const r=Object.entries(n).map(([i,a])=>({key:i,backend:bn(a)})).filter(({key:i,backend:a})=>a.constructor.name==="LevelDatastore").map(({key:i,backend:a})=>({name:i,store:a}));t(0,`Migrating ${r.length} dbs`);let o=0;const s=i=>{t(Math.round(o/r.length*100),i)};for(const{name:i,store:a}of r){await a.open();try{await e(i,a,s)}finally{o++,await a.close()}}t(100,`Migrated ${r.length} dbs`)}const _u={version:10,description:"Migrates datastore-level keys to binary",migrate:(n,t=()=>{})=>xr(n,t,Au),revert:(n,t=()=>{})=>xr(n,t,xu)};function gn(n,t){function e(r,o){const s=n.store("readwrite"),i=s.transaction;let a=0,c;i.onabort=()=>o(c||i.error||new Error("aborted by user")),i.oncomplete=()=>o();function d(){const l=r[a++],f=l.key;let h;try{h=l.type==="del"?s.delete(f):s.put(l.value,f)}catch(y){c=y,i.abort();return}a<r.length&&(h.onsuccess=d)}d()}return new Promise((r,o)=>{const s=n.iterator(),i=c=>c;s._deserializeKey=s._deserializeValue=i,a();function a(){const c=(d,l,f)=>{if(d||l===void 0){const h=y=>{if(y){o(y);return}r()};s.end(h);return}e(t(l,f),a)};s.next(c)}})}const re=new M("/local/filesroot");async function Pu(n,t=()=>{}){if(t(100,"Migrating MFS root to repo datastore"),await n.root.open(),await n.datastore.open(),await n.root.has(re)){const e=await n.root.get(re);await n.datastore.put(re,e),await n.root.delete(re)}await n.datastore.close(),await n.root.close(),t(100,"Stored MFS root in repo datastore")}async function ju(n,t=()=>{}){if(t(100,"Migrating MFS root to repo root datastore"),await n.root.open(),await n.datastore.open(),await n.datastore.has(re)){const e=await n.datastore.get(re);await n.root.put(re,e),await n.datastore.delete(re)}await n.datastore.close(),await n.root.close(),t(100,"Stored MFS root in repo root datastore")}const ku={version:11,description:"Store mfs root in the datastore",migrate:Pu,revert:ju},_r=E.Reader,Ru=E.Writer,Tu=E.util,Ie=E.roots.default||(E.roots.default={}),wn=Ie.Protocols=(()=>{function n(t){if(this.protocols=[],t)for(var e=Object.keys(t),r=0;r<e.length;++r)t[e[r]]!=null&&(this[e[r]]=t[e[r]])}return n.prototype.protocols=Tu.emptyArray,n.encode=function(e,r){if(r||(r=Ru.create()),e.protocols!=null&&e.protocols.length)for(var o=0;o<e.protocols.length;++o)r.uint32(10).string(e.protocols[o]);return r},n.decode=function(e,r){e instanceof _r||(e=_r.create(e));for(var o=r===void 0?e.len:e.pos+r,s=new Ie.Protocols;e.pos<o;){var i=e.uint32();switch(i>>>3){case 1:s.protocols&&s.protocols.length||(s.protocols=[]),s.protocols.push(e.string());break;default:e.skipType(i&7);break}}return s},n.fromObject=function(e){if(e instanceof Ie.Protocols)return e;var r=new Ie.Protocols;if(e.protocols){if(!Array.isArray(e.protocols))throw TypeError(".Protocols.protocols: array expected");r.protocols=[];for(var o=0;o<e.protocols.length;++o)r.protocols[o]=String(e.protocols[o])}return r},n.toObject=function(e,r){r||(r={});var o={};if((r.arrays||r.defaults)&&(o.protocols=[]),e.protocols&&e.protocols.length){o.protocols=[];for(var s=0;s<e.protocols.length;++s)o.protocols[s]=e.protocols[s]}return o},n.prototype.toJSON=function(){return this.constructor.toObject(this,E.util.toJSONOptions)},n})(),de=E.Reader,Dt=E.Writer,x=E.util,I=E.roots.default||(E.roots.default={}),Dn=I.Addresses=(()=>{function n(t){if(this.addrs=[],t)for(var e=Object.keys(t),r=0;r<e.length;++r)t[e[r]]!=null&&(this[e[r]]=t[e[r]])}return n.prototype.addrs=x.emptyArray,n.prototype.certifiedRecord=null,n.encode=function(e,r){if(r||(r=Dt.create()),e.addrs!=null&&e.addrs.length)for(var o=0;o<e.addrs.length;++o)I.Addresses.Address.encode(e.addrs[o],r.uint32(10).fork()).ldelim();return e.certifiedRecord!=null&&Object.hasOwnProperty.call(e,"certifiedRecord")&&I.Addresses.CertifiedRecord.encode(e.certifiedRecord,r.uint32(18).fork()).ldelim(),r},n.decode=function(e,r){e instanceof de||(e=de.create(e));for(var o=r===void 0?e.len:e.pos+r,s=new I.Addresses;e.pos<o;){var i=e.uint32();switch(i>>>3){case 1:s.addrs&&s.addrs.length||(s.addrs=[]),s.addrs.push(I.Addresses.Address.decode(e,e.uint32()));break;case 2:s.certifiedRecord=I.Addresses.CertifiedRecord.decode(e,e.uint32());break;default:e.skipType(i&7);break}}return s},n.fromObject=function(e){if(e instanceof I.Addresses)return e;var r=new I.Addresses;if(e.addrs){if(!Array.isArray(e.addrs))throw TypeError(".Addresses.addrs: array expected");r.addrs=[];for(var o=0;o<e.addrs.length;++o){if(typeof e.addrs[o]!="object")throw TypeError(".Addresses.addrs: object expected");r.addrs[o]=I.Addresses.Address.fromObject(e.addrs[o])}}if(e.certifiedRecord!=null){if(typeof e.certifiedRecord!="object")throw TypeError(".Addresses.certifiedRecord: object expected");r.certifiedRecord=I.Addresses.CertifiedRecord.fromObject(e.certifiedRecord)}return r},n.toObject=function(e,r){r||(r={});var o={};if((r.arrays||r.defaults)&&(o.addrs=[]),r.defaults&&(o.certifiedRecord=null),e.addrs&&e.addrs.length){o.addrs=[];for(var s=0;s<e.addrs.length;++s)o.addrs[s]=I.Addresses.Address.toObject(e.addrs[s],r)}return e.certifiedRecord!=null&&e.hasOwnProperty("certifiedRecord")&&(o.certifiedRecord=I.Addresses.CertifiedRecord.toObject(e.certifiedRecord,r)),o},n.prototype.toJSON=function(){return this.constructor.toObject(this,E.util.toJSONOptions)},n.Address=function(){function t(r){if(r)for(var o=Object.keys(r),s=0;s<o.length;++s)r[o[s]]!=null&&(this[o[s]]=r[o[s]])}t.prototype.multiaddr=x.newBuffer([]),t.prototype.isCertified=null;let e;return Object.defineProperty(t.prototype,"_isCertified",{get:x.oneOfGetter(e=["isCertified"]),set:x.oneOfSetter(e)}),t.encode=function(o,s){return s||(s=Dt.create()),o.multiaddr!=null&&Object.hasOwnProperty.call(o,"multiaddr")&&s.uint32(10).bytes(o.multiaddr),o.isCertified!=null&&Object.hasOwnProperty.call(o,"isCertified")&&s.uint32(16).bool(o.isCertified),s},t.decode=function(o,s){o instanceof de||(o=de.create(o));for(var i=s===void 0?o.len:o.pos+s,a=new I.Addresses.Address;o.pos<i;){var c=o.uint32();switch(c>>>3){case 1:a.multiaddr=o.bytes();break;case 2:a.isCertified=o.bool();break;default:o.skipType(c&7);break}}return a},t.fromObject=function(o){if(o instanceof I.Addresses.Address)return o;var s=new I.Addresses.Address;return o.multiaddr!=null&&(typeof o.multiaddr=="string"?x.base64.decode(o.multiaddr,s.multiaddr=x.newBuffer(x.base64.length(o.multiaddr)),0):o.multiaddr.length&&(s.multiaddr=o.multiaddr)),o.isCertified!=null&&(s.isCertified=!!o.isCertified),s},t.toObject=function(o,s){s||(s={});var i={};return s.defaults&&(s.bytes===String?i.multiaddr="":(i.multiaddr=[],s.bytes!==Array&&(i.multiaddr=x.newBuffer(i.multiaddr)))),o.multiaddr!=null&&o.hasOwnProperty("multiaddr")&&(i.multiaddr=s.bytes===String?x.base64.encode(o.multiaddr,0,o.multiaddr.length):s.bytes===Array?Array.prototype.slice.call(o.multiaddr):o.multiaddr),o.isCertified!=null&&o.hasOwnProperty("isCertified")&&(i.isCertified=o.isCertified,s.oneofs&&(i._isCertified="isCertified")),i},t.prototype.toJSON=function(){return this.constructor.toObject(this,E.util.toJSONOptions)},t}(),n.CertifiedRecord=function(){function t(e){if(e)for(var r=Object.keys(e),o=0;o<r.length;++o)e[r[o]]!=null&&(this[r[o]]=e[r[o]])}return t.prototype.seq=x.Long?x.Long.fromBits(0,0,!0):0,t.prototype.raw=x.newBuffer([]),t.encode=function(r,o){return o||(o=Dt.create()),r.seq!=null&&Object.hasOwnProperty.call(r,"seq")&&o.uint32(8).uint64(r.seq),r.raw!=null&&Object.hasOwnProperty.call(r,"raw")&&o.uint32(18).bytes(r.raw),o},t.decode=function(r,o){r instanceof de||(r=de.create(r));for(var s=o===void 0?r.len:r.pos+o,i=new I.Addresses.CertifiedRecord;r.pos<s;){var a=r.uint32();switch(a>>>3){case 1:i.seq=r.uint64();break;case 2:i.raw=r.bytes();break;default:r.skipType(a&7);break}}return i},t.fromObject=function(r){if(r instanceof I.Addresses.CertifiedRecord)return r;var o=new I.Addresses.CertifiedRecord;return r.seq!=null&&(x.Long?(o.seq=x.Long.fromValue(r.seq)).unsigned=!0:typeof r.seq=="string"?o.seq=parseInt(r.seq,10):typeof r.seq=="number"?o.seq=r.seq:typeof r.seq=="object"&&(o.seq=new x.LongBits(r.seq.low>>>0,r.seq.high>>>0).toNumber(!0))),r.raw!=null&&(typeof r.raw=="string"?x.base64.decode(r.raw,o.raw=x.newBuffer(x.base64.length(r.raw)),0):r.raw.length&&(o.raw=r.raw)),o},t.toObject=function(r,o){o||(o={});var s={};if(o.defaults){if(x.Long){var i=new x.Long(0,0,!0);s.seq=o.longs===String?i.toString():o.longs===Number?i.toNumber():i}else s.seq=o.longs===String?"0":0;o.bytes===String?s.raw="":(s.raw=[],o.bytes!==Array&&(s.raw=x.newBuffer(s.raw)))}return r.seq!=null&&r.hasOwnProperty("seq")&&(typeof r.seq=="number"?s.seq=o.longs===String?String(r.seq):r.seq:s.seq=o.longs===String?x.Long.prototype.toString.call(r.seq):o.longs===Number?new x.LongBits(r.seq.low>>>0,r.seq.high>>>0).toNumber(!0):r.seq),r.raw!=null&&r.hasOwnProperty("raw")&&(s.raw=o.bytes===String?x.base64.encode(r.raw,0,r.raw.length):o.bytes===Array?Array.prototype.slice.call(r.raw):r.raw),s},t.prototype.toJSON=function(){return this.constructor.toObject(this,E.util.toJSONOptions)},t}(),n})(),he=E.Reader,er=E.Writer,A=E.util,j=E.roots.default||(E.roots.default={}),vn=j.Peer=(()=>{function n(e){if(this.addresses=[],this.protocols=[],this.metadata=[],e)for(var r=Object.keys(e),o=0;o<r.length;++o)e[r[o]]!=null&&(this[r[o]]=e[r[o]])}n.prototype.addresses=A.emptyArray,n.prototype.protocols=A.emptyArray,n.prototype.metadata=A.emptyArray,n.prototype.pubKey=null,n.prototype.peerRecordEnvelope=null;let t;return Object.defineProperty(n.prototype,"_pubKey",{get:A.oneOfGetter(t=["pubKey"]),set:A.oneOfSetter(t)}),Object.defineProperty(n.prototype,"_peerRecordEnvelope",{get:A.oneOfGetter(t=["peerRecordEnvelope"]),set:A.oneOfSetter(t)}),n.encode=function(r,o){if(o||(o=er.create()),r.addresses!=null&&r.addresses.length)for(var s=0;s<r.addresses.length;++s)j.Address.encode(r.addresses[s],o.uint32(10).fork()).ldelim();if(r.protocols!=null&&r.protocols.length)for(var s=0;s<r.protocols.length;++s)o.uint32(18).string(r.protocols[s]);if(r.metadata!=null&&r.metadata.length)for(var s=0;s<r.metadata.length;++s)j.Metadata.encode(r.metadata[s],o.uint32(26).fork()).ldelim();return r.pubKey!=null&&Object.hasOwnProperty.call(r,"pubKey")&&o.uint32(34).bytes(r.pubKey),r.peerRecordEnvelope!=null&&Object.hasOwnProperty.call(r,"peerRecordEnvelope")&&o.uint32(42).bytes(r.peerRecordEnvelope),o},n.decode=function(r,o){r instanceof he||(r=he.create(r));for(var s=o===void 0?r.len:r.pos+o,i=new j.Peer;r.pos<s;){var a=r.uint32();switch(a>>>3){case 1:i.addresses&&i.addresses.length||(i.addresses=[]),i.addresses.push(j.Address.decode(r,r.uint32()));break;case 2:i.protocols&&i.protocols.length||(i.protocols=[]),i.protocols.push(r.string());break;case 3:i.metadata&&i.metadata.length||(i.metadata=[]),i.metadata.push(j.Metadata.decode(r,r.uint32()));break;case 4:i.pubKey=r.bytes();break;case 5:i.peerRecordEnvelope=r.bytes();break;default:r.skipType(a&7);break}}return i},n.fromObject=function(r){if(r instanceof j.Peer)return r;var o=new j.Peer;if(r.addresses){if(!Array.isArray(r.addresses))throw TypeError(".Peer.addresses: array expected");o.addresses=[];for(var s=0;s<r.addresses.length;++s){if(typeof r.addresses[s]!="object")throw TypeError(".Peer.addresses: object expected");o.addresses[s]=j.Address.fromObject(r.addresses[s])}}if(r.protocols){if(!Array.isArray(r.protocols))throw TypeError(".Peer.protocols: array expected");o.protocols=[];for(var s=0;s<r.protocols.length;++s)o.protocols[s]=String(r.protocols[s])}if(r.metadata){if(!Array.isArray(r.metadata))throw TypeError(".Peer.metadata: array expected");o.metadata=[];for(var s=0;s<r.metadata.length;++s){if(typeof r.metadata[s]!="object")throw TypeError(".Peer.metadata: object expected");o.metadata[s]=j.Metadata.fromObject(r.metadata[s])}}return r.pubKey!=null&&(typeof r.pubKey=="string"?A.base64.decode(r.pubKey,o.pubKey=A.newBuffer(A.base64.length(r.pubKey)),0):r.pubKey.length&&(o.pubKey=r.pubKey)),r.peerRecordEnvelope!=null&&(typeof r.peerRecordEnvelope=="string"?A.base64.decode(r.peerRecordEnvelope,o.peerRecordEnvelope=A.newBuffer(A.base64.length(r.peerRecordEnvelope)),0):r.peerRecordEnvelope.length&&(o.peerRecordEnvelope=r.peerRecordEnvelope)),o},n.toObject=function(r,o){o||(o={});var s={};if((o.arrays||o.defaults)&&(s.addresses=[],s.protocols=[],s.metadata=[]),r.addresses&&r.addresses.length){s.addresses=[];for(var i=0;i<r.addresses.length;++i)s.addresses[i]=j.Address.toObject(r.addresses[i],o)}if(r.protocols&&r.protocols.length){s.protocols=[];for(var i=0;i<r.protocols.length;++i)s.protocols[i]=r.protocols[i]}if(r.metadata&&r.metadata.length){s.metadata=[];for(var i=0;i<r.metadata.length;++i)s.metadata[i]=j.Metadata.toObject(r.metadata[i],o)}return r.pubKey!=null&&r.hasOwnProperty("pubKey")&&(s.pubKey=o.bytes===String?A.base64.encode(r.pubKey,0,r.pubKey.length):o.bytes===Array?Array.prototype.slice.call(r.pubKey):r.pubKey,o.oneofs&&(s._pubKey="pubKey")),r.peerRecordEnvelope!=null&&r.hasOwnProperty("peerRecordEnvelope")&&(s.peerRecordEnvelope=o.bytes===String?A.base64.encode(r.peerRecordEnvelope,0,r.peerRecordEnvelope.length):o.bytes===Array?Array.prototype.slice.call(r.peerRecordEnvelope):r.peerRecordEnvelope,o.oneofs&&(s._peerRecordEnvelope="peerRecordEnvelope")),s},n.prototype.toJSON=function(){return this.constructor.toObject(this,E.util.toJSONOptions)},n})();j.Address=(()=>{function n(e){if(e)for(var r=Object.keys(e),o=0;o<r.length;++o)e[r[o]]!=null&&(this[r[o]]=e[r[o]])}n.prototype.multiaddr=A.newBuffer([]),n.prototype.isCertified=null;let t;return Object.defineProperty(n.prototype,"_isCertified",{get:A.oneOfGetter(t=["isCertified"]),set:A.oneOfSetter(t)}),n.encode=function(r,o){return o||(o=er.create()),r.multiaddr!=null&&Object.hasOwnProperty.call(r,"multiaddr")&&o.uint32(10).bytes(r.multiaddr),r.isCertified!=null&&Object.hasOwnProperty.call(r,"isCertified")&&o.uint32(16).bool(r.isCertified),o},n.decode=function(r,o){r instanceof he||(r=he.create(r));for(var s=o===void 0?r.len:r.pos+o,i=new j.Address;r.pos<s;){var a=r.uint32();switch(a>>>3){case 1:i.multiaddr=r.bytes();break;case 2:i.isCertified=r.bool();break;default:r.skipType(a&7);break}}return i},n.fromObject=function(r){if(r instanceof j.Address)return r;var o=new j.Address;return r.multiaddr!=null&&(typeof r.multiaddr=="string"?A.base64.decode(r.multiaddr,o.multiaddr=A.newBuffer(A.base64.length(r.multiaddr)),0):r.multiaddr.length&&(o.multiaddr=r.multiaddr)),r.isCertified!=null&&(o.isCertified=!!r.isCertified),o},n.toObject=function(r,o){o||(o={});var s={};return o.defaults&&(o.bytes===String?s.multiaddr="":(s.multiaddr=[],o.bytes!==Array&&(s.multiaddr=A.newBuffer(s.multiaddr)))),r.multiaddr!=null&&r.hasOwnProperty("multiaddr")&&(s.multiaddr=o.bytes===String?A.base64.encode(r.multiaddr,0,r.multiaddr.length):o.bytes===Array?Array.prototype.slice.call(r.multiaddr):r.multiaddr),r.isCertified!=null&&r.hasOwnProperty("isCertified")&&(s.isCertified=r.isCertified,o.oneofs&&(s._isCertified="isCertified")),s},n.prototype.toJSON=function(){return this.constructor.toObject(this,E.util.toJSONOptions)},n})();j.Metadata=(()=>{function n(t){if(t)for(var e=Object.keys(t),r=0;r<e.length;++r)t[e[r]]!=null&&(this[e[r]]=t[e[r]])}return n.prototype.key="",n.prototype.value=A.newBuffer([]),n.encode=function(e,r){return r||(r=er.create()),e.key!=null&&Object.hasOwnProperty.call(e,"key")&&r.uint32(10).string(e.key),e.value!=null&&Object.hasOwnProperty.call(e,"value")&&r.uint32(18).bytes(e.value),r},n.decode=function(e,r){e instanceof he||(e=he.create(e));for(var o=r===void 0?e.len:e.pos+r,s=new j.Metadata;e.pos<o;){var i=e.uint32();switch(i>>>3){case 1:s.key=e.string();break;case 2:s.value=e.bytes();break;default:e.skipType(i&7);break}}return s},n.fromObject=function(e){if(e instanceof j.Metadata)return e;var r=new j.Metadata;return e.key!=null&&(r.key=String(e.key)),e.value!=null&&(typeof e.value=="string"?A.base64.decode(e.value,r.value=A.newBuffer(A.base64.length(e.value)),0):e.value.length&&(r.value=e.value)),r},n.toObject=function(e,r){r||(r={});var o={};return r.defaults&&(o.key="",r.bytes===String?o.value="":(o.value=[],r.bytes!==Array&&(o.value=A.newBuffer(o.value)))),e.key!=null&&e.hasOwnProperty("key")&&(o.key=e.key),e.value!=null&&e.hasOwnProperty("value")&&(o.value=r.bytes===String?A.base64.encode(e.value,0,e.value.length):r.bytes===Array?Array.prototype.slice.call(e.value):e.value),o},n.prototype.toJSON=function(){return this.constructor.toObject(this,E.util.toJSONOptions)},n})();const Pr=E.Reader,Iu=E.Writer,_=E.util,Me=E.roots.default||(E.roots.default={}),Mu=Me.Envelope=(()=>{function n(t){if(t)for(var e=Object.keys(t),r=0;r<e.length;++r)t[e[r]]!=null&&(this[e[r]]=t[e[r]])}return n.prototype.publicKey=_.newBuffer([]),n.prototype.payloadType=_.newBuffer([]),n.prototype.payload=_.newBuffer([]),n.prototype.signature=_.newBuffer([]),n.encode=function(e,r){return r||(r=Iu.create()),e.publicKey!=null&&Object.hasOwnProperty.call(e,"publicKey")&&r.uint32(10).bytes(e.publicKey),e.payloadType!=null&&Object.hasOwnProperty.call(e,"payloadType")&&r.uint32(18).bytes(e.payloadType),e.payload!=null&&Object.hasOwnProperty.call(e,"payload")&&r.uint32(26).bytes(e.payload),e.signature!=null&&Object.hasOwnProperty.call(e,"signature")&&r.uint32(42).bytes(e.signature),r},n.decode=function(e,r){e instanceof Pr||(e=Pr.create(e));for(var o=r===void 0?e.len:e.pos+r,s=new Me.Envelope;e.pos<o;){var i=e.uint32();switch(i>>>3){case 1:s.publicKey=e.bytes();break;case 2:s.payloadType=e.bytes();break;case 3:s.payload=e.bytes();break;case 5:s.signature=e.bytes();break;default:e.skipType(i&7);break}}return s},n.fromObject=function(e){if(e instanceof Me.Envelope)return e;var r=new Me.Envelope;return e.publicKey!=null&&(typeof e.publicKey=="string"?_.base64.decode(e.publicKey,r.publicKey=_.newBuffer(_.base64.length(e.publicKey)),0):e.publicKey.length&&(r.publicKey=e.publicKey)),e.payloadType!=null&&(typeof e.payloadType=="string"?_.base64.decode(e.payloadType,r.payloadType=_.newBuffer(_.base64.length(e.payloadType)),0):e.payloadType.length&&(r.payloadType=e.payloadType)),e.payload!=null&&(typeof e.payload=="string"?_.base64.decode(e.payload,r.payload=_.newBuffer(_.base64.length(e.payload)),0):e.payload.length&&(r.payload=e.payload)),e.signature!=null&&(typeof e.signature=="string"?_.base64.decode(e.signature,r.signature=_.newBuffer(_.base64.length(e.signature)),0):e.signature.length&&(r.signature=e.signature)),r},n.toObject=function(e,r){r||(r={});var o={};return r.defaults&&(r.bytes===String?o.publicKey="":(o.publicKey=[],r.bytes!==Array&&(o.publicKey=_.newBuffer(o.publicKey))),r.bytes===String?o.payloadType="":(o.payloadType=[],r.bytes!==Array&&(o.payloadType=_.newBuffer(o.payloadType))),r.bytes===String?o.payload="":(o.payload=[],r.bytes!==Array&&(o.payload=_.newBuffer(o.payload))),r.bytes===String?o.signature="":(o.signature=[],r.bytes!==Array&&(o.signature=_.newBuffer(o.signature)))),e.publicKey!=null&&e.hasOwnProperty("publicKey")&&(o.publicKey=r.bytes===String?_.base64.encode(e.publicKey,0,e.publicKey.length):r.bytes===Array?Array.prototype.slice.call(e.publicKey):e.publicKey),e.payloadType!=null&&e.hasOwnProperty("payloadType")&&(o.payloadType=r.bytes===String?_.base64.encode(e.payloadType,0,e.payloadType.length):r.bytes===Array?Array.prototype.slice.call(e.payloadType):e.payloadType),e.payload!=null&&e.hasOwnProperty("payload")&&(o.payload=r.bytes===String?_.base64.encode(e.payload,0,e.payload.length):r.bytes===Array?Array.prototype.slice.call(e.payload):e.payload),e.signature!=null&&e.hasOwnProperty("signature")&&(o.signature=r.bytes===String?_.base64.encode(e.signature,0,e.signature.length):r.bytes===Array?Array.prototype.slice.call(e.signature):e.signature),o},n.prototype.toJSON=function(){return this.constructor.toObject(this,E.util.toJSONOptions)},n})(),Be=E.Reader,jr=E.Writer,P=E.util,G=E.roots.default||(E.roots.default={}),Bu=G.PeerRecord=(()=>{function n(t){if(this.addresses=[],t)for(var e=Object.keys(t),r=0;r<e.length;++r)t[e[r]]!=null&&(this[e[r]]=t[e[r]])}return n.prototype.peerId=P.newBuffer([]),n.prototype.seq=P.Long?P.Long.fromBits(0,0,!0):0,n.prototype.addresses=P.emptyArray,n.encode=function(e,r){if(r||(r=jr.create()),e.peerId!=null&&Object.hasOwnProperty.call(e,"peerId")&&r.uint32(10).bytes(e.peerId),e.seq!=null&&Object.hasOwnProperty.call(e,"seq")&&r.uint32(16).uint64(e.seq),e.addresses!=null&&e.addresses.length)for(var o=0;o<e.addresses.length;++o)G.PeerRecord.AddressInfo.encode(e.addresses[o],r.uint32(26).fork()).ldelim();return r},n.decode=function(e,r){e instanceof Be||(e=Be.create(e));for(var o=r===void 0?e.len:e.pos+r,s=new G.PeerRecord;e.pos<o;){var i=e.uint32();switch(i>>>3){case 1:s.peerId=e.bytes();break;case 2:s.seq=e.uint64();break;case 3:s.addresses&&s.addresses.length||(s.addresses=[]),s.addresses.push(G.PeerRecord.AddressInfo.decode(e,e.uint32()));break;default:e.skipType(i&7);break}}return s},n.fromObject=function(e){if(e instanceof G.PeerRecord)return e;var r=new G.PeerRecord;if(e.peerId!=null&&(typeof e.peerId=="string"?P.base64.decode(e.peerId,r.peerId=P.newBuffer(P.base64.length(e.peerId)),0):e.peerId.length&&(r.peerId=e.peerId)),e.seq!=null&&(P.Long?(r.seq=P.Long.fromValue(e.seq)).unsigned=!0:typeof e.seq=="string"?r.seq=parseInt(e.seq,10):typeof e.seq=="number"?r.seq=e.seq:typeof e.seq=="object"&&(r.seq=new P.LongBits(e.seq.low>>>0,e.seq.high>>>0).toNumber(!0))),e.addresses){if(!Array.isArray(e.addresses))throw TypeError(".PeerRecord.addresses: array expected");r.addresses=[];for(var o=0;o<e.addresses.length;++o){if(typeof e.addresses[o]!="object")throw TypeError(".PeerRecord.addresses: object expected");r.addresses[o]=G.PeerRecord.AddressInfo.fromObject(e.addresses[o])}}return r},n.toObject=function(e,r){r||(r={});var o={};if((r.arrays||r.defaults)&&(o.addresses=[]),r.defaults)if(r.bytes===String?o.peerId="":(o.peerId=[],r.bytes!==Array&&(o.peerId=P.newBuffer(o.peerId))),P.Long){var s=new P.Long(0,0,!0);o.seq=r.longs===String?s.toString():r.longs===Number?s.toNumber():s}else o.seq=r.longs===String?"0":0;if(e.peerId!=null&&e.hasOwnProperty("peerId")&&(o.peerId=r.bytes===String?P.base64.encode(e.peerId,0,e.peerId.length):r.bytes===Array?Array.prototype.slice.call(e.peerId):e.peerId),e.seq!=null&&e.hasOwnProperty("seq")&&(typeof e.seq=="number"?o.seq=r.longs===String?String(e.seq):e.seq:o.seq=r.longs===String?P.Long.prototype.toString.call(e.seq):r.longs===Number?new P.LongBits(e.seq.low>>>0,e.seq.high>>>0).toNumber(!0):e.seq),e.addresses&&e.addresses.length){o.addresses=[];for(var i=0;i<e.addresses.length;++i)o.addresses[i]=G.PeerRecord.AddressInfo.toObject(e.addresses[i],r)}return o},n.prototype.toJSON=function(){return this.constructor.toObject(this,E.util.toJSONOptions)},n.AddressInfo=function(){function t(e){if(e)for(var r=Object.keys(e),o=0;o<r.length;++o)e[r[o]]!=null&&(this[r[o]]=e[r[o]])}return t.prototype.multiaddr=P.newBuffer([]),t.encode=function(r,o){return o||(o=jr.create()),r.multiaddr!=null&&Object.hasOwnProperty.call(r,"multiaddr")&&o.uint32(10).bytes(r.multiaddr),o},t.decode=function(r,o){r instanceof Be||(r=Be.create(r));for(var s=o===void 0?r.len:r.pos+o,i=new G.PeerRecord.AddressInfo;r.pos<s;){var a=r.uint32();switch(a>>>3){case 1:i.multiaddr=r.bytes();break;default:r.skipType(a&7);break}}return i},t.fromObject=function(r){if(r instanceof G.PeerRecord.AddressInfo)return r;var o=new G.PeerRecord.AddressInfo;return r.multiaddr!=null&&(typeof r.multiaddr=="string"?P.base64.decode(r.multiaddr,o.multiaddr=P.newBuffer(P.base64.length(r.multiaddr)),0):r.multiaddr.length&&(o.multiaddr=r.multiaddr)),o},t.toObject=function(r,o){o||(o={});var s={};return o.defaults&&(o.bytes===String?s.multiaddr="":(s.multiaddr=[],o.bytes!==Array&&(s.multiaddr=P.newBuffer(s.multiaddr)))),r.multiaddr!=null&&r.hasOwnProperty("multiaddr")&&(s.multiaddr=o.bytes===String?P.base64.encode(r.multiaddr,0,r.multiaddr.length):o.bytes===Array?Array.prototype.slice.call(r.multiaddr):r.multiaddr),s},t.prototype.toJSON=function(){return this.constructor.toObject(this,E.util.toJSONOptions)},t}(),n})();E.util.Long=void 0;E.configure();async function Nu(n,t=()=>{}){t(0,"Storing each peerstore key under a single datastore key"),await n.datastore.open();const e={},r=[];for await(const{key:o,value:s}of n.datastore.query({prefix:"/peers"})){r.push(o);const i=o.toString(),[,a,c,d,l]=i.split("/");if(a==="peers"&&["protos","addrs","metadata","keys"].includes(c)&&d)if(e[d]=e[d]||{addresses:[],protocols:[],metadata:[]},c==="protos"){const f=wn.decode(s);e[d].protocols=f.protocols.sort()}else if(c==="addrs"){const f=Dn.decode(s);e[d].addresses=f.addrs.sort((h,y)=>Rt(h.multiaddr).toString().localeCompare(Rt(y.multiaddr).toString())),f.certifiedRecord&&f.certifiedRecord.raw&&(e[d].peerRecordEnvelope=f.certifiedRecord.raw)}else c==="metadata"?e[d].metadata.push({key:l,value:s}):c==="keys"&&(e[d].pubKey=s)}t(33,"Read peer data from store");for(const o of r)await n.datastore.delete(o);t(66,"Removed existing peer data from store");for(const o of Object.keys(e)){const s=e[o];s.metadata=s.metadata.sort((a,c)=>a.key.localeCompare(c.key));const i=vn.encode(s).finish();await n.datastore.put(new M(`/peers/${o}`),i)}await n.datastore.close(),t(100,"Stored each peerstore key under a single datastore key")}async function zu(n,t=()=>{}){t(0,"Storing each peerstore key under a multiple datastore keys"),await n.datastore.open();const e={},r=[];for await(const{key:o,value:s}of n.datastore.query({prefix:"/peers"})){r.push(o);const i=o.toString(),[,,a]=i.split("/");e[a]=vn.decode(s)}t(33,"Read peer data from store");for(const o of r)await n.datastore.delete(o);t(66,"Removed existing peer data from store");for(const[o,s]of Object.entries(e)){if(s.protocols&&s.protocols.length>0&&await n.datastore.put(new M(`/peers/protos/${o}`),wn.encode({protocols:s.protocols}).finish()),s.addresses&&s.addresses.length>0){const i=s.peerRecordEnvelope;let a;if(i){const c=Mu.decode(i),d=Bu.decode(c.payload);a={raw:i,seq:d.seq}}await n.datastore.put(new M(`/peers/addrs/${o}`),Dn.encode({addrs:s.addresses,certifiedRecord:a}).finish())}if(s.metadata&&s.metadata.length>0)for(const{key:i,value:a}of s.metadata)await n.datastore.put(new M(`/peers/metadata/${o}/${i}`),a);s.pubKey&&await n.datastore.put(new M(`/peers/keys/${o}`),s.pubKey)}await n.datastore.close(),t(100,"Stored each peerstore key under multiple datastore keys")}const Uu={version:12,description:"Store each peerstore peer under a single datastore key",migrate:Nu,revert:zu},oe={description:"Empty migration.",migrate:()=>{},revert:()=>{},empty:!0},tr=[Object.assign({version:1},oe),Object.assign({version:2},oe),Object.assign({version:3},oe),Object.assign({version:4},oe),Object.assign({version:5},oe),Object.assign({version:6},oe),Object.assign({version:7},oe),hu,$u,_u,ku,Uu];class lt extends Error{constructor(t){super(t),this.name="NonReversibleMigrationError",this.code=lt.code,this.message=t}}lt.code="ERR_NON_REVERSIBLE_MIGRATION";class Pe extends Error{constructor(t){super(t),this.name="NotInitializedRepoError",this.code=Pe.code,this.message=t}}Pe.code="ERR_NOT_INITIALIZED_REPO";class dt extends Error{constructor(t){super(t),this.name="RequiredParameterError",this.code=dt.code,this.message=t}}dt.code="ERR_REQUIRED_PARAMETER";class ft extends Error{constructor(t){super(t),this.name="InvalidValueError",this.code=ft.code,this.message=t}}ft.code="ERR_INVALID_VALUE";class ge extends Error{constructor(t){super(t),this.name="MissingRepoOptionsError",this.code=ge.code,this.message=t}}ge.code="ERR_MISSING_REPO_OPTIONS";const Fu=Object.freeze(Object.defineProperty({__proto__:null,InvalidValueError:ft,MissingRepoOptionsError:ge,NonReversibleMigrationError:lt,NotInitializedRepoError:Pe,RequiredParameterError:dt},Symbol.toStringTag,{value:"Module"})),vt=H("ipfs:repo:migrator:repo:init");async function qu(n){if(!n)throw new ge("Please pass repo options when trying to open a repo");const t=n.root;try{await t.open();const e=await t.has(Ht),r=await t.has(Cu);return!e||!r?(vt(`Version entry present: ${e}`),vt(`Config entry present: ${r}`),!1):!0}catch(e){return vt("While checking if repo is initialized error was thrown: "+e.message),!1}finally{if(t!==void 0)try{await t.close()}catch{}}}async function mn(n){if(!await qu(n))throw new Pe("Repo is not initialized!");const t=n.root;await t.open();try{return parseInt(ye(await t.get(Ht)))}finally{await t.close()}}async function He(n,t){if(!t)throw new ge("Please pass repo options when trying to open a repo");const e=t.root;await e.open(),await e.put(Ht,ue(String(n))),await e.close()}const Y=H("ipfs:repo:migrator");function Lu(n){return n=n||tr,!Array.isArray(n)||n.length===0?0:n[n.length-1].version}async function Ku(n,t,e,r,o={}){const s=o.ignoreLock??!1,i=o.onProgress,a=o.isDryRun??!1,c=o.migrations??tr;if(!n)throw new W.RequiredParameterError("Path argument is required!");if(!e)throw new W.RequiredParameterError("repoOptions argument is required!");if(!r)throw new W.RequiredParameterError("toVersion argument is required!");if(!Number.isInteger(r)||r<=0)throw new W.InvalidValueError("Version has to be positive integer!");t=yn(t);const d=await mn(t);if(d===r){Y("Nothing to migrate.");return}if(d>r)throw new W.InvalidValueError(`Current repo's version (${d}) is higher then toVersion (${r}), you probably wanted to revert it?`);En(c,d,r);let l;!a&&!s&&(l=await e.repoLock.lock(n));try{for(const f of c){if(r!==void 0&&f.version>r)break;if(!(f.version<=d)){Y(`Migrating version ${f.version}`);try{if(!a){let h=()=>{};i&&(h=(y,u)=>i(f.version,y.toFixed(2),u)),await f.migrate(t,h)}}catch(h){const y=f.version-1;throw Y(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${y}`),await He(y,t),new Error(`During migration to version ${f.version} exception was raised: ${h.stack||h.message||h}`)}Y(`Migrating to version ${f.version} finished`)}}a||await He(r||Lu(c),t),Y("Repo successfully migrated",r!==void 0?`to version ${r}!`:"to latest version!")}finally{!a&&!s&&l&&await l.close()}}async function Vu(n,t,e,r,o={}){const s=o.ignoreLock??!1,i=o.onProgress,a=o.isDryRun??!1,c=o.migrations??tr;if(!n)throw new W.RequiredParameterError("Path argument is required!");if(!e)throw new W.RequiredParameterError("repoOptions argument is required!");if(!r)throw new W.RequiredParameterError("When reverting migrations, you have to specify to which version to revert!");if(!Number.isInteger(r)||r<=0)throw new W.InvalidValueError("Version has to be positive integer!");t=yn(t);const d=await mn(t);if(d===r){Y("Nothing to revert.");return}if(d<r)throw new W.InvalidValueError(`Current repo's version (${d}) is lower then toVersion (${r}), you probably wanted to migrate it?`);En(c,r,d,!0);let l;!a&&!s&&(l=await e.repoLock.lock(n)),Y(`Reverting from version ${d} to ${r}`);try{const f=c.slice().reverse();for(const h of f){if(h.version<=r)break;if(!(h.version>d)){Y(`Reverting migration version ${h.version}`);try{if(!a){let y=()=>{};i&&(y=(u,p)=>i(h.version,u.toFixed(2),p)),await h.revert(t,y)}}catch(y){const u=h.version;throw Y(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${u}`),await He(u,t),y.message=`During reversion to version ${h.version} exception was raised: ${y.message}`,y}Y(`Reverting to version ${h.version} finished`)}}a||await He(r,t),Y(`All migrations successfully reverted to version ${r}!`)}finally{!a&&!s&&l&&await l.close()}}function En(n,t,e,r=!1){let o=0;for(const s of n){if(s.version>e)break;if(s.version>t){if(r&&!s.revert)throw new W.NonReversibleMigrationError(`It is not possible to revert to version ${t} because migration version ${s.version} is not reversible. Cancelling reversion.`);o++}}if(o!==e-t)throw new W.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${t} to ${e}`)}const W=Fu,mt=12;class pt extends Error{constructor(t){super(t),this.name="LockExistsError",this.code=pt.code}}pt.code="ERR_LOCK_EXISTS";class ne extends Error{constructor(t){super(t),this.name="NotFoundError",this.code=ne.code}}ne.code="ERR_NOT_FOUND";class ht extends Error{constructor(t){super(t),this.name="InvalidRepoVersionError",this.code=ht.code}}ht.code="ERR_INVALID_REPO_VERSION";const Ne="ERR_REPO_NOT_INITIALIZED",Ju="ERR_REPO_ALREADY_OPEN",Wu="ERR_REPO_ALREADY_CLOSED";async function $n(n,t,e){const r=await t(n);if(r)return r;const o=On(e);return o?new Promise((s,i)=>{const a=o.store("readonly").get(n.toString());a.transaction.onabort=()=>{i(a.transaction.error)},a.transaction.oncomplete=()=>{s(!!a.result)}}):!1}async function Cn(n,t,e,r){if(await e(n))return t(n);const o=On(r);if(!o)throw new ne;return new Promise((s,i)=>{const a=o.store("readonly").get(n.toString());a.transaction.onabort=()=>{i(a.transaction.error)},a.transaction.oncomplete=()=>{if(a.result)return s(a.result);i(new ne)}})}function On(n){let t=n;for(;t.db||t.child;)if(t=t.db||t.child,t.type==="level-js"||t.constructor.name==="Level")return t}const Gu=H("ipfs:repo:version"),Et=new M("version");function Qu(n){return{async exists(){return $n(Et,n.has.bind(n),n)},async get(){const t=await Cn(Et,n.get.bind(n),n.has.bind(n),n);return parseInt(ye(t),10)},set(t){return n.put(Et,ue(String(t)))},async check(t){const e=await this.get();return Gu("comparing version: %s and %s",e,t),e===t||(e===6&&t===7||t===6&&e===7)}}}const Yu=yt.default?yt.default:yt,$t=new M("config");function Xu(n){const t=new Yu({concurrency:1}),e={async getAll(s={}){const i=await Cn($t,n.get.bind(n),n.has.bind(n),n);return JSON.parse(ye(i))},async get(s,i={}){if(s==null)throw new ne(`Key ${s} does not exist in config`);const a=await this.getAll(i),c=Vt(a,s);if(c===void 0)throw new ne(`Key ${s} does not exist in config`);return c},set(s,i,a={}){if(typeof s!="string"&&!(s instanceof String))throw K(new Error("Invalid key type: "+typeof s),"ERR_INVALID_KEY");if(i===void 0||i instanceof Uint8Array)throw K(new Error("Invalid value type: "+typeof i),"ERR_INVALID_VALUE");return t.add(()=>r({key:s,value:i},a.signal))},replace(s,i={}){if(!s||s instanceof Uint8Array)throw K(new Error("Invalid value type: "+typeof s),"ERR_INVALID_VALUE");return t.add(()=>r({key:void 0,value:s},i.signal))},async exists(){return $n($t,n.has.bind(n),n)}};return e;async function r(s,i){if(i&&i.aborted)return;const a=s.key,c=s.value;if(a){const d=await e.getAll();return typeof d=="object"&&d!==null&&Bn(d,a,c),o(d)}return o(c)}function o(s){const i=ue(JSON.stringify(s,null,2));return n.put($t,i)}}const Ct=new M("datastore_spec");function Zu(n){return{exists(){return n.has(Ct)},async get(){const t=await n.get(Ct);return JSON.parse(ye(t))},async set(t){return n.put(Ct,ue(JSON.stringify(Nn(t,{deep:!0}))))}}}const Ot=new M("api");function Hu(n){return{async get(){const t=await n.get(Ot);return t&&t.toString()},set(t){return n.put(Ot,ue(t.toString()))},delete(){return n.delete(Ot)}}}function el(n){return{open(){return n.open()},close(){return n.close()},query(t,e){return n.query(t,e)},queryKeys(t,e){return n.queryKeys(t,e)},async get(t,e){const r=ee(t);return r.isIdentity?Promise.resolve(r.digest):n.get(t,e)},async*getMany(t,e){for await(const r of t)yield this.get(r,e)},async put(t,e,r){const{isIdentity:o}=ee(t);o||await n.put(t,e,r)},async*putMany(t,e){const r=zn({objectMode:!0});(globalThis.process&&globalThis.process.nextTick?globalThis.process.nextTick:globalThis.setImmediate||globalThis.setTimeout)(async()=>{try{await Un(n.putMany(async function*(){for await(const{key:s,value:i}of t)ee(s).isIdentity||(yield{key:s,value:i}),r.push({key:s,value:i})}())),r.end()}catch(s){r.end(s)}}),yield*r},has(t,e){const{isIdentity:r}=ee(t);return r?Promise.resolve(!0):n.has(t,e)},delete(t,e){const{isIdentity:r}=ee(t);return r?Promise.resolve():n.delete(t,e)},deleteMany(t,e){return n.deleteMany(Fr(t,r=>!ee(r).isIdentity),e)},batch(){const t=n.batch();return{put(e,r){const{isIdentity:o}=ee(e);o||t.put(e,r)},delete(e){const{isIdentity:r}=ee(e);r||t.delete(e)},commit:e=>t.commit(e)}}}}function ee(n){const t=O.asCID(n);if(t==null)throw K(new Error("Not a valid cid"),"ERR_INVALID_CID");return t.multihash.code!==lu.code?{isIdentity:!1}:{isIdentity:!0,digest:t.multihash.digest}}const Sn=H("ipfs:repo:lock:memory"),An="repo.lock",$e={};async function tl(n){const t=n+"/"+An;if(Sn("locking %s",t),$e[t]===!0)throw new pt(`Lock already being held for file: ${t}`);return $e[t]=!0,{async close(){$e[t]&&delete $e[t]}}}async function rl(n){const t=n+"/"+An;return Sn(`checking lock: ${t}`),!!$e[t]}const nl={lock:tl,locked:rl},ol={autoMigrate:!0,onMigrationProgress:()=>{},repoOwner:!0,repoLock:nl},xn={Spec:{type:"mount",mounts:[{mountpoint:"/blocks",type:"measure",prefix:"flatfs.datastore",child:{type:"flatfs",path:"blocks",sync:!0,shardFunc:"/repo/flatfs/shard/v1/next-to-last/2"}},{mountpoint:"/",type:"measure",prefix:"leveldb.datastore",child:{type:"levelds",path:"datastore",compression:"none"}}]}};function ze({enumerable:n=!0,configurable:t=!1}={}){return{enumerable:n,configurable:t,writable:!1}}function*sl(n,t){if(t!=null&&typeof t=="object")if(Array.isArray(t))for(const[e,r]of t.entries()){const o=[...n,e],s=O.asCID(r);s?yield[o.join("/"),s]:typeof r=="object"&&(yield*Nt(r,o))}else{const e=O.asCID(t);e?yield[n.join("/"),e]:yield*Nt(t,n)}}function*Nt(n,t){if(!(n==null||n instanceof Uint8Array))for(const[e,r]of Object.entries(n)){const o=[...t,e];yield*sl(o,r)}}function*il(n,t){if(Array.isArray(t))for(const[e,r]of t.entries()){const o=[...n,e];yield o.join("/"),typeof r=="object"&&!O.asCID(r)&&(yield*zt(r,o))}else yield*zt(t,n)}function*zt(n,t){if(!(n==null||typeof n!="object"))for(const[e,r]of Object.entries(n)){const o=[...t,e];yield o.join("/"),r!=null&&!(r instanceof Uint8Array)&&typeof r=="object"&&!O.asCID(r)&&(yield*il(o,r))}}function al(n,t){let e=n;for(const[r,o]of t.entries()){if(e=e[o],e==null)throw new Error(`Object has no property at ${t.slice(0,r+1).map(i=>`[${JSON.stringify(i)}]`).join("")}`);const s=O.asCID(e);if(s)return{value:s,remaining:t.slice(r+1).join("/")}}return{value:e}}class cl{constructor({cid:t,bytes:e,value:r}){if(!t||!e||typeof r>"u")throw new Error("Missing required argument");this.cid=t,this.bytes=e,this.value=r,this.asBlock=this,Object.defineProperties(this,{cid:ze(),bytes:ze(),value:ze(),asBlock:ze()})}links(){return Nt(this.value,[])}tree(){return zt(this.value,[])}get(t="/"){return al(this.value,t.split("/").filter(Boolean))}}function _n({bytes:n,cid:t,value:e,codec:r}){const o=e!==void 0?e:r&&r.decode(n);if(o===void 0)throw new Error('Missing required argument, must either provide "value" or "codec"');return new cl({cid:t,bytes:n,value:o})}function Ue(n){const t=O.asCID(n);if(t==null)throw K(new Error("Not a valid cid"),"ERR_INVALID_CID");const e=q.encode(t.multihash.bytes);return new M("/"+e.slice(1).toUpperCase(),!1)}function kr(n){return it(q.decode(`b${n.toString().toLowerCase().substring(1)}`))}const ul=H("ipfs:repo:utils:walk-dag");async function*et(n,t,e,r){try{const o=await t.get(n,r),s=await e(n.code),i=_n({bytes:o,cid:n,codec:s});for(const[,a]of i.links())yield a,yield*et(a,t,e,r)}catch(o){throw ul("Could not walk DAG for CID",n.toString(),o),o}}const J={direct:"direct",recursive:"recursive",indirect:"indirect",all:"all"},ll=2048;function dl(n){const t=`Invalid type '${n}', must be one of {direct, indirect, recursive, all}`;return K(new Error(t),"ERR_INVALID_PIN_TYPE")}class fl{constructor({pinstore:t,blockstore:e,loadCodec:r}){this.pinstore=t,this.blockstore=e,this.loadCodec=r,this.log=H("ipfs:repo:pin"),this.directPins=new Set,this.recursivePins=new Set}async pinDirectly(t,e={}){await this.blockstore.get(t,e);const r={depth:0};return t.version!==0&&(r.version=t.version),t.code!==te&&(r.codec=t.code),e.metadata&&(r.metadata=e.metadata),this.pinstore.put(Ue(t),Le(r))}unpin(t,e){return this.pinstore.delete(Ue(t),e)}async pinRecursively(t,e={}){await this.fetchCompleteDag(t,e);const r={depth:1/0};t.version!==0&&(r.version=t.version),t.code!==te&&(r.codec=t.code),e.metadata&&(r.metadata=e.metadata),await this.pinstore.put(Ue(t),Le(r))}async*directKeys(t){for await(const e of this.pinstore.query({filters:[r=>se(r.value).depth===0]})){const r=se(e.value),o=r.version||0,s=r.codec!=null?r.codec:te,i=kr(e.key);yield{cid:O.create(o,s,i),metadata:r.metadata}}}async*recursiveKeys(t){for await(const e of this.pinstore.query({filters:[r=>se(r.value).depth===1/0]})){const r=se(e.value),o=r.version||0,s=r.codec!=null?r.codec:te,i=kr(e.key);yield{cid:O.create(o,s,i),metadata:r.metadata}}}async*indirectKeys(t){for await(const{cid:e}of this.recursiveKeys())for await(const r of et(e,this.blockstore,this.loadCodec,t)){const o=[J.recursive];(await this.isPinnedWithType(r,o)).pinned||(yield r)}}async isPinnedWithType(t,e,r){Array.isArray(e)||(e=[e]);const o=e.includes(J.all),s=e.includes(J.direct),i=e.includes(J.recursive),a=e.includes(J.indirect);if(i||s||o){const l=await rr(this.pinstore.query({prefix:Ue(t).toString(),filters:[f=>{if(o)return!0;const h=se(f.value);return e.includes(h.depth===0?J.direct:J.recursive)}],limit:1}));if(l){const f=se(l.value);return{cid:t,pinned:!0,reason:f.depth===0?J.direct:J.recursive,metadata:f.metadata}}}const c=this;async function*d(l,f){for await(const{cid:h}of f)for await(const y of et(h,c.blockstore,c.loadCodec))if(y.equals(l)){yield h;return}}if(o||a){const l=await rr(d(t,this.recursiveKeys()));if(l)return{cid:t,pinned:!0,reason:J.indirect,parent:l}}return{cid:t,pinned:!1}}async fetchCompleteDag(t,e={}){const r=new Fn({maxSize:e.cidCacheMaxSize??ll}),o=async(s,i)=>{if(r.has(s.toString()))return;r.set(s.toString(),!0);const a=await this.blockstore.get(s,i),c=await this.loadCodec(s.code),d=_n({bytes:a,cid:s,codec:c});await Promise.all([...d.links()].map(([,l])=>o(l,i)))};await o(t,e)}static checkPinType(t){if(typeof t!="string"||!Object.keys(J).includes(t))throw dl(t);return!0}}function pl(n,t){return{open(){return t.open()},close(){return t.close()},query(e,r){return t.query(e,r)},queryKeys(e,r){return t.queryKeys(e,r)},async get(e,r){return t.get(e,r)},async*getMany(e,r){yield*t.getMany(e,r)},async put(e,r,o){await t.put(e,r,o)},async*putMany(e,r){yield*t.putMany(e,r)},has(e,r){return t.has(e,r)},async delete(e,r){return await Rr(e,n),t.delete(e,r)},deleteMany(e,r){return t.deleteMany(Ke(e,async o=>(await Rr(o,n),o)),r)},batch(){return t.batch()}}}async function Rr(n,t){const{pinned:e,reason:r}=await t.isPinnedWithType(n,J.all);if(e)throw K(new Error(`pinned: ${r}`),"ERR_BLOCK_PINNED")}const Ce=H("ipfs:repo:gc"),hl=At().code,yl=256,bl=new M("/local/filesroot");function gl({gcLock:n,pins:t,blockstore:e,root:r,loadCodec:o}){async function*s(){const i=Date.now();Ce("Creating set of marked blocks");const a=await n.writeLock();try{const c=await wl({pins:t,blockstore:e,root:r,loadCodec:o}),d=e.queryKeys({});yield*Dl({blockstore:e},c,d),Ce(`Complete (${Date.now()-i}ms)`)}finally{a()}}return s}async function wl({pins:n,blockstore:t,loadCodec:e,root:r}){const o=async function*(){let a;try{a=await r.get(bl)}catch(d){if(d.code===hl){Ce("No blocks in MFS");return}throw d}const c=O.decode(a);yield c,yield*et(c,t,e)}(),s=nr(Ke(n.recursiveKeys(),({cid:a})=>a),n.indirectKeys(),Ke(n.directKeys(),({cid:a})=>a),o),i=new Set;for await(const a of nr(s,o))i.add(q.encode(a.multihash.bytes));return i}async function*Dl({blockstore:n},t,e){let r=0,o=0;yield*qn(Ln(Ke(e,async i=>async function(){r++;try{const c=q.encode(i.multihash.bytes);if(t.has(c))return null;try{await n.delete(i),o++}catch(d){return{err:new Error(`Could not delete block with CID ${i}: ${d.message}`)}}return{cid:i}}catch(c){const d=`Could delete block with CID ${i}`;return Ce(d,c),{err:new Error(d+`: ${c.message}`)}}}),yl),i=>Fr(i,Boolean)),Ce(`Marked set has ${t.size} unique blocks. Blockstore has ${r} blocks. Deleted ${o} blocks.`)}const L=H("ipfs:repo"),vl=Number.MAX_SAFE_INTEGER,ml="repoAutoMigrate";class El{constructor(t,e,r,o){if(typeof t!="string")throw new Error("missing repo path");if(typeof e!="function")throw new Error("missing codec loader");this.options=Kn(ol,o),this.closed=!0,this.path=t,this.root=r.root,this.datastore=r.datastore,this.keys=r.keys;const s=r.blocks,i=r.pins;this.pins=new fl({pinstore:i,blockstore:s,loadCodec:e});const a=pl(this.pins,s);this.blocks=el(a),this.version=Qu(this.root),this.config=Xu(this.root),this.spec=Zu(this.root),this.apiAddr=Hu(this.root),this.gcLock=Vn({name:t,singleProcess:this.options.repoOwner!==!1}),this.gc=gl({gcLock:this.gcLock,pins:this.pins,blockstore:this.blocks,root:this.root,loadCodec:e})}async init(t){L("initializing at: %s",this.path),await this._openRoot(),await this.config.replace(Cl(t)),await this.spec.set(Ol(t)),await this.version.set(mt)}async isInitialized(){if(!this.closed)return!0;try{return await this._openRoot(),await this._checkInitialized(),await this.root.close(),!0}catch{return!1}}async open(){if(!this.closed)throw K(new Error("repo is already open"),Ju);L("opening at: %s",this.path);try{if(await this._openRoot(),await this._checkInitialized(),this._lockfile=await this._openLock(),L("acquired repo.lock"),!await this.version.check(mt))if(await this._isAutoMigrationEnabled())await this._migrate(mt,{root:this.root,datastore:this.datastore,pins:this.pins.pinstore,blocks:this.pins.blockstore,keys:this.keys});else throw new ht("Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.");L("creating datastore"),await this.datastore.open(),L("creating blocks"),await this.blocks.open(),L("creating keystore"),await this.keys.open(),L("creating pins"),await this.pins.pinstore.open(),this.closed=!1,L("all opened")}catch(t){if(this._lockfile)try{await this._closeLock(),this._lockfile=null}catch(e){L("error removing lock",e)}throw t}}async _openRoot(){try{await this.root.open()}catch(t){if(t.message!=="Already open")throw t}}async _openLock(){const t=await this.options.repoLock.lock(this.path);if(typeof t.close!="function")throw K(new Error("Locks must have a close method"),"ERR_NO_CLOSE_FUNCTION");return t}_closeLock(){return this._lockfile&&this._lockfile.close()}async _checkInitialized(){L("init check");let t;try{[t]=await Promise.all([this.config.exists(),this.spec.exists(),this.version.exists()])}catch(e){throw e.code==="ERR_NOT_FOUND"?K(new Error("repo is not initialized yet"),Ne,{path:this.path}):e}if(!t)throw K(new Error("repo is not initialized yet"),Ne,{path:this.path})}async close(){if(this.closed)throw K(new Error("repo is already closed"),Wu);L("closing at: %s",this.path);try{await this.apiAddr.delete()}catch(t){if(t.code!==Ne&&!t.message.startsWith("ENOENT"))throw t}await Promise.all([this.root,this.blocks,this.keys,this.datastore,this.pins.pinstore].map(t=>t&&t.close())),L("unlocking"),this.closed=!0,await this._closeLock()}exists(){return this.version.exists()}async stat(){if(this.datastore&&this.keys){const[t,e,r,o,s]=await Promise.all([this._storageMaxStat(),this._blockStat(),this.version.get(),Tr(this.datastore),Tr(this.keys)]),i=e.size+o+s;return{repoPath:this.path,storageMax:t,version:r,numObjects:e.count,repoSize:i}}throw K(new Error("repo is not initialized yet"),Ne,{path:this.path})}async _isAutoMigrationEnabled(){if(this.options.autoMigrate!==void 0)return this.options.autoMigrate;let t;try{t=await this.config.get(ml)}catch(e){if(e.code===ne.code)t=!0;else throw e}return t}async _migrate(t,e){return await this.version.get()>t?(L(`reverting to version ${t}`),Vu(this.path,e,this.options,t,{ignoreLock:!0,onProgress:this.options.onMigrationProgress})):(L(`migrating to version ${t}`),Ku(this.path,e,this.options,t,{ignoreLock:!0,onProgress:this.options.onMigrationProgress}))}async _storageMaxStat(){try{const t=await this.config.get("Datastore.StorageMax");return BigInt(Jn(t))}catch{return BigInt(vl)}}async _blockStat(){let t=BigInt(0),e=BigInt(0);if(this.blocks)for await(const{key:r,value:o}of this.blocks.query({}))t+=BigInt(1),e+=BigInt(o.byteLength),e+=BigInt(r.bytes.byteLength);return{count:t,size:e}}}async function Tr(n){let t=BigInt(0);for await(const e of n.query({}))t+=BigInt(e.value.byteLength),t+=BigInt(e.key.uint8Array().byteLength);return t}function $l(n,t,e,r){return new El(n,t,e,r)}function Cl(n){return n.Datastore=Object.assign({},xn,Vt(n,"datastore")),n}function Ol(n){const t={...xn.Spec,...Vt(n,"Datastore.Spec")};return{type:t.type,mounts:t.mounts.map(e=>({mountpoint:e.mountpoint,type:e.child.type,path:e.child.path,shardFunc:e.child.shardFunc}))}}function Sl(n){const t=new Wn;return $l(n,e=>{const r={[te]:or,[Qn]:or,[Yn]:sr,[Xn]:sr,[Zt]:Er,[cn]:Er};return Promise.resolve(r[e])},{root:new je(`${n}/root`,{prefix:"",version:2}),blocks:new Gn(new je(`${n}/blocks`,{prefix:"",version:2})),keys:new je(`${n}/keys`,{prefix:"",version:2}),datastore:t,pins:new je(`${n}/pins`,{prefix:"",version:2})},{repoLock:{lock:async()=>({close:async()=>{}}),locked:async()=>!1},autoMigrate:!1})}const Ut={},Al=/^((?!chrome|android).)*safari/i.test(globalThis.navigator?.userAgent||""),Pn=1*60*1e3,Ft=5*60*1e3,qt={retryNumber:0,lastBackoff:0,currentBackoff:1e3},xl={config:{Addresses:{Delegates:[]},Bootstrap:[],Discovery:{webRTCStar:{Enabled:!1}},Pubsub:{Enabled:!1}},preload:{enabled:!1,addresses:[]},libp2p:{peerDiscovery:[],connectionManager:{autoDial:!1}},init:{algorithm:Al?to:void 0,emptyRepo:!0}};async function _l(n,t,e,r,o){const s=await Mr(n.storage,e);if(s.length===0)throw new Error("ðŸ’¥ Couldn't start IPFS node, peer list is empty");const i=Sl(r),a=await t.create({...xl,repo:i});return s.forEach(c=>{Ut[c.toString()]=null,Nr(a,c,o)}),globalThis.addEventListener("online",async()=>{(await Mr(n.storage,e)).filter(c=>{const d=c.toString();return!d.includes("/localhost/")&&!d.includes("/127.0.0.1/")&&!d.includes("/0.0.0.0/")}).forEach(c=>{Nr(a,c,o)})}),o&&console.log("ðŸš€ Started IPFS node"),{ipfs:a,repo:i}}function Ir(n){return fetch(n).then(t=>t.json()).then(t=>Array.isArray(t)?t:[]).then(t=>t.filter(e=>qr(e)&&e.includes("/wss/"))).catch(()=>{throw new Error("ðŸ’¥ Couldn't start IPFS node, failed to fetch peer list")})}async function Mr(n,t){let e;const r=`ipfs-peers-${t}`,o=await n.getItem(r);return qr(o)&&o.trim()!==""?(e=JSON.parse(o),Ir(t).then(s=>n.setItem(r,JSON.stringify(s))).catch(s=>{console.error(s)})):(e=await Ir(t),await n.setItem(r,JSON.stringify(e))),e.map(Rt)}function Oe(n,t,e,r){let o=null;e.currentBackoff<Ft?o=setTimeout(()=>Br(n,t,e,r),e.currentBackoff):o=setTimeout(()=>Br(n,t,e,r),Ft),Ut[t.toString()]=o,jn(n,t).then(({latency:s})=>{const i={connected:!0,lastConnectedAt:Date.now(),latency:s};tt(t,i),o&&clearTimeout(o),o===Ut[t.toString()]&&setTimeout(()=>Oe(n,t,qt,i),Pn)}).catch(()=>{})}async function Br(n,t,e,r){const o={...r,connected:!1,latency:null};tt(t,o);try{await n.swarm.disconnect(t),await n.swarm.connect(t)}catch{}if(e.currentBackoff<Ft){const s={retryNumber:e.retryNumber+1,lastBackoff:e.currentBackoff,currentBackoff:e.lastBackoff+e.currentBackoff};Oe(n,t,s,o)}else Oe(n,t,e,o)}function Nr(n,t,e){jn(n,t).then(({latency:r})=>n.swarm.connect(t,{timeout:60*1e3}).then(()=>{e&&console.log(`ðŸª Connected to ${t}`);const o={connected:!0,lastConnectedAt:Date.now(),latency:r};tt(t,o),setTimeout(()=>Oe(n,t,qt,o),Pn)})).catch(()=>{e&&console.log(`ðŸª“ Could not connect to ${t}`);const r={connected:!1,lastConnectedAt:null,latency:null};tt(t,r),Oe(n,t,qt,r)})}async function jn(n,t){return n.libp2p.ping(t).then(e=>({latency:e}))}let fe=[];function tt(n,t){fe=fe.filter(r=>r.peer!==n).concat({peer:n,status:t}),fe.every(r=>!r.status.connected),fe.reduce((r,{status:o})=>r>=(o.lastConnectedAt||0)?r:o.lastConnectedAt||0,0);const e=fe.filter(r=>r.status.latency!==null);e.length>0&&fe.reduce((r,o)=>r+(o.status.latency||0),0)/e.length}const Pl="https://unpkg.com/ipfs-core@0.17.0/dist/index.min.js",jl=(n,t,e,r,o)=>_l(n,t,e,r,o),kl=async n=>{if(!n)throw new Error("This function requires a URL to a CDN");return ro(()=>import(n),[]).then(t=>self.IpfsCore)};async function Rl(n){return{getBlock:async t=>{const{ipfs:e}=await n();return e.block.get(t)},getUnixDirectory:async t=>{const{ipfs:e}=await n(),r=[];for await(const o of e.ls(t)){const{name:s="",cid:i,size:a,type:c}=o;r.push({name:s,cid:i,size:a,isFile:c!=="dir"})}return r},getUnixFile:async t=>{const{ipfs:e}=await n(),r=[];for await(const o of e.cat(t))r.push(o);return Zn(r)},putBlock:async(t,e)=>{const{repo:r}=await n(),o=Hn(e),s=await ct.digest(t),i=O.createV1(o.code,s);return await r.blocks.put(i,t),i},putChunked:async t=>{const{ipfs:e}=await n();return{...await e.add(t,{cidVersion:1,hashAlg:"sha2-256",rawLeaves:!0,wrapWithDirectory:!1,preload:!1,pin:!1}),isFile:!0}},size:async t=>{const{ipfs:e}=await n();return(await e.files.stat(`/ipfs/${t}`)).cumulativeSize}}}async function Tl(n,t,e){let r=null;return Rl(async()=>r||(r=await jl(n,await kl(Pl),t,e,!1),r))}async function td(n,t){return Tl(n,eo.server+"/ipfs/peers",t)}export{O as C,ae as a,Q as b,Ao as c,ed as d,Gl as e,Es as f,Hl as g,Nl as h,it as i,Jr as j,Zt as k,q as l,wc as m,cn as n,Z as o,td as p,Er as r};
//# sourceMappingURL=ipfs-modules-5ddb521f.js.map
