var uh=Object.defineProperty;var dh=(s,e,t)=>e in s?uh(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t;var Wn=(s,e,t)=>(dh(s,typeof e!="symbol"?e+"":e,t),t),oo=(s,e,t)=>{if(!e.has(s))throw TypeError("Cannot "+t)};var We=(s,e,t)=>(oo(s,e,"read from private field"),t?t.call(s):e.get(s)),hr=(s,e,t)=>{if(e.has(s))throw TypeError("Cannot add the same private member more than once");e instanceof WeakSet?e.add(s):e.set(s,t)},Dt=(s,e,t,r)=>(oo(s,e,"write to private field"),r?r.call(s,t):e.set(s,t),t);import{e as xr,i as hh,$ as D,j as y,t as R,k as ul,l as dl,m as hn,v as j,n as Q,o as oe,q as fn,u as hl,x as pn,y as Jr,z as yn,K as ae,A as V,B as fi,C as fh,D as ph,E as yh,F as wh,G as gh,P as Ue,I as Ce,J as At,L as Us,M as _a,N as pi,O as bh,Q as mh,R as fl,S as _h,T as Eh,U as Jn,V as Gn,W as wn,X as Tr,Y as vh,Z as _e,a0 as Dh,a1 as it,a2 as Ve,a3 as pl,a4 as gn,a5 as Sh,a6 as Gr,a7 as Qr,a8 as yi,a9 as kh,aa as Xe,ab as J,ac as gt,ad as yl,ae as wi,af as $h,ag as Ns,ah as bn,ai as nr,aj as le,ak as Fs,al as Ph,am as Xr,an as co,ao as lo,ap as uo,aq as re,ar as Ah,as as Hs,at as Rh,au as Th,av as wl,_ as ho,aw as Oh,ax as ct,ay as qs,az as Ch,aA as Ih,aB as Ks,aC as kt,aD as gi,aE as Nh,aF as xh,aG as Ea,aH as Lh,aI as fr,aJ as Bh,aK as jh,aL as Mr,aM as gl,aN as bl,aO as Mh,aP as zh,aQ as Uh,aR as Fh,aS as Hh,aT as qh,aU as Kh,aV as Yr,aW as fo,aX as ml,aY as Vh,aZ as zr,a_ as va,a$ as Wh,b0 as Ye,b1 as ye,b2 as Jh,b3 as _l,b4 as Da,b5 as Gh,b6 as Qh}from"./other-modules-3990ee0b.js";import{C as El,p as pe,l as M,i as Lr,a as vl,b as mn,L as po,u as bi,c as mi,d as Xh,e as Yh,t as _n,f as Zh}from"./libp2p-modules-7ceb3045.js";import{g as ef}from"./ionic-modules-23047cf7.js";import{C as xs,I as yo,K as Sa,a as ka,S as wo,E as Dl,F as Sl,b as kl,c as $l,D as Pl}from"./orbit-modules-7eb78d3b.js";function tf(s){throw new Error('Could not dynamically require "'+s+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}const rf=hh,En=typeof window=="object"&&typeof document=="object"&&document.nodeType===9,Zr=rf(),sf=En&&!Zr,nf=Zr&&!En,af=Zr&&En,of=typeof tf=="function"&&typeof xr<"u"&&typeof xr.release<"u"&&xr.release.name==="node"&&!Zr,cf=typeof importScripts=="function"&&typeof self<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope,lf=typeof xr<"u"&&typeof xr.env<"u"&&!1,uf=typeof navigator<"u"&&navigator.product==="ReactNative";var ot={isTest:lf,isElectron:Zr,isElectronMain:nf,isElectronRenderer:af,isNode:of,isBrowser:sf,isWebWorker:cf,isEnvWithDom:En,isReactNative:uf};function df(s,e){if(s.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),r=0;r<t.length;r++)t[r]=255;for(var n=0;n<s.length;n++){var a=s.charAt(n),i=a.charCodeAt(0);if(t[i]!==255)throw new TypeError(a+" is ambiguous");t[i]=n}var o=s.length,c=s.charAt(0),l=Math.log(o)/Math.log(256),u=Math.log(256)/Math.log(o);function d(p){if(p instanceof Uint8Array||(ArrayBuffer.isView(p)?p=new Uint8Array(p.buffer,p.byteOffset,p.byteLength):Array.isArray(p)&&(p=Uint8Array.from(p))),!(p instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(p.length===0)return"";for(var g=0,_=0,v=0,k=p.length;v!==k&&p[v]===0;)v++,g++;for(var P=(k-v)*u+1>>>0,T=new Uint8Array(P);v!==k;){for(var I=p[v],x=0,C=P-1;(I!==0||x<_)&&C!==-1;C--,x++)I+=256*T[C]>>>0,T[C]=I%o>>>0,I=I/o>>>0;if(I!==0)throw new Error("Non-zero carry");_=x,v++}for(var S=P-_;S!==P&&T[S]===0;)S++;for(var L=c.repeat(g);S<P;++S)L+=s.charAt(T[S]);return L}function h(p){if(typeof p!="string")throw new TypeError("Expected String");if(p.length===0)return new Uint8Array;var g=0;if(p[g]!==" "){for(var _=0,v=0;p[g]===c;)_++,g++;for(var k=(p.length-g)*l+1>>>0,P=new Uint8Array(k);p[g];){var T=t[p.charCodeAt(g)];if(T===255)return;for(var I=0,x=k-1;(T!==0||I<v)&&x!==-1;x--,I++)T+=o*P[x]>>>0,P[x]=T%256>>>0,T=T/256>>>0;if(T!==0)throw new Error("Non-zero carry");v=I,g++}if(p[g]!==" "){for(var C=k-v;C!==k&&P[C]===0;)C++;for(var S=new Uint8Array(_+(k-C)),L=_;C!==k;)S[L++]=P[C++];return S}}}function f(p){var g=h(p);if(g)return g;throw new Error(`Non-${e} character`)}return{encode:d,decodeUnsafe:h,decode:f}}var hf=df,ff=hf;const pf=new Uint8Array(0),yf=s=>{const e=s.match(/../g);return e?new Uint8Array(e.map(t=>parseInt(t,16))):pf},wf=(s,e)=>{if(s===e)return!0;if(s.byteLength!==e.byteLength)return!1;for(let t=0;t<s.byteLength;t++)if(s[t]!==e[t])return!1;return!0},ar=s=>{if(s instanceof Uint8Array&&s.constructor.name==="Uint8Array")return s;if(s instanceof ArrayBuffer)return new Uint8Array(s);if(ArrayBuffer.isView(s))return new Uint8Array(s.buffer,s.byteOffset,s.byteLength);throw new Error("Unknown type, must be binary type")},gf=s=>new TextEncoder().encode(s),bf=s=>new TextDecoder().decode(s);let mf=class{constructor(e,t,r){this.name=e,this.prefix=t,this.baseEncode=r}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}},_f=class{constructor(e,t,r){if(this.name=e,this.prefix=t,t.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=r}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return Al(this,e)}},Ef=class{constructor(e){this.decoders=e}or(e){return Al(this,e)}decode(e){const t=e[0],r=this.decoders[t];if(r)return r.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};const Al=(s,e)=>new Ef({...s.decoders||{[s.prefix]:s},...e.decoders||{[e.prefix]:e}});let vf=class{constructor(e,t,r,n){this.name=e,this.prefix=t,this.baseEncode=r,this.baseDecode=n,this.encoder=new mf(e,t,r),this.decoder=new _f(e,t,n)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}};const vn=({name:s,prefix:e,encode:t,decode:r})=>new vf(s,e,t,r),es=({prefix:s,name:e,alphabet:t})=>{const{encode:r,decode:n}=ff(t,e);return vn({prefix:s,name:e,encode:r,decode:a=>ar(n(a))})},Df=(s,e,t,r)=>{const n={};for(let u=0;u<e.length;++u)n[e[u]]=u;let a=s.length;for(;s[a-1]==="=";)--a;const i=new Uint8Array(a*t/8|0);let o=0,c=0,l=0;for(let u=0;u<a;++u){const d=n[s[u]];if(d===void 0)throw new SyntaxError(`Non-${r} character`);c=c<<t|d,o+=t,o>=8&&(o-=8,i[l++]=255&c>>o)}if(o>=t||255&c<<8-o)throw new SyntaxError("Unexpected end of data");return i},Sf=(s,e,t)=>{const r=e[e.length-1]==="=",n=(1<<t)-1;let a="",i=0,o=0;for(let c=0;c<s.length;++c)for(o=o<<8|s[c],i+=8;i>t;)i-=t,a+=e[n&o>>i];if(i&&(a+=e[n&o<<t-i]),r)for(;a.length*t&7;)a+="=";return a},Ee=({name:s,prefix:e,bitsPerChar:t,alphabet:r})=>vn({prefix:e,name:s,encode(n){return Sf(n,r,t)},decode(n){return Df(n,r,t,s)}}),U=es({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),kf=es({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),$f=Object.freeze(Object.defineProperty({__proto__:null,base58btc:U,base58flickr:kf},Symbol.toStringTag,{value:"Module"})),he=Ee({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Pf=Ee({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Af=Ee({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Rf=Ee({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Tf=Ee({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Of=Ee({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),Cf=Ee({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),If=Ee({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Nf=Ee({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),xf=Object.freeze(Object.defineProperty({__proto__:null,base32:he,base32hex:Tf,base32hexpad:Cf,base32hexpadupper:If,base32hexupper:Of,base32pad:Af,base32padupper:Rf,base32upper:Pf,base32z:Nf},Symbol.toStringTag,{value:"Module"})),Lf=Ee({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Bf=Ee({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Dn=Ee({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),jf=Ee({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),Mf=Object.freeze(Object.defineProperty({__proto__:null,base64:Lf,base64pad:Bf,base64url:Dn,base64urlpad:jf},Symbol.toStringTag,{value:"Module"})),Zt=D.Reader,_i=D.Writer,A=D.util,be=D.roots["ipfs-unixfs"]||(D.roots["ipfs-unixfs"]={}),zf=be.Data=(()=>{function s(e){if(this.blocksizes=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return s.prototype.Type=0,s.prototype.Data=A.newBuffer([]),s.prototype.filesize=A.Long?A.Long.fromBits(0,0,!0):0,s.prototype.blocksizes=A.emptyArray,s.prototype.hashType=A.Long?A.Long.fromBits(0,0,!0):0,s.prototype.fanout=A.Long?A.Long.fromBits(0,0,!0):0,s.prototype.mode=0,s.prototype.mtime=null,s.encode=function(t,r){if(r||(r=_i.create()),r.uint32(8).int32(t.Type),t.Data!=null&&Object.hasOwnProperty.call(t,"Data")&&r.uint32(18).bytes(t.Data),t.filesize!=null&&Object.hasOwnProperty.call(t,"filesize")&&r.uint32(24).uint64(t.filesize),t.blocksizes!=null&&t.blocksizes.length)for(var n=0;n<t.blocksizes.length;++n)r.uint32(32).uint64(t.blocksizes[n]);return t.hashType!=null&&Object.hasOwnProperty.call(t,"hashType")&&r.uint32(40).uint64(t.hashType),t.fanout!=null&&Object.hasOwnProperty.call(t,"fanout")&&r.uint32(48).uint64(t.fanout),t.mode!=null&&Object.hasOwnProperty.call(t,"mode")&&r.uint32(56).uint32(t.mode),t.mtime!=null&&Object.hasOwnProperty.call(t,"mtime")&&be.UnixTime.encode(t.mtime,r.uint32(66).fork()).ldelim(),r},s.decode=function(t,r){t instanceof Zt||(t=Zt.create(t));for(var n=r===void 0?t.len:t.pos+r,a=new be.Data;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:a.Type=t.int32();break;case 2:a.Data=t.bytes();break;case 3:a.filesize=t.uint64();break;case 4:if(a.blocksizes&&a.blocksizes.length||(a.blocksizes=[]),(i&7)===2)for(var o=t.uint32()+t.pos;t.pos<o;)a.blocksizes.push(t.uint64());else a.blocksizes.push(t.uint64());break;case 5:a.hashType=t.uint64();break;case 6:a.fanout=t.uint64();break;case 7:a.mode=t.uint32();break;case 8:a.mtime=be.UnixTime.decode(t,t.uint32());break;default:t.skipType(i&7);break}}if(!a.hasOwnProperty("Type"))throw A.ProtocolError("missing required 'Type'",{instance:a});return a},s.fromObject=function(t){if(t instanceof be.Data)return t;var r=new be.Data;switch(t.Type){case"Raw":case 0:r.Type=0;break;case"Directory":case 1:r.Type=1;break;case"File":case 2:r.Type=2;break;case"Metadata":case 3:r.Type=3;break;case"Symlink":case 4:r.Type=4;break;case"HAMTShard":case 5:r.Type=5;break}if(t.Data!=null&&(typeof t.Data=="string"?A.base64.decode(t.Data,r.Data=A.newBuffer(A.base64.length(t.Data)),0):t.Data.length&&(r.Data=t.Data)),t.filesize!=null&&(A.Long?(r.filesize=A.Long.fromValue(t.filesize)).unsigned=!0:typeof t.filesize=="string"?r.filesize=parseInt(t.filesize,10):typeof t.filesize=="number"?r.filesize=t.filesize:typeof t.filesize=="object"&&(r.filesize=new A.LongBits(t.filesize.low>>>0,t.filesize.high>>>0).toNumber(!0))),t.blocksizes){if(!Array.isArray(t.blocksizes))throw TypeError(".Data.blocksizes: array expected");r.blocksizes=[];for(var n=0;n<t.blocksizes.length;++n)A.Long?(r.blocksizes[n]=A.Long.fromValue(t.blocksizes[n])).unsigned=!0:typeof t.blocksizes[n]=="string"?r.blocksizes[n]=parseInt(t.blocksizes[n],10):typeof t.blocksizes[n]=="number"?r.blocksizes[n]=t.blocksizes[n]:typeof t.blocksizes[n]=="object"&&(r.blocksizes[n]=new A.LongBits(t.blocksizes[n].low>>>0,t.blocksizes[n].high>>>0).toNumber(!0))}if(t.hashType!=null&&(A.Long?(r.hashType=A.Long.fromValue(t.hashType)).unsigned=!0:typeof t.hashType=="string"?r.hashType=parseInt(t.hashType,10):typeof t.hashType=="number"?r.hashType=t.hashType:typeof t.hashType=="object"&&(r.hashType=new A.LongBits(t.hashType.low>>>0,t.hashType.high>>>0).toNumber(!0))),t.fanout!=null&&(A.Long?(r.fanout=A.Long.fromValue(t.fanout)).unsigned=!0:typeof t.fanout=="string"?r.fanout=parseInt(t.fanout,10):typeof t.fanout=="number"?r.fanout=t.fanout:typeof t.fanout=="object"&&(r.fanout=new A.LongBits(t.fanout.low>>>0,t.fanout.high>>>0).toNumber(!0))),t.mode!=null&&(r.mode=t.mode>>>0),t.mtime!=null){if(typeof t.mtime!="object")throw TypeError(".Data.mtime: object expected");r.mtime=be.UnixTime.fromObject(t.mtime)}return r},s.toObject=function(t,r){r||(r={});var n={};if((r.arrays||r.defaults)&&(n.blocksizes=[]),r.defaults){if(n.Type=r.enums===String?"Raw":0,r.bytes===String?n.Data="":(n.Data=[],r.bytes!==Array&&(n.Data=A.newBuffer(n.Data))),A.Long){var a=new A.Long(0,0,!0);n.filesize=r.longs===String?a.toString():r.longs===Number?a.toNumber():a}else n.filesize=r.longs===String?"0":0;if(A.Long){var a=new A.Long(0,0,!0);n.hashType=r.longs===String?a.toString():r.longs===Number?a.toNumber():a}else n.hashType=r.longs===String?"0":0;if(A.Long){var a=new A.Long(0,0,!0);n.fanout=r.longs===String?a.toString():r.longs===Number?a.toNumber():a}else n.fanout=r.longs===String?"0":0;n.mode=0,n.mtime=null}if(t.Type!=null&&t.hasOwnProperty("Type")&&(n.Type=r.enums===String?be.Data.DataType[t.Type]:t.Type),t.Data!=null&&t.hasOwnProperty("Data")&&(n.Data=r.bytes===String?A.base64.encode(t.Data,0,t.Data.length):r.bytes===Array?Array.prototype.slice.call(t.Data):t.Data),t.filesize!=null&&t.hasOwnProperty("filesize")&&(typeof t.filesize=="number"?n.filesize=r.longs===String?String(t.filesize):t.filesize:n.filesize=r.longs===String?A.Long.prototype.toString.call(t.filesize):r.longs===Number?new A.LongBits(t.filesize.low>>>0,t.filesize.high>>>0).toNumber(!0):t.filesize),t.blocksizes&&t.blocksizes.length){n.blocksizes=[];for(var i=0;i<t.blocksizes.length;++i)typeof t.blocksizes[i]=="number"?n.blocksizes[i]=r.longs===String?String(t.blocksizes[i]):t.blocksizes[i]:n.blocksizes[i]=r.longs===String?A.Long.prototype.toString.call(t.blocksizes[i]):r.longs===Number?new A.LongBits(t.blocksizes[i].low>>>0,t.blocksizes[i].high>>>0).toNumber(!0):t.blocksizes[i]}return t.hashType!=null&&t.hasOwnProperty("hashType")&&(typeof t.hashType=="number"?n.hashType=r.longs===String?String(t.hashType):t.hashType:n.hashType=r.longs===String?A.Long.prototype.toString.call(t.hashType):r.longs===Number?new A.LongBits(t.hashType.low>>>0,t.hashType.high>>>0).toNumber(!0):t.hashType),t.fanout!=null&&t.hasOwnProperty("fanout")&&(typeof t.fanout=="number"?n.fanout=r.longs===String?String(t.fanout):t.fanout:n.fanout=r.longs===String?A.Long.prototype.toString.call(t.fanout):r.longs===Number?new A.LongBits(t.fanout.low>>>0,t.fanout.high>>>0).toNumber(!0):t.fanout),t.mode!=null&&t.hasOwnProperty("mode")&&(n.mode=t.mode),t.mtime!=null&&t.hasOwnProperty("mtime")&&(n.mtime=be.UnixTime.toObject(t.mtime,r)),n},s.prototype.toJSON=function(){return this.constructor.toObject(this,D.util.toJSONOptions)},s.DataType=function(){const e={},t=Object.create(e);return t[e[0]="Raw"]=0,t[e[1]="Directory"]=1,t[e[2]="File"]=2,t[e[3]="Metadata"]=3,t[e[4]="Symlink"]=4,t[e[5]="HAMTShard"]=5,t}(),s})();be.UnixTime=(()=>{function s(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return s.prototype.Seconds=A.Long?A.Long.fromBits(0,0,!1):0,s.prototype.FractionalNanoseconds=0,s.encode=function(t,r){return r||(r=_i.create()),r.uint32(8).int64(t.Seconds),t.FractionalNanoseconds!=null&&Object.hasOwnProperty.call(t,"FractionalNanoseconds")&&r.uint32(21).fixed32(t.FractionalNanoseconds),r},s.decode=function(t,r){t instanceof Zt||(t=Zt.create(t));for(var n=r===void 0?t.len:t.pos+r,a=new be.UnixTime;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:a.Seconds=t.int64();break;case 2:a.FractionalNanoseconds=t.fixed32();break;default:t.skipType(i&7);break}}if(!a.hasOwnProperty("Seconds"))throw A.ProtocolError("missing required 'Seconds'",{instance:a});return a},s.fromObject=function(t){if(t instanceof be.UnixTime)return t;var r=new be.UnixTime;return t.Seconds!=null&&(A.Long?(r.Seconds=A.Long.fromValue(t.Seconds)).unsigned=!1:typeof t.Seconds=="string"?r.Seconds=parseInt(t.Seconds,10):typeof t.Seconds=="number"?r.Seconds=t.Seconds:typeof t.Seconds=="object"&&(r.Seconds=new A.LongBits(t.Seconds.low>>>0,t.Seconds.high>>>0).toNumber())),t.FractionalNanoseconds!=null&&(r.FractionalNanoseconds=t.FractionalNanoseconds>>>0),r},s.toObject=function(t,r){r||(r={});var n={};if(r.defaults){if(A.Long){var a=new A.Long(0,0,!1);n.Seconds=r.longs===String?a.toString():r.longs===Number?a.toNumber():a}else n.Seconds=r.longs===String?"0":0;n.FractionalNanoseconds=0}return t.Seconds!=null&&t.hasOwnProperty("Seconds")&&(typeof t.Seconds=="number"?n.Seconds=r.longs===String?String(t.Seconds):t.Seconds:n.Seconds=r.longs===String?A.Long.prototype.toString.call(t.Seconds):r.longs===Number?new A.LongBits(t.Seconds.low>>>0,t.Seconds.high>>>0).toNumber():t.Seconds),t.FractionalNanoseconds!=null&&t.hasOwnProperty("FractionalNanoseconds")&&(n.FractionalNanoseconds=t.FractionalNanoseconds),n},s.prototype.toJSON=function(){return this.constructor.toObject(this,D.util.toJSONOptions)},s})();be.Metadata=(()=>{function s(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return s.prototype.MimeType="",s.encode=function(t,r){return r||(r=_i.create()),t.MimeType!=null&&Object.hasOwnProperty.call(t,"MimeType")&&r.uint32(10).string(t.MimeType),r},s.decode=function(t,r){t instanceof Zt||(t=Zt.create(t));for(var n=r===void 0?t.len:t.pos+r,a=new be.Metadata;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:a.MimeType=t.string();break;default:t.skipType(i&7);break}}return a},s.fromObject=function(t){if(t instanceof be.Metadata)return t;var r=new be.Metadata;return t.MimeType!=null&&(r.MimeType=String(t.MimeType)),r},s.toObject=function(t,r){r||(r={});var n={};return r.defaults&&(n.MimeType=""),t.MimeType!=null&&t.hasOwnProperty("MimeType")&&(n.MimeType=t.MimeType),n},s.prototype.toJSON=function(){return this.constructor.toObject(this,D.util.toJSONOptions)},s})();const rt=zf,go=["raw","directory","file","metadata","symlink","hamt-sharded-directory"],Uf=["directory","hamt-sharded-directory"],bo=parseInt("0644",8),mo=parseInt("0755",8);function Wt(s){if(s!=null)return typeof s=="number"?s&4095:(s=s.toString(),s.substring(0,1)==="0"?parseInt(s,8)&4095:parseInt(s,10)&4095)}function Ur(s){if(s==null)return;let e;if(s.secs!=null&&(e={secs:s.secs,nsecs:s.nsecs}),s.Seconds!=null&&(e={secs:s.Seconds,nsecs:s.FractionalNanoseconds}),Array.isArray(s)&&(e={secs:s[0],nsecs:s[1]}),s instanceof Date){const t=s.getTime(),r=Math.floor(t/1e3);e={secs:r,nsecs:(t-r*1e3)*1e3}}if(Object.prototype.hasOwnProperty.call(e,"secs")){if(e!=null&&e.nsecs!=null&&(e.nsecs<0||e.nsecs>999999999))throw y(new Error("mtime-nsecs must be within the range [0,999999999]"),"ERR_INVALID_MTIME_NSECS");return e}}class G{static unmarshal(e){const t=rt.decode(e),r=rt.toObject(t,{defaults:!1,arrays:!0,longs:Number,objects:!1}),n=new G({type:go[r.Type],data:r.Data,blockSizes:r.blocksizes,mode:r.mode,mtime:r.mtime?{secs:r.mtime.Seconds,nsecs:r.mtime.FractionalNanoseconds}:void 0});return n._originalMode=r.mode||0,n}constructor(e={type:"file"}){const{type:t,data:r,blockSizes:n,hashType:a,fanout:i,mtime:o,mode:c}=e;if(t&&!go.includes(t))throw y(new Error("Type: "+t+" is not valid"),"ERR_INVALID_TYPE");this.type=t||"file",this.data=r,this.hashType=a,this.fanout=i,this.blockSizes=n||[],this._originalMode=0,this.mode=Wt(c),o&&(this.mtime=Ur(o),this.mtime&&!this.mtime.nsecs&&(this.mtime.nsecs=0))}set mode(e){this._mode=this.isDirectory()?mo:bo;const t=Wt(e);t!==void 0&&(this._mode=t)}get mode(){return this._mode}isDirectory(){return!!(this.type&&Uf.includes(this.type))}addBlockSize(e){this.blockSizes.push(e)}removeBlockSize(e){this.blockSizes.splice(e,1)}fileSize(){if(this.isDirectory())return 0;let e=0;return this.blockSizes.forEach(t=>{e+=t}),this.data&&(e+=this.data.length),e}marshal(){let e;switch(this.type){case"raw":e=rt.DataType.Raw;break;case"directory":e=rt.DataType.Directory;break;case"file":e=rt.DataType.File;break;case"metadata":e=rt.DataType.Metadata;break;case"symlink":e=rt.DataType.Symlink;break;case"hamt-sharded-directory":e=rt.DataType.HAMTShard;break;default:throw y(new Error("Type: "+e+" is not valid"),"ERR_INVALID_TYPE")}let t=this.data;(!this.data||!this.data.length)&&(t=void 0);let r;this.mode!=null&&(r=this._originalMode&4294963200|(Wt(this.mode)||0),r===bo&&!this.isDirectory()&&(r=void 0),r===mo&&this.isDirectory()&&(r=void 0));let n;if(this.mtime!=null){const i=Ur(this.mtime);i&&(n={Seconds:i.secs,FractionalNanoseconds:i.nsecs},n.FractionalNanoseconds===0&&delete n.FractionalNanoseconds)}const a={Type:e,Data:t,filesize:this.isDirectory()?void 0:this.fileSize(),blocksizes:this.blockSizes,hashType:this.hashType,fanout:this.fanout,mode:r,mtime:n};return rt.encode(a).finish()}}var Ff=Rl,_o=128,Hf=127,qf=~Hf,Kf=Math.pow(2,31);function Rl(s,e,t){e=e||[],t=t||0;for(var r=t;s>=Kf;)e[t++]=s&255|_o,s/=128;for(;s&qf;)e[t++]=s&255|_o,s>>>=7;return e[t]=s|0,Rl.bytes=t-r+1,e}var Vf=$a,Wf=128,Eo=127;function $a(s,r){var t=0,r=r||0,n=0,a=r,i,o=s.length;do{if(a>=o)throw $a.bytes=0,new RangeError("Could not decode varint");i=s[a++],t+=n<28?(i&Eo)<<n:(i&Eo)*Math.pow(2,n),n+=7}while(i>=Wf);return $a.bytes=a-r,t}var Jf=Math.pow(2,7),Gf=Math.pow(2,14),Qf=Math.pow(2,21),Xf=Math.pow(2,28),Yf=Math.pow(2,35),Zf=Math.pow(2,42),ep=Math.pow(2,49),tp=Math.pow(2,56),rp=Math.pow(2,63),sp=function(s){return s<Jf?1:s<Gf?2:s<Qf?3:s<Xf?4:s<Yf?5:s<Zf?6:s<ep?7:s<tp?8:s<rp?9:10},np={encode:Ff,decode:Vf,encodingLength:sp},Vs=np;const Pa=(s,e=0)=>[Vs.decode(s,e),Vs.decode.bytes],Ws=(s,e,t=0)=>(Vs.encode(s,e,t),e),Js=s=>Vs.encodingLength(s),Gs=(s,e)=>{const t=e.byteLength,r=Js(s),n=r+Js(t),a=new Uint8Array(n+t);return Ws(s,a,0),Ws(t,a,r),a.set(e,n),new Ei(s,t,e,a)},Et=s=>{const e=ar(s),[t,r]=Pa(e),[n,a]=Pa(e.subarray(r)),i=e.subarray(r+a);if(i.byteLength!==n)throw new Error("Incorrect length");return new Ei(t,n,i,e)},ap=(s,e)=>{if(s===e)return!0;{const t=e;return s.code===t.code&&s.size===t.size&&t.bytes instanceof Uint8Array&&wf(s.bytes,t.bytes)}};let Ei=class{constructor(e,t,r,n){this.code=e,this.size=t,this.digest=r,this.bytes=n}};const vo=(s,e)=>{const{bytes:t,version:r}=s;switch(r){case 0:return op(t,Aa(s),e||U.encoder);default:return cp(t,Aa(s),e||he.encoder)}},Do=new WeakMap,Aa=s=>{const e=Do.get(s);if(e==null){const t=new Map;return Do.set(s,t),t}return e};let w=class ke{constructor(e,t,r,n){this.code=t,this.version=e,this.multihash=r,this.bytes=n,this["/"]=n}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:e,multihash:t}=this;if(e!==pr)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==lp)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return ke.createV0(t)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,r=Gs(e,t);return ke.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(e){return ke.equals(this,e)}static equals(e,t){const r=t;return r&&e.code===r.code&&e.version===r.version&&ap(e.multihash,r.multihash)}toString(e){return vo(this,e)}toJSON(){return{"/":vo(this)}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(e){if(e==null)return null;const t=e;if(t instanceof ke)return t;if(t["/"]!=null&&t["/"]===t.bytes||t.asCID===t){const{version:r,code:n,multihash:a,bytes:i}=t;return new ke(r,n,a,i||So(r,n,a.bytes))}else if(t[up]===!0){const{version:r,multihash:n,code:a}=t,i=Et(n);return ke.create(r,a,i)}else return null}static create(e,t,r){if(typeof t!="number")throw new Error("String codecs are no longer supported");if(!(r.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(e){case 0:{if(t!==pr)throw new Error(`Version 0 CID must use dag-pb (code: ${pr}) block encoding`);return new ke(e,t,r,r.bytes)}case 1:{const n=So(e,t,r.bytes);return new ke(e,t,r,n)}default:throw new Error("Invalid version")}}static createV0(e){return ke.create(0,pr,e)}static createV1(e,t){return ke.create(1,e,t)}static decode(e){const[t,r]=ke.decodeFirst(e);if(r.length)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=ke.inspectBytes(e),r=t.size-t.multihashSize,n=ar(e.subarray(r,r+t.multihashSize));if(n.byteLength!==t.multihashSize)throw new Error("Incorrect length");const a=n.subarray(t.multihashSize-t.digestSize),i=new Ei(t.multihashCode,t.digestSize,a,n);return[t.version===0?ke.createV0(i):ke.createV1(t.codec,i),e.subarray(t.size)]}static inspectBytes(e){let t=0;const r=()=>{const[d,h]=Pa(e.subarray(t));return t+=h,d};let n=r(),a=pr;if(n===18?(n=0,t=0):a=r(),n!==0&&n!==1)throw new RangeError(`Invalid CID version ${n}`);const i=t,o=r(),c=r(),l=t+c,u=l-i;return{version:n,codec:a,multihashCode:o,digestSize:c,multihashSize:u,size:l}}static parse(e,t){const[r,n]=ip(e,t),a=ke.decode(n);if(a.version===0&&e[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return Aa(a).set(r,e),a}};const ip=(s,e)=>{switch(s[0]){case"Q":{const t=e||U;return[U.prefix,t.decode(`${U.prefix}${s}`)]}case U.prefix:{const t=e||U;return[U.prefix,t.decode(s)]}case he.prefix:{const t=e||he;return[he.prefix,t.decode(s)]}default:{if(e==null)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[s[0],e.decode(s)]}}},op=(s,e,t)=>{const{prefix:r}=t;if(r!==U.prefix)throw Error(`Cannot string encode V0 in ${t.name} encoding`);const n=e.get(r);if(n==null){const a=t.encode(s).slice(1);return e.set(r,a),a}else return n},cp=(s,e,t)=>{const{prefix:r}=t,n=e.get(r);if(n==null){const a=t.encode(s);return e.set(r,a),a}else return n},pr=112,lp=18,So=(s,e,t)=>{const r=Js(s),n=r+Js(e),a=new Uint8Array(n+t.byteLength);return Ws(s,a,0),Ws(e,a,r),a.set(t,n),a},up=Symbol.for("@ipld/js-cid/CID"),vi=({name:s,code:e,encode:t})=>new dp(s,e,t);let dp=class{constructor(e,t,r){this.name=e,this.code=t,this.encode=r}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?Gs(this.code,t):t.then(r=>Gs(this.code,r))}else throw Error("Unknown type, must be binary type")}};const Tl=0,hp="identity",Ol=ar,fp=s=>Gs(Tl,Ol(s)),Rt={code:Tl,name:hp,encode:Ol,digest:fp},pp=Object.freeze(Object.defineProperty({__proto__:null,identity:Rt},Symbol.toStringTag,{value:"Module"})),yp=vn({prefix:"\0",name:"identity",encode:s=>bf(s),decode:s=>gf(s)}),wp=Object.freeze(Object.defineProperty({__proto__:null,identity:yp},Symbol.toStringTag,{value:"Module"})),gp=Ee({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),bp=Object.freeze(Object.defineProperty({__proto__:null,base2:gp},Symbol.toStringTag,{value:"Module"})),mp=Ee({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),_p=Object.freeze(Object.defineProperty({__proto__:null,base8:mp},Symbol.toStringTag,{value:"Module"})),Ep=es({prefix:"9",name:"base10",alphabet:"0123456789"}),vp=Object.freeze(Object.defineProperty({__proto__:null,base10:Ep},Symbol.toStringTag,{value:"Module"})),Dp=Ee({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),Sp=Ee({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),kp=Object.freeze(Object.defineProperty({__proto__:null,base16:Dp,base16upper:Sp},Symbol.toStringTag,{value:"Module"})),Qs=es({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),$p=es({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),Pp=Object.freeze(Object.defineProperty({__proto__:null,base36:Qs,base36upper:$p},Symbol.toStringTag,{value:"Module"})),Cl=Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),Ap=Cl.reduce((s,e,t)=>(s[t]=e,s),[]),Rp=Cl.reduce((s,e,t)=>(s[e.codePointAt(0)]=t,s),[]);function Tp(s){return s.reduce((e,t)=>(e+=Ap[t],e),"")}function Op(s){const e=[];for(const t of s){const r=Rp[t.codePointAt(0)];if(r===void 0)throw new Error(`Non-base256emoji character: ${t}`);e.push(r)}return new Uint8Array(e)}const Cp=vn({prefix:"🚀",name:"base256emoji",encode:Tp,decode:Op}),Ip=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:Cp},Symbol.toStringTag,{value:"Module"})),Il=s=>async e=>new Uint8Array(await crypto.subtle.digest(s,e)),me=vi({name:"sha2-256",code:18,encode:Il("SHA-256")}),Np=vi({name:"sha2-512",code:19,encode:Il("SHA-512")}),xp=Object.freeze(Object.defineProperty({__proto__:null,sha256:me,sha512:Np},Symbol.toStringTag,{value:"Module"})),Lp="raw",bt=85,Bp=s=>ar(s),jp=s=>ar(s),Nl=Object.freeze(Object.defineProperty({__proto__:null,code:bt,decode:jp,encode:Bp,name:Lp},Symbol.toStringTag,{value:"Module"})),Mp=new TextEncoder,zp=new TextDecoder,Up="json",xl=512,Fp=s=>Mp.encode(JSON.stringify(s)),Hp=s=>JSON.parse(zp.decode(s)),qp=Object.freeze(Object.defineProperty({__proto__:null,code:xl,decode:Hp,encode:Fp,name:Up},Symbol.toStringTag,{value:"Module"})),Sn={...wp,...bp,..._p,...vp,...kp,...xf,...Pp,...$f,...Mf,...Ip},Ll={...xp,...pp},Bl={raw:Nl,json:qp};class ts extends Error{constructor(e="not initialized"){super(e),this.name="NotInitializedError",this.code=ts.code}}ts.code="ERR_NOT_INITIALIZED";class Kp extends Error{constructor(e="cannot initialize an initializing node"){super(e),this.name="AlreadyInitializingError",this.code=Tt.code}}Kp.code="ERR_ALREADY_INITIALIZING";class Tt extends Error{constructor(e="cannot re-initialize an initialized node"){super(e),this.name="AlreadyInitializedError",this.code=Tt.code}}Tt.code="ERR_ALREADY_INITIALIZED";class rs extends Error{constructor(e="not started"){super(e),this.name="NotStartedError",this.code=rs.code}}rs.code="ERR_NOT_STARTED";class kn extends Error{constructor(e="cannot start, already startin"){super(e),this.name="AlreadyStartingError",this.code=kn.code}}kn.code="ERR_ALREADY_STARTING";class $n extends Error{constructor(e="cannot start, already started"){super(e),this.name="AlreadyStartedError",this.code=$n.code}}$n.code="ERR_ALREADY_STARTED";class ir extends Error{constructor(e="not enabled"){super(e),this.name="NotEnabledError",this.code=ir.code}}ir.code="ERR_NOT_ENABLED";const ko=ul,Vp=dl,jl=function(s){let e=0;if(s=s.toString().trim(),ko(s)){const t=new Uint8Array(e+4);return s.split(/\./g).forEach(r=>{t[e++]=parseInt(r,10)&255}),t}if(Vp(s)){const t=s.split(":",8);let r;for(r=0;r<t.length;r++){const a=ko(t[r]);let i;a&&(i=jl(t[r]),t[r]=R(i.slice(0,2),"base16")),i!=null&&++r<8&&t.splice(r,0,R(i.slice(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(r=0;r<t.length&&t[r]!=="";r++);const a=[r,1];for(r=9-t.length;r>0;r--)a.push("0");t.splice.apply(t,a)}const n=new Uint8Array(e+16);for(r=0;r<t.length;r++){const a=parseInt(t[r],16);n[e++]=a>>8&255,n[e++]=a&255}return n}throw new Error("invalid ip address")},Wp=function(s,e=0,t){e=~~e,t=t??s.length-e;const r=new DataView(s.buffer);if(t===4){const n=[];for(let a=0;a<t;a++)n.push(s[e+a]);return n.join(".")}if(t===16){const n=[];for(let a=0;a<t;a+=2)n.push(r.getUint16(e+a).toString(16));return n.join(":").replace(/(^|:)0(:0)*:0(:|$)/,"$1::$3").replace(/:{3,4}/,"::")}return""},xe=-1,Xs={},Ra={},Jp=[[4,32,"ip4"],[6,16,"tcp"],[33,16,"dccp"],[41,128,"ip6"],[42,xe,"ip6zone"],[43,8,"ipcidr"],[53,xe,"dns",!0],[54,xe,"dns4",!0],[55,xe,"dns6",!0],[56,xe,"dnsaddr",!0],[132,16,"sctp"],[273,16,"udp"],[275,0,"p2p-webrtc-star"],[276,0,"p2p-webrtc-direct"],[277,0,"p2p-stardust"],[280,0,"webrtc"],[281,0,"webrtc-w3c"],[290,0,"p2p-circuit"],[301,0,"udt"],[302,0,"utp"],[400,xe,"unix",!1,!0],[421,xe,"ipfs"],[421,xe,"p2p"],[443,0,"https"],[444,96,"onion"],[445,296,"onion3"],[446,xe,"garlic64"],[448,0,"tls"],[449,xe,"sni"],[460,0,"quic"],[461,0,"quic-v1"],[465,0,"webtransport"],[466,xe,"certhash"],[477,0,"ws"],[478,0,"wss"],[479,0,"p2p-websocket-star"],[480,0,"http"],[777,xe,"memory"]];Jp.forEach(s=>{const e=Gp(...s);Ra[e.code]=e,Xs[e.name]=e});function Gp(s,e,t,r,n){return{code:s,size:e,name:t,resolvable:!!r,path:!!n}}function ne(s){if(typeof s=="number"){if(Ra[s]!=null)return Ra[s];throw new Error(`no protocol with code: ${s}`)}else if(typeof s=="string"){if(Xs[s]!=null)return Xs[s];throw new Error(`no protocol with name: ${s}`)}throw new Error(`invalid protocol id type: ${typeof s}`)}function Qp(s,e){switch(ne(s).code){case 4:case 41:return Zp(e);case 42:return Ao(e);case 6:case 273:case 33:case 132:return Ml(e).toString();case 53:case 54:case 55:case 56:case 400:case 449:case 777:return Ao(e);case 421:return sy(e);case 444:return Ro(e);case 445:return Ro(e);case 466:return ry(e);default:return R(e,"base16")}}function Xp(s,e){switch(ne(s).code){case 4:return $o(e);case 41:return $o(e);case 42:return Po(e);case 6:case 273:case 33:case 132:return Di(parseInt(e,10));case 53:case 54:case 55:case 56:case 400:case 449:case 777:return Po(e);case 421:return ey(e);case 444:return ny(e);case 445:return ay(e);case 466:return ty(e);default:return Q(e,"base16")}}const Qn=Object.values(Sn).map(s=>s.decoder),Yp=function(){let s=Qn[0].or(Qn[1]);return Qn.slice(2).forEach(e=>s=s.or(e)),s}();function $o(s){if(!hn(s))throw new Error("invalid ip address");return jl(s)}function Zp(s){const e=Wp(s,0,s.length);if(e==null)throw new Error("ipBuff is required");if(!hn(e))throw new Error("invalid ip address");return e}function Di(s){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,s),new Uint8Array(e)}function Ml(s){return new DataView(s.buffer).getUint16(s.byteOffset)}function Po(s){const e=Q(s),t=Uint8Array.from(j.encode(e.length));return oe([t,e],t.length+e.length)}function Ao(s){const e=j.decode(s);if(s=s.slice(j.decode.bytes),s.length!==e)throw new Error("inconsistent lengths");return R(s)}function ey(s){let e;s[0]==="Q"||s[0]==="1"?e=Et(U.decode(`z${s}`)).bytes:e=w.parse(s).multihash.bytes;const t=Uint8Array.from(j.encode(e.length));return oe([t,e],t.length+e.length)}function ty(s){const e=Yp.decode(s),t=Uint8Array.from(j.encode(e.length));return oe([t,e],t.length+e.length)}function ry(s){const e=j.decode(s),t=s.slice(j.decode.bytes);if(t.length!==e)throw new Error("inconsistent lengths");return"u"+R(t,"base64url")}function sy(s){const e=j.decode(s),t=s.slice(j.decode.bytes);if(t.length!==e)throw new Error("inconsistent lengths");return R(t,"base58btc")}function ny(s){const e=s.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=he.decode("b"+e[0]),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const n=Di(r);return oe([t,n],t.length+n.length)}function ay(s){const e=s.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=he.decode(`b${e[0]}`),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const n=Di(r);return oe([t,n],t.length+n.length)}function Ro(s){const e=s.slice(0,s.length-2),t=s.slice(s.length-2),r=R(e,"base32"),n=Ml(t);return`${r}:${n}`}function iy(s){const e=[],t=s.split("/").slice(1);if(t.length===1&&t[0]==="")return[];for(let r=0;r<t.length;r++){const n=t[r],a=ne(n);if(a.size===0){e.push([n]);continue}if(r++,r>=t.length)throw Hl("invalid address: "+s);if(a.path===!0){e.push([n,ki(t.slice(r).join("/"))]);break}e.push([n,t[r]])}return e}function oy(s){const e=[];return s.map(t=>{const r=Pn(t);return e.push(r.name),t.length>1&&t[1]!=null&&e.push(t[1]),null}),ki(e.join("/"))}function cy(s){return s.map(e=>{Array.isArray(e)||(e=[e]);const t=Pn(e);return e.length>1?[t.code,Xp(t.code,e[1])]:[t.code]})}function zl(s){return s.map(e=>{const t=Pn(e);return e[1]!=null?[t.code,Qp(t.code,e[1])]:[t.code]})}function Ul(s){return Ta(oe(s.map(e=>{const t=Pn(e);let r=Uint8Array.from(j.encode(t.code));return e.length>1&&e[1]!=null&&(r=oe([r,e[1]])),r})))}function Fl(s,e){return s.size>0?s.size/8:s.size===0?0:j.decode(e)+(j.decode.bytes??0)}function Si(s){const e=[];let t=0;for(;t<s.length;){const r=j.decode(s,t),n=j.decode.bytes??0,a=ne(r),i=Fl(a,s.slice(t+n));if(i===0){e.push([r]),t+=n;continue}const o=s.slice(t+n,t+n+i);if(t+=i+n,t>s.length)throw Hl("Invalid address Uint8Array: "+R(s,"base16"));e.push([r,o])}return e}function To(s){const e=Si(s),t=zl(e);return oy(t)}function ly(s){s=ki(s);const e=iy(s),t=cy(e);return Ul(t)}function uy(s){return ly(s)}function Ta(s){const e=dy(s);if(e!=null)throw e;return Uint8Array.from(s)}function dy(s){try{Si(s)}catch(e){return e}}function ki(s){return"/"+s.trim().split("/").filter(e=>e).join("/")}function Hl(s){return new Error("Error parsing address: "+s)}function Pn(s){return ne(s[0])}var jt=globalThis&&globalThis.__classPrivateFieldGet||function(s,e,t,r){if(t==="a"&&!r)throw new TypeError("Private accessor was defined without a getter");if(typeof e=="function"?s!==e||!r:!e.has(s))throw new TypeError("Cannot read private member from an object whose class did not declare it");return t==="m"?r:t==="a"?r.call(s):r?r.value:e.get(s)},Xn=globalThis&&globalThis.__classPrivateFieldSet||function(s,e,t,r,n){if(r==="m")throw new TypeError("Private method is not writable");if(r==="a"&&!n)throw new TypeError("Private accessor was defined without a setter");if(typeof e=="function"?s!==e||!n:!e.has(s))throw new TypeError("Cannot write private member to an object whose class did not declare it");return r==="a"?n.call(s,t):n?n.value=t:e.set(s,t),t},yr,wr,gr,Oo;const hy=Symbol.for("nodejs.util.inspect.custom"),fy=[ne("dns").code,ne("dns4").code,ne("dns6").code,ne("dnsaddr").code],py=new Map,ql=Symbol.for("@multiformats/js-multiaddr/multiaddr");function VA(s,e){if(s==null)throw new Error("requires node address object");if(e==null)throw new Error("requires transport protocol");let t,r=s.address;switch(s.family){case 4:t="ip4";break;case 6:if(t="ip6",r.includes("%")){const n=r.split("%");if(n.length!==2)throw Error("Multiple ip6 zones in multiaddr");r=n[0],t=`/ip6zone/${n[1]}/ip6`}break;default:throw Error("Invalid addr family, should be 4 or 6.")}return new Kl("/"+[t,r,e,s.port].join("/"))}function WA(s){return Ys(s)?s.protos().some(e=>e.resolvable):!1}function Ys(s){return!!s?.[ql]}let Kl=class Ht{constructor(e){if(yr.set(this,void 0),wr.set(this,void 0),gr.set(this,void 0),this[Oo]=!0,e==null&&(e=""),e instanceof Uint8Array)this.bytes=Ta(e);else if(typeof e=="string"){if(e.length>0&&e.charAt(0)!=="/")throw new Error(`multiaddr "${e}" must start with a "/"`);this.bytes=uy(e)}else if(Ys(e))this.bytes=Ta(e.bytes);else throw new Error("addr must be a string, Buffer, or another Multiaddr")}toString(){return jt(this,yr,"f")==null&&Xn(this,yr,To(this.bytes),"f"),jt(this,yr,"f")}toJSON(){return this.toString()}toOptions(){let e,t,r,n,a="";const i=ne("tcp"),o=ne("udp"),c=ne("ip4"),l=ne("ip6"),u=ne("dns6"),d=ne("ip6zone");for(const[f,p]of this.stringTuples())f===d.code&&(a=`%${p??""}`),fy.includes(f)&&(t=i.name,n=443,r=`${p??""}${a}`,e=f===u.code?6:4),(f===i.code||f===o.code)&&(t=ne(f).name,n=parseInt(p??"")),(f===c.code||f===l.code)&&(t=ne(f).name,r=`${p??""}${a}`,e=f===l.code?6:4);if(e==null||t==null||r==null||n==null)throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');return{family:e,host:r,transport:t,port:n}}protos(){return this.protoCodes().map(e=>Object.assign({},ne(e)))}protoCodes(){const e=[],t=this.bytes;let r=0;for(;r<t.length;){const n=j.decode(t,r),a=j.decode.bytes??0,i=ne(n),o=Fl(i,t.slice(r+a));r+=o+a,e.push(n)}return e}protoNames(){return this.protos().map(e=>e.name)}tuples(){return jt(this,wr,"f")==null&&Xn(this,wr,Si(this.bytes),"f"),jt(this,wr,"f")}stringTuples(){return jt(this,gr,"f")==null&&Xn(this,gr,zl(this.tuples()),"f"),jt(this,gr,"f")}encapsulate(e){return e=new Ht(e),new Ht(this.toString()+e.toString())}decapsulate(e){const t=e.toString(),r=this.toString(),n=r.lastIndexOf(t);if(n<0)throw new Error(`Address ${this.toString()} does not contain subaddress: ${e.toString()}`);return new Ht(r.slice(0,n))}decapsulateCode(e){const t=this.tuples();for(let r=t.length-1;r>=0;r--)if(t[r][0]===e)return new Ht(Ul(t.slice(0,r)));return this}getPeerId(){try{const t=this.stringTuples().filter(r=>r[0]===Xs.ipfs.code).pop();if(t?.[1]!=null){const r=t[1];return r[0]==="Q"||r[0]==="1"?R(U.decode(`z${r}`),"base58btc"):R(w.parse(r).multihash.bytes,"base58btc")}return null}catch{return null}}getPath(){let e=null;try{e=this.stringTuples().filter(t=>ne(t[0]).path===!0)[0][1],e==null&&(e=null)}catch{e=null}return e}equals(e){return fn(this.bytes,e.bytes)}async resolve(e){const t=this.protos().find(a=>a.resolvable);if(t==null)return[this];const r=py.get(t.name);if(r==null)throw y(new Error(`no available resolver for ${t.name}`),"ERR_NO_AVAILABLE_RESOLVER");return(await r(this,e)).map(a=>new Ht(a))}nodeAddress(){const e=this.toOptions();if(e.transport!=="tcp"&&e.transport!=="udp")throw new Error(`multiaddr must have a valid format - no protocol with name: "${e.transport}". Must have a valid transport protocol: "{tcp, udp}"`);return{family:e.family,address:e.host,port:e.port}}isThinWaistAddress(e){const t=(e??this).protos();return!(t.length!==2||t[0].code!==4&&t[0].code!==41||t[1].code!==6&&t[1].code!==273)}[(yr=new WeakMap,wr=new WeakMap,gr=new WeakMap,Oo=ql,hy)](){return`Multiaddr(${To(this.bytes)})`}};function ie(s){return new Kl(s)}const Co=ul,yy=dl,Vl=function(s){let e=0;if(s=s.toString().trim(),Co(s)){const t=new Uint8Array(e+4);return s.split(/\./g).forEach(r=>{t[e++]=parseInt(r,10)&255}),t}if(yy(s)){const t=s.split(":",8);let r;for(r=0;r<t.length;r++){const a=Co(t[r]);let i;a&&(i=Vl(t[r]),t[r]=R(i.slice(0,2),"base16")),i!=null&&++r<8&&t.splice(r,0,R(i.slice(2,4),"base16"))}if(t[0]==="")for(;t.length<8;)t.unshift("0");else if(t[t.length-1]==="")for(;t.length<8;)t.push("0");else if(t.length<8){for(r=0;r<t.length&&t[r]!=="";r++);const a=[r,1];for(r=9-t.length;r>0;r--)a.push("0");t.splice.apply(t,a)}const n=new Uint8Array(e+16);for(r=0;r<t.length;r++){const a=parseInt(t[r],16);n[e++]=a>>8&255,n[e++]=a&255}return n}throw new Error("invalid ip address")},wy=function(s,e=0,t){e=~~e,t=t??s.length-e;const r=new DataView(s.buffer);if(t===4){const n=[];for(let a=0;a<t;a++)n.push(s[e+a]);return n.join(".")}if(t===16){const n=[];for(let a=0;a<t;a+=2)n.push(r.getUint16(e+a).toString(16));return n.join(":").replace(/(^|:)0(:0)*:0(:|$)/,"$1::$3").replace(/:{3,4}/,"::")}return""},Le=-1,Zs={},Oa={},gy=[[4,32,"ip4"],[6,16,"tcp"],[33,16,"dccp"],[41,128,"ip6"],[42,Le,"ip6zone"],[43,8,"ipcidr"],[53,Le,"dns",!0],[54,Le,"dns4",!0],[55,Le,"dns6",!0],[56,Le,"dnsaddr",!0],[132,16,"sctp"],[273,16,"udp"],[275,0,"p2p-webrtc-star"],[276,0,"p2p-webrtc-direct"],[277,0,"p2p-stardust"],[280,0,"webrtc-direct"],[281,0,"webrtc"],[290,0,"p2p-circuit"],[301,0,"udt"],[302,0,"utp"],[400,Le,"unix",!1,!0],[421,Le,"ipfs"],[421,Le,"p2p"],[443,0,"https"],[444,96,"onion"],[445,296,"onion3"],[446,Le,"garlic64"],[448,0,"tls"],[449,Le,"sni"],[460,0,"quic"],[461,0,"quic-v1"],[465,0,"webtransport"],[466,Le,"certhash"],[477,0,"ws"],[478,0,"wss"],[479,0,"p2p-websocket-star"],[480,0,"http"],[777,Le,"memory"]];gy.forEach(s=>{const e=by(...s);Oa[e.code]=e,Zs[e.name]=e});function by(s,e,t,r,n){return{code:s,size:e,name:t,resolvable:!!r,path:!!n}}function ee(s){if(typeof s=="number"){if(Oa[s]!=null)return Oa[s];throw new Error(`no protocol with code: ${s}`)}else if(typeof s=="string"){if(Zs[s]!=null)return Zs[s];throw new Error(`no protocol with name: ${s}`)}throw new Error(`invalid protocol id type: ${typeof s}`)}ee("ip4");ee("ip6");ee("ipcidr");function my(s,e){switch(ee(s).code){case 4:case 41:return vy(e);case 42:return xo(e);case 6:case 273:case 33:case 132:return Wl(e).toString();case 53:case 54:case 55:case 56:case 400:case 449:case 777:return xo(e);case 421:return $y(e);case 444:return Lo(e);case 445:return Lo(e);case 466:return ky(e);default:return R(e,"base16")}}function _y(s,e){switch(ee(s).code){case 4:return Io(e);case 41:return Io(e);case 42:return No(e);case 6:case 273:case 33:case 132:return $i(parseInt(e,10));case 53:case 54:case 55:case 56:case 400:case 449:case 777:return No(e);case 421:return Dy(e);case 444:return Py(e);case 445:return Ay(e);case 466:return Sy(e);default:return Q(e,"base16")}}const Yn=Object.values(Sn).map(s=>s.decoder),Ey=function(){let s=Yn[0].or(Yn[1]);return Yn.slice(2).forEach(e=>s=s.or(e)),s}();function Io(s){if(!hn(s))throw new Error("invalid ip address");return Vl(s)}function vy(s){const e=wy(s,0,s.length);if(e==null)throw new Error("ipBuff is required");if(!hn(e))throw new Error("invalid ip address");return e}function $i(s){const e=new ArrayBuffer(2);return new DataView(e).setUint16(0,s),new Uint8Array(e)}function Wl(s){return new DataView(s.buffer).getUint16(s.byteOffset)}function No(s){const e=Q(s),t=Uint8Array.from(j.encode(e.length));return oe([t,e],t.length+e.length)}function xo(s){const e=j.decode(s);if(s=s.slice(j.decode.bytes),s.length!==e)throw new Error("inconsistent lengths");return R(s)}function Dy(s){let e;s[0]==="Q"||s[0]==="1"?e=Et(U.decode(`z${s}`)).bytes:e=w.parse(s).multihash.bytes;const t=Uint8Array.from(j.encode(e.length));return oe([t,e],t.length+e.length)}function Sy(s){const e=Ey.decode(s),t=Uint8Array.from(j.encode(e.length));return oe([t,e],t.length+e.length)}function ky(s){const e=j.decode(s),t=s.slice(j.decode.bytes);if(t.length!==e)throw new Error("inconsistent lengths");return"u"+R(t,"base64url")}function $y(s){const e=j.decode(s),t=s.slice(j.decode.bytes);if(t.length!==e)throw new Error("inconsistent lengths");return R(t,"base58btc")}function Py(s){const e=s.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==16)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion address.`);const t=he.decode("b"+e[0]),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const n=$i(r);return oe([t,n],t.length+n.length)}function Ay(s){const e=s.split(":");if(e.length!==2)throw new Error(`failed to parse onion addr: ["'${e.join('", "')}'"]' does not contain a port number`);if(e[0].length!==56)throw new Error(`failed to parse onion addr: ${e[0]} not a Tor onion3 address.`);const t=he.decode(`b${e[0]}`),r=parseInt(e[1],10);if(r<1||r>65536)throw new Error("Port number is not in range(1, 65536)");const n=$i(r);return oe([t,n],t.length+n.length)}function Lo(s){const e=s.slice(0,s.length-2),t=s.slice(s.length-2),r=R(e,"base32"),n=Wl(t);return`${r}:${n}`}function Ry(s){const e=[],t=s.split("/").slice(1);if(t.length===1&&t[0]==="")return[];for(let r=0;r<t.length;r++){const n=t[r],a=ee(n);if(a.size===0){e.push([n]);continue}if(r++,r>=t.length)throw Xl("invalid address: "+s);if(a.path===!0){e.push([n,Ai(t.slice(r).join("/"))]);break}e.push([n,t[r]])}return e}function Ty(s){const e=[];return s.map(t=>{const r=An(t);return e.push(r.name),t.length>1&&t[1]!=null&&e.push(t[1]),null}),Ai(e.join("/"))}function Oy(s){return s.map(e=>{Array.isArray(e)||(e=[e]);const t=An(e);return e.length>1?[t.code,_y(t.code,e[1])]:[t.code]})}function Jl(s){return s.map(e=>{const t=An(e);return e[1]!=null?[t.code,my(t.code,e[1])]:[t.code]})}function Gl(s){return Ca(oe(s.map(e=>{const t=An(e);let r=Uint8Array.from(j.encode(t.code));return e.length>1&&e[1]!=null&&(r=oe([r,e[1]])),r})))}function Ql(s,e){return s.size>0?s.size/8:s.size===0?0:j.decode(e)+(j.decode.bytes??0)}function Pi(s){const e=[];let t=0;for(;t<s.length;){const r=j.decode(s,t),n=j.decode.bytes??0,a=ee(r),i=Ql(a,s.slice(t+n));if(i===0){e.push([r]),t+=n;continue}const o=s.slice(t+n,t+n+i);if(t+=i+n,t>s.length)throw Xl("Invalid address Uint8Array: "+R(s,"base16"));e.push([r,o])}return e}function Bo(s){const e=Pi(s),t=Jl(e);return Ty(t)}function Cy(s){s=Ai(s);const e=Ry(s),t=Oy(e);return Gl(t)}function Iy(s){return Cy(s)}function Ca(s){const e=Ny(s);if(e!=null)throw e;return Uint8Array.from(s)}function Ny(s){try{Pi(s)}catch(e){return e}}function Ai(s){return"/"+s.trim().split("/").filter(e=>e).join("/")}function Xl(s){return new Error("Error parsing address: "+s)}function An(s){return ee(s[0])}const xy=Symbol.for("nodejs.util.inspect.custom"),Ly=[ee("dns").code,ee("dns4").code,ee("dns6").code,ee("dnsaddr").code],By=new Map,Yl=Symbol.for("@multiformats/js-multiaddr/multiaddr");function jy(s){return!!s?.[Yl]}var Qt,Xt,Yt,nt,NA;const $t=class $t{constructor(e){Wn(this,"bytes");hr(this,Qt,void 0);hr(this,Xt,void 0);hr(this,Yt,void 0);hr(this,nt,void 0);Wn(this,NA,!0);if(e==null&&(e=""),e instanceof Uint8Array)this.bytes=Ca(e);else if(typeof e=="string"){if(e.length>0&&e.charAt(0)!=="/")throw new Error(`multiaddr "${e}" must start with a "/"`);this.bytes=Iy(e)}else if(jy(e))this.bytes=Ca(e.bytes);else throw new Error("addr must be a string, Buffer, or another Multiaddr")}toString(){return We(this,Qt)==null&&Dt(this,Qt,Bo(this.bytes)),We(this,Qt)}toJSON(){return this.toString()}toOptions(){let e,t,r,n,a="";const i=ee("tcp"),o=ee("udp"),c=ee("ip4"),l=ee("ip6"),u=ee("dns6"),d=ee("ip6zone");for(const[f,p]of this.stringTuples())f===d.code&&(a=`%${p??""}`),Ly.includes(f)&&(t=i.name,n=443,r=`${p??""}${a}`,e=f===u.code?6:4),(f===i.code||f===o.code)&&(t=ee(f).name,n=parseInt(p??"")),(f===c.code||f===l.code)&&(t=ee(f).name,r=`${p??""}${a}`,e=f===l.code?6:4);if(e==null||t==null||r==null||n==null)throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');return{family:e,host:r,transport:t,port:n}}protos(){return this.protoCodes().map(e=>Object.assign({},ee(e)))}protoCodes(){const e=[],t=this.bytes;let r=0;for(;r<t.length;){const n=j.decode(t,r),a=j.decode.bytes??0,i=ee(n),o=Ql(i,t.slice(r+a));r+=o+a,e.push(n)}return e}protoNames(){return this.protos().map(e=>e.name)}tuples(){return We(this,Xt)==null&&Dt(this,Xt,Pi(this.bytes)),We(this,Xt)}stringTuples(){return We(this,Yt)==null&&Dt(this,Yt,Jl(this.tuples())),We(this,Yt)}encapsulate(e){return e=new $t(e),new $t(this.toString()+e.toString())}decapsulate(e){const t=e.toString(),r=this.toString(),n=r.lastIndexOf(t);if(n<0)throw new Error(`Address ${this.toString()} does not contain subaddress: ${e.toString()}`);return new $t(r.slice(0,n))}decapsulateCode(e){const t=this.tuples();for(let r=t.length-1;r>=0;r--)if(t[r][0]===e)return new $t(Gl(t.slice(0,r)));return this}getPeerId(){try{const t=this.stringTuples().filter(r=>r[0]===Zs.ipfs.code).pop();if(t?.[1]!=null){const r=t[1];return r[0]==="Q"||r[0]==="1"?R(U.decode(`z${r}`),"base58btc"):R(w.parse(r).multihash.bytes,"base58btc")}return null}catch{return null}}getPath(){if(We(this,nt)===void 0)try{Dt(this,nt,this.stringTuples().filter(e=>ee(e[0]).path===!0)[0][1]),We(this,nt)==null&&Dt(this,nt,null)}catch{Dt(this,nt,null)}return We(this,nt)}equals(e){return fn(this.bytes,e.bytes)}async resolve(e){const t=this.protos().find(a=>a.resolvable);if(t==null)return[this];const r=By.get(t.name);if(r==null)throw new El(`no available resolver for ${t.name}`,"ERR_NO_AVAILABLE_RESOLVER");return(await r(this,e)).map(a=>new $t(a))}nodeAddress(){const e=this.toOptions();if(e.transport!=="tcp"&&e.transport!=="udp")throw new Error(`multiaddr must have a valid format - no protocol with name: "${e.transport}". Must have a valid transport protocol: "{tcp, udp}"`);return{family:e.family,address:e.host,port:e.port}}isThinWaistAddress(e){const t=(e??this).protos();return!(t.length!==2||t[0].code!==4&&t[0].code!==41||t[1].code!==6&&t[1].code!==273)}[(NA=Yl,xy)](){return`Multiaddr(${Bo(this.bytes)})`}};Qt=new WeakMap,Xt=new WeakMap,Yt=new WeakMap,nt=new WeakMap;let Ia=$t;function ss(s){return new Ia(s)}const My=O("dns4"),zy=O("dns6"),Uy=O("dnsaddr"),Ot=Ae(O("dns"),Uy,My,zy),Rn=Ae(O("ip4"),O("ip6")),er=Ae(B(Rn,O("tcp")),B(Ot,O("tcp"))),Ri=B(Rn,O("udp")),Fy=B(Ri,O("utp")),Hy=B(Ri,O("quic")),Na=Ae(B(er,O("ws")),B(Ot,O("ws"))),xa=Ae(B(er,O("wss")),B(Ot,O("wss")),B(er,O("tls"),O("ws")),B(Ot,O("tls"),O("ws"))),La=Ae(B(er,O("http")),B(Rn,O("http")),B(Ot,O("http"))),Ba=Ae(B(er,O("https")),B(Rn,O("https")),B(Ot,O("https"))),jo=B(Ri,O("webrtc"),O("certhash")),Zl=Ae(B(jo,O("p2p")),jo),eu=Ae(B(Na,O("p2p-webrtc-star"),O("p2p")),B(xa,O("p2p-webrtc-star"),O("p2p")),B(Na,O("p2p-webrtc-star")),B(xa,O("p2p-webrtc-star"))),tu=Ae(B(La,O("p2p-webrtc-direct"),O("p2p")),B(Ba,O("p2p-webrtc-direct"),O("p2p")),B(La,O("p2p-webrtc-direct")),B(Ba,O("p2p-webrtc-direct"))),ja=Ae(Na,xa,La,Ba,eu,tu,er,Fy,Hy,Ot,Zl),ft=Ae(B(ja,O("p2p")),eu,tu,Zl,O("p2p")),Mo=Ae(B(ft,O("p2p-circuit"),ft),B(ft,O("p2p-circuit")),B(O("p2p-circuit"),ft),B(ja,O("p2p-circuit")),B(O("p2p-circuit"),ja),O("p2p-circuit")),ru=()=>Ae(B(Mo,ru),Mo),br=ru(),qy=Ae(B(br,ft,br),B(ft,br),B(br,ft),br,ft),Ky=qy;function su(s){function e(t){let r;try{r=ss(t)}catch{return!1}const n=s(r.protoNames());return n===null?!1:n===!0||n===!1?n:n.length===0}return e}function B(...s){function e(t){if(t.length<s.length)return null;let r=t;return s.some(n=>(r=typeof n=="function"?n().partialMatch(t):n.partialMatch(t),Array.isArray(r)&&(t=r),r===null)),r}return{toString:function(){return"{ "+s.join(" ")+" }"},input:s,matches:su(e),partialMatch:e}}function Ae(...s){function e(r){let n=null;return s.some(a=>{const i=typeof a=="function"?a().partialMatch(r):a.partialMatch(r);return i!=null?(n=i,!0):!1}),n}return{toString:function(){return"{ "+s.join(" ")+" }"},input:s,matches:su(e),partialMatch:e}}function O(s){const e=s;function t(n){let a;try{a=ss(n)}catch{return!1}const i=a.protoNames();return i.length===1&&i[0]===e}function r(n){return n.length===0?null:n[0]===e?n.slice(1):null}return{toString:function(){return e},matches:t,partialMatch:r}}const en=/^\/(ip[fn]s)\/([^/?#]+)/,nu=1,au=2,iu=/^https?:\/\/([^/]+)\.(ip[fn]s)\.[^/?]+/,Vy=/^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/;function Ti(s){try{return lu(s)?!!w.parse(s):s instanceof Uint8Array?!!w.decode(s):!!w.asCID(s)}catch{return!1}}function ou(s,e,t=nu,r=au){const n=uu(s);if(n===!1)return!1;const a=n.match(e);if(a==null||a[t]!=="ipfs")return!1;let i=a[r];return i!=null&&e===iu&&(i=i.toLowerCase()),Ti(i)}function cu(s,e,t=nu,r=au){const n=uu(s);if(n===!1)return!1;const a=n.match(e);if(a==null||a[t]!=="ipns")return!1;let i=a[r];if(i!=null&&e===iu){if(i=i.toLowerCase(),Ti(i))return!0;try{!i.includes(".")&&i.includes("-")&&(i=i.replace(/--/g,"@").replace(/-/g,".").replace(/@/g,"-"));const{hostname:o}=new hl.URL(`http://${i}`);return Vy.test(o)}catch{return!1}}return!0}function lu(s){return typeof s=="string"}function uu(s){return s instanceof Uint8Array?R(s,"base58btc"):lu(s)?s:!1}const du=s=>ou(s,en)||cu(s,en),Wy=s=>ou(s,en),hu=s=>cu(s,en);let Ls=class fu extends Error{constructor(e="request timed out"){super(e),this.name="TimeoutError",this.code=fu.code}};Ls.code="ERR_TIMEOUT";function E(s,e){return(...t)=>{const r=t[e??t.length-1];if(!r||!r.timeout)return s(...t);const n=typeof r.timeout=="string"?pn(r.timeout):r.timeout,a=new Jr.TimeoutController(n);r.signal=yn([r.signal,a.signal]);const i=s(...t),o=new Promise((u,d)=>{a.signal.addEventListener("abort",()=>{d(new Ls)})}),c=Date.now(),l=()=>{if(a.signal.aborted)throw new Ls;if(Date.now()-c>n)throw a.abort(),new Ls};return i[Symbol.asyncIterator]?async function*(){const u=i[Symbol.asyncIterator]();try{for(;;){const{value:d,done:h}=await Promise.race([u.next(),o]);if(h)break;l(),yield d}}catch(d){throw l(),d}finally{a.clear(),u.return&&u.return()}}():(async()=>{try{const u=await Promise.race([i,o]);return l(),u}catch(u){throw l(),u}finally{a.clear()}})()}}const zo="/ipfs/";function ns(s){if(s instanceof Uint8Array)try{s=w.decode(s)}catch(n){throw y(n,"ERR_INVALID_CID")}let e=w.asCID(s);if(e)return{cid:e,path:void 0};s=s.toString(),s.startsWith(zo)&&(s=s.substring(zo.length));const t=s.split("/");let r;try{e=w.parse(t.shift()||"")}catch(n){throw y(n,"ERR_INVALID_CID")}return t.length&&(r=`/${t.join("/")}`),{cid:e,path:r}}const Jy="ERR_BAD_PATH",pu="This command must be run in online mode. Try running 'ipfs daemon' first.",Ma=new ae("/local/filesroot"),Gy=262144,Qy=s=>{if(w.asCID(s))return`/ipfs/${s}`;const t=s.toString();try{return`/ipfs/${w.parse(t)}`}catch{}if(du(t))return t;throw y(new Error(`invalid path: ${s}`),Jy)},Oi=s=>s instanceof Uint8Array?w.decode(s).toString():(s=s.toString(),s.indexOf("/ipfs/")===0&&(s=s.substring(6)),s.charAt(s.length-1)==="/"&&(s=s.substring(0,s.length-1)),s),Tn=async function(s,e,t,r={}){const{cid:n,path:a}=ns(t);a&&(r.path=a);let i=n,o=r.path||"";if(o.startsWith("/")&&(o=o.substring(1)),r.path)try{for await(const{value:c,remainderPath:l}of Fr(n,r.path,e,s,{signal:r.signal})){if(!w.asCID(c))break;o=l,i=c}}catch(c){throw c.message.startsWith("Object has no property")&&(c.message=`no link named "${o.split("/")[0]}" under ${i}`,c.code="ERR_NO_LINK"),c}return{cid:i,remainderPath:o||""}},Uo=s=>{if(s.type!=="file"&&s.type!=="directory"&&s.type!=="raw")throw new Error(`Unknown node type '${s.type}'`);const e={cid:s.cid,path:s.path,name:s.name,size:s.size,type:"file"};return s.type==="directory"&&(e.type="dir"),s.type==="file"&&(e.size=s.unixfs.fileSize()),(s.type==="file"||s.type==="directory")&&(e.mode=s.unixfs.mode,s.unixfs.mtime!==void 0&&(e.mtime=s.unixfs.mtime)),e},Xy=E(async(s,e)=>await s),Fr=async function*(s,e,t,r,n){const a=async l=>{const u=await t.getCodec(l.code),d=await r.blocks.get(l,n);return u.decode(d)},i=e.split("/").filter(Boolean);let o=await a(s),c=s;for(;i.length;){const l=i.shift();if(!l)throw y(new Error(`Could not resolve path "${e}"`),"ERR_INVALID_PATH");if(s.code===V&&Array.isArray(o.Links)){const u=o.Links.find(d=>d.Name===l);if(u){yield{value:u.Hash,remainderPath:i.join("/")},o=await a(u.Hash),c=u.Hash;continue}}if(Object.prototype.hasOwnProperty.call(o,l))o=o[l],yield{value:o,remainderPath:i.join("/")};else throw y(new Error(`no link named "${l}" under ${c}`),"ERR_NO_LINK");w.asCID(o)&&(c=o,o=await a(o))}yield{value:o,remainderPath:""}};class He{static create({start:e,stop:t}){return new He(e,t)}static async start(e,t){const{state:r,activate:n}=e;switch(r.status){case"stopped":try{const a=n(t);e.state={status:"starting",ready:a};const i=await a;return e.state={status:"started",value:i},i}catch(a){throw e.state={status:"stopped"},a}case"starting":throw new kn;case"started":throw new $n;case"stopping":return await r.ready,await He.start(e,t);default:return He.panic(e)}}static async stop(e){const{state:t,deactivate:r}=e;switch(t.status){case"stopped":break;case"starting":{try{await t.ready}catch{}return await He.stop(e)}case"stopping":return await t.ready;case"started":{r&&await r(t.value),e.state={status:"stopped"};break}default:He.panic(t)}}static try({state:e}){switch(e.status){case"started":return e.value;default:return null}}static async use({state:e},t){switch(e.status){case"started":return e.value;case"starting":return await Xy(e.ready,t);default:throw new rs}}static panic({state:e}){const t=JSON.stringify({status:e.status});throw RangeError(`Service in invalid state ${t}, should never happen if you see this please report a bug`)}constructor(e,t){this.activate=e,this.deactivate=t,this.state={status:"stopped"}}async use(e){return await He.use(this,e)}try(){return He.try(this)}}function Yy({network:s,preload:e,peerId:t,keychain:r,repo:n,ipns:a,mfsPreload:i,print:o,hashers:c,options:l}){return async()=>{const{libp2p:d}=await He.start(s,{peerId:t,repo:n,print:o,hashers:c,options:l});await Promise.all([a.startOnline({keychain:r,libp2p:d,peerId:t,repo:n}),e.start(),i.start()])}}function Zy({network:s,preload:e,ipns:t,repo:r,mfsPreload:n}){return async()=>{await Promise.all([e.stop(),t.stop(),n.stop()]),await He.stop(s),await r.close()}}let ew=class{constructor(e){this.lru=fi(e)}get(e){const t=this.lru.get(e);if(t){if(t.expire&&t.expire<Date.now()){this.lru.remove(e);return}return t.value}}set(e,t,r){this.lru.set(e,{value:t,expire:Date.now()+r})}has(e){return!!this.get(e)}remove(e){this.lru.remove(e)}clear(){this.lru.clear()}};var as={};let tw=class extends Error{constructor(e="Request timed out"){super(e),this.name="TimeoutError"}};as.TimeoutError=tw;let rw=class extends Error{constructor(e="The operation was aborted."){super(e),this.name="AbortError"}};as.AbortError=rw;let sw=class extends Error{constructor(e){super(e.statusText),this.name="HTTPError",this.response=e}};as.HTTPError=sw;var nw=fh;const{TimeoutError:aw,AbortError:iw}=as,{Response:yu,Request:ow,Headers:Ci,default:cw}=nw,lw=(s,e={})=>{const t=new XMLHttpRequest;t.open(e.method||"GET",s.toString(),!0);const{timeout:r,headers:n}=e;if(r&&r>0&&r<1/0&&(t.timeout=r),e.overrideMimeType!=null&&t.overrideMimeType(e.overrideMimeType),n)for(const[a,i]of new Ci(n))t.setRequestHeader(a,i);return e.signal&&(e.signal.onabort=()=>t.abort()),e.onUploadProgress&&(t.upload.onprogress=e.onUploadProgress),t.responseType="arraybuffer",new Promise((a,i)=>{const o=c=>{switch(c.type){case"error":{a(yu.error());break}case"load":{a(new fw(t.responseURL,t.response,{status:t.status,statusText:t.statusText,headers:hw(t.getAllResponseHeaders())}));break}case"timeout":{i(new aw);break}case"abort":{i(new iw);break}}};t.onerror=o,t.onload=o,t.ontimeout=o,t.onabort=o,t.send(e.body)})},uw=cw,dw=(s,e={})=>e.onUploadProgress!=null?lw(s,e):uw(s,e),hw=s=>{const e=new Ci;for(const t of s.trim().split(/[\r\n]+/)){const r=t.indexOf(": ");r>0&&e.set(t.slice(0,r),t.slice(r+1))}return e};class fw extends yu{constructor(e,t,r){super(t,r),Object.defineProperty(this,"url",{value:e})}}var pw={fetch:dw,Request:ow,Headers:Ci};const{fetch:yw,Request:ww,Headers:gw}=pw,{TimeoutError:za,HTTPError:wu}=as,Fo=ph.bind({ignoreUndefined:!0}),{URL:Ho,URLSearchParams:qo}=hl,bw=yh,mw=wh,{isBrowser:_w,isWebWorker:Ew}=ot,vw=gh,Dw=(s,e,t)=>{if(e===void 0)return s;const r=Date.now(),n=()=>Date.now()-r>=e;return new Promise((a,i)=>{const o=setTimeout(()=>{n()&&(i(new za),t.abort())},e),c=l=>d=>{if(clearTimeout(o),n()){i(new za);return}l(d)};s.then(c(a),c(i))})},Sw={throwHttpErrors:!0,credentials:"same-origin"};let Oe=class{constructor(e={}){this.opts=Fo(Sw,e)}async fetch(e,t={}){const r=Fo(this.opts,t),n=new gw(r.headers);if(typeof e!="string"&&!(e instanceof Ho||e instanceof ww))throw new TypeError("`resource` must be a string, URL, or Request");const a=new Ho(e.toString(),r.base),{searchParams:i,transformSearchParams:o,json:c}=r;i&&(typeof o=="function"?a.search=o(new qo(r.searchParams)):a.search=new qo(r.searchParams)),c&&(r.body=JSON.stringify(r.json),n.set("content-type","application/json"));const l=new AbortController,u=bw([l.signal,r.signal]);globalThis.ReadableStream!=null&&r.body instanceof globalThis.ReadableStream&&(_w||Ew)&&(r.body=new Blob(await vw(mw(r.body))));const d=await Dw(yw(a.toString(),{...r,signal:u,timeout:void 0,headers:n,duplex:"half"}),r.timeout,l);if(!d.ok&&r.throwHttpErrors)throw r.handleError&&await r.handleError(d),new wu(d);return d.iterator=async function*(){yield*gu(d.body)},d.ndjson=async function*(){for await(const h of kw(d.iterator()))t.transform?yield t.transform(h):yield h},d}post(e,t={}){return this.fetch(e,{...t,method:"POST"})}get(e,t={}){return this.fetch(e,{...t,method:"GET"})}put(e,t={}){return this.fetch(e,{...t,method:"PUT"})}delete(e,t={}){return this.fetch(e,{...t,method:"DELETE"})}options(e,t={}){return this.fetch(e,{...t,method:"OPTIONS"})}};const kw=async function*(s){const e=new TextDecoder;let t="";for await(const r of s){t+=e.decode(r,{stream:!0});const n=t.split(/\r?\n/);for(let a=0;a<n.length-1;a++){const i=n[a].trim();i.length>0&&(yield JSON.parse(i))}t=n[n.length-1]}t+=e.decode(),t=t.trim(),t.length!==0&&(yield JSON.parse(t))},gu=s=>{if($w(s))return s;if(Aw(s)){const e=s[Symbol.asyncIterator]();return{[Symbol.asyncIterator](){return{next:e.next.bind(e),return(t){return s.destroy(),typeof e.return=="function"?e.return():Promise.resolve({done:!0,value:t})}}}}}if(Pw(s)){const e=s.getReader();return async function*(){try{for(;;){const{done:t,value:r}=await e.read();if(t)return;r&&(yield r)}}finally{e.releaseLock()}}()}throw new TypeError("Body can't be converted to AsyncIterable")},$w=s=>typeof s=="object"&&s!==null&&typeof s[Symbol.asyncIterator]=="function",Pw=s=>s&&typeof s.getReader=="function",Aw=s=>Object.prototype.hasOwnProperty.call(s,"readable")&&Object.prototype.hasOwnProperty.call(s,"writable");Oe.HTTPError=wu;Oe.TimeoutError=za;Oe.streamToAsyncIterator=gu;Oe.post=(s,e)=>new Oe(e).post(s,e);Oe.get=(s,e)=>new Oe(e).get(s,e);Oe.put=(s,e)=>new Oe(e).put(s,e);Oe.delete=(s,e)=>new Oe(e).delete(s,e);Oe.options=(s,e)=>new Oe(e).options(s,e);var Rw=Oe;const at=ef(Rw),Zn=new ew(1e3),Tw=60*1e3,Ow=Ue.default?Ue.default:Ue,Cw=new Ow({concurrency:4}),Ko=s=>{if(s.Path)return s.Path;throw new Error(s.Message)};async function Iw(s,e){return(async(r,n={})=>{const a=new URLSearchParams(n);a.set("arg",r);const i=a.toString();if(!n.nocache&&Zn.has(i)){const c=Zn.get(i);return Ko(c)}const o=await Cw.add(async()=>{const c=await at.get("https://ipfs.io/api/v0/dns",{searchParams:a}),l=new URL(c.url).search.slice(1),u=await c.json();return Zn.set(l,u,Tw),u});return Ko(o)})(s,e)}function Nw(s){return s.endsWith(".eth")&&(s=s.replace(/.eth$/,".eth.link")),s}function xw(){return E(async(e,t={recursive:!0})=>{if(typeof e!="string")throw new Error("Invalid arguments, domain must be a string");return e=Nw(e),Iw(e,t)})}function Lw({network:s}){return()=>{const e=s.try();return e!=null&&!!e.libp2p.isStarted()}}function Bw({repo:s,codecs:e,bases:t,name:r}){async function n(a,i={}){if(!du(a))throw new Error("invalid argument "+a);if(hu(a))for await(const _ of r.resolve(a,i))a=_;const[,o,c,...l]=a.split("/"),u=i.cidBase?await t.getBase(i.cidBase):void 0,d=jw(c);if(l.length===0){const _=u?u.encoder.encode(d):c;return`/${o}/${_}`}const h=w.decode(d);a=l.join("/");const f=Fr(h,a,e,s,i);let p=h,g=a;for await(const _ of f)w.asCID(_.value)&&(p=_.value,g=_.remainderPath);return`/ipfs/${p.toString(u&&u.encoder)}${g?"/"+g:""}`}return E(n)}function jw(s){try{return pe(s).toBytes()}catch{return w.parse(s).bytes}}function Mw({addAll:s}){return(e,t={})=>{let r;const n=w.asCID(e);return n?r=s([{cid:n,...t}],t):r=s([{path:e.toString(),...t}],t),Ce(r)}}function zw(s){return Symbol.iterator in s}function Uw(s){return Symbol.asyncIterator in s}function Vo(s){return w.asCID(s)!=null}async function*is(s){if(s==null)throw y(new Error(`Unexpected input: ${s}`),"ERR_UNEXPECTED_INPUT");const e=w.asCID(s);if(e){yield Pe({cid:e});return}if(s instanceof String||typeof s=="string"){yield Pe({path:s});return}if(s.cid!=null||s.path!=null)return yield Pe(s);if(zw(s)){const t=s[Symbol.iterator](),r=t.next();if(r.done)return t;if(Vo(r.value)){yield Pe({cid:r.value});for(const n of t)yield Pe({cid:n});return}if(r.value instanceof String||typeof r.value=="string"){yield Pe({path:r.value});for(const n of t)yield Pe({path:n});return}if(r.value.cid!=null||r.value.path!=null){yield Pe(r.value);for(const n of t)yield Pe(n);return}throw y(new Error("Unexpected input: "+typeof s),"ERR_UNEXPECTED_INPUT")}if(Uw(s)){const t=s[Symbol.asyncIterator](),r=await t.next();if(r.done)return t;if(Vo(r.value)){yield Pe({cid:r.value});for await(const n of t)yield Pe({cid:n});return}if(r.value instanceof String||typeof r.value=="string"){yield Pe({path:r.value});for await(const n of t)yield Pe({path:n});return}if(r.value.cid!=null||r.value.path!=null){yield Pe(r.value);for await(const n of t)yield Pe(n);return}throw y(new Error("Unexpected input: "+typeof s),"ERR_UNEXPECTED_INPUT")}throw y(new Error("Unexpected input: "+typeof s),"ERR_UNEXPECTED_INPUT")}function Pe(s){const e=s.cid||`${s.path}`;if(!e)throw y(new Error("Unexpected input: Please path either a CID or an IPFS path"),"ERR_UNEXPECTED_INPUT");const t={path:e,recursive:s.recursive!==!1};return s.metadata!=null&&(t.metadata=s.metadata),t}const q={direct:"direct",recursive:"recursive",indirect:"indirect",all:"all"};function Fw({repo:s,codecs:e}){async function*t(r,n={}){const a=async function*(){for await(const{path:c,recursive:l,metadata:u}of is(r)){const{cid:d}=await Tn(s,e,c),{reason:h}=await s.pins.isPinnedWithType(d,[q.recursive,q.direct]);if(h==="recursive"&&!l)throw new Error(`${d} already pinned recursively`);l?await s.pins.pinRecursively(d,{metadata:u}):await s.pins.pinDirectly(d,{metadata:u}),yield d}};if(!!!n.lock){yield*a();return}const o=await s.gcLock.readLock();try{yield*a()}finally{o()}}return E(t)}function mr(s,e,t){const r={type:s,cid:e};return t&&(r.metadata=t),r}function Hw({repo:s,codecs:e}){async function*t(r={}){let n=q.all;if(r.type&&(n=r.type,!Object.keys(q).includes(n)))throw y(new Error("Invalid pin type"),"ERR_INVALID_PIN_TYPE");if(r.paths){let a=!1;for await(const{path:i}of is(r.paths)){const{cid:o}=await Tn(s,e,i),{reason:c,pinned:l,parent:u,metadata:d}=await s.pins.isPinnedWithType(o,n);if(!l)throw y(new Error(`path '${i}' is not pinned`),"ERR_NOT_PINNED");switch(c){case q.direct:case q.recursive:a=!0,yield mr(c,o,d);break;default:a=!0,yield mr(`${q.indirect} through ${u}`,o,d)}}if(!a)throw new Error("No match found");return}if(n===q.recursive||n===q.all)for await(const{cid:a,metadata:i}of s.pins.recursiveKeys())yield mr(q.recursive,a,i);if(n===q.indirect||n===q.all)for await(const a of s.pins.indirectKeys(r))yield mr(q.indirect,a);if(n===q.direct||n===q.all)for await(const{cid:a,metadata:i}of s.pins.directKeys())yield mr(q.direct,a,i)}return E(t)}function qw({rmAll:s}){async function e(t,r={}){const n=await Ce(s([{path:t,...r}],r));if(!n)throw new Error("CID expected");return n}return e}function Kw({repo:s,codecs:e}){async function*t(r,n={}){const a=await s.gcLock.readLock();try{for await(const{path:i,recursive:o}of is(r)){const{cid:c}=await Tn(s,e,i),{pinned:l,reason:u}=await s.pins.isPinnedWithType(c,q.all);if(!l)throw new Error(`${c} is not pinned`);switch(u){case q.recursive:if(!o)throw new Error(`${c} is pinned recursively`);await s.pins.unpin(c),yield c;break;case q.direct:await s.pins.unpin(c),yield c;break;default:throw new Error(`${c} is pinned indirectly under ${u}`)}}}finally{a()}}return E(t)}class Vw{constructor({codecs:e,repo:t}){const r=Fw({codecs:e,repo:t});this.addAll=r,this.add=Mw({addAll:r});const n=Kw({codecs:e,repo:t});this.rmAll=n,this.rm=qw({rmAll:n}),this.ls=Hw({codecs:e,repo:t}),this.remote={add:(a,i={})=>Promise.reject(new Error("Not implemented")),ls:async function*(a,i={}){return Promise.reject(new Error("Not implemented"))},rm:(a,i={})=>Promise.reject(new Error("Not implemented")),rmAll:(a,i={})=>Promise.reject(new Error("Not implemented")),service:{add:(a,i)=>Promise.reject(new Error("Not implemented")),rm:(a,i={})=>Promise.reject(new Error("Not implemented")),ls:(a={})=>Promise.reject(new Error("Not implemented"))}}}}const Be=M("ipfs:ipns:publisher"),Wo=At().code,bu=60*60*1e3;class Bs{constructor(e,t){this._routing=e,this._datastore=t}async publishWithEOL(e,t,r,n){const a=await this._updateOrCreateRecord(e,t,r,n);return this._putRecordToRouting(a,e,n)}publish(e,t,r){return this.publishWithEOL(e,t,bu,r)}async _putRecordToRouting(e,t,r){if(!Lr(t)){const a="peerId received is not valid";throw Be.error(a),y(new Error(a),"ERR_INVALID_PEER_ID")}if(t.publicKey==null)throw y(new Error("Public key was missing"),"ERR_MISSING_PUBLIC_KEY");const n=Us(t);return await this._publishEntry(n,e,r),e}async _publishEntry(e,t,r){try{const n=await this._routing.put(e,t,r);return Be(`ipns record for ${R(e,"base32")} was stored in the routing`),n}catch(n){const a=`ipns record for ${R(e,"base32")} could not be stored in the routing - ${n.stack}`;throw Be.error(a),Be.error(n),y(new Error(a),"ERR_PUTTING_TO_ROUTING")}}async _getPublished(e,t={}){if(!Lr(e)){const n="peerId received is not valid";throw Be.error(n),y(new Error(n),"ERR_INVALID_PEER_ID")}const r=t.checkRouting!==!1;try{const n=await this._datastore.get(_a(e.toBytes()));return this._unmarshalData(n)}catch(n){if(n.code!==Wo){const a=`unexpected error getting the ipns record ${e.toString()} from datastore`;throw Be.error(a),y(new Error(a),"ERR_UNEXPECTED_DATASTORE_RESPONSE")}if(!r)throw y(n,"ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED");try{const a=Us(e),i=await this._routing.get(a);return this._unmarshalData(i)}catch(a){throw Be.error(a),a}}}_unmarshalData(e){try{return pi(e)}catch(t){throw y(t,"ERR_INVALID_RECORD_DATA")}}async _updateOrCreateRecord(e,t,r,n){if(!Lr(e)){const l="peerId received is not valid";throw Be.error(l),y(new Error(l),"ERR_INVALID_PEER_ID")}const a={checkRouting:!0};let i;try{i=await this._getPublished(e,a)}catch(l){if(l.code!==Wo){const u=`unexpected error when determining the last published IPNS record for ${e.toString()} ${l.stack}`;throw Be.error(u),y(new Error(u),"ERR_DETERMINING_PUBLISHED_RECORD")}}let o=0n;i&&i.sequence!==void 0&&(o=fn(i.value,t)?i.sequence:i.sequence+BigInt(1));let c;try{c=await bh(e,t,o,r)}catch(l){const u=`ipns record for ${t} could not be created`;throw Be.error(l),y(new Error(u),"ERR_CREATING_IPNS_RECORD")}try{const l=mh(c);return await this._datastore.put(_a(e.toBytes()),l,n),Be(`ipns record for ${R(t,"base32")} was stored in the datastore`),l}catch{const u=`ipns record for ${t} could not be stored in the datastore`;throw Be.error(u),y(new Error(u),"ERR_STORING_IN_DATASTORE")}}}Bs.defaultRecordLifetime=bu;const fs=M("ipfs:ipns:republisher"),mu=60*1e3,_u=60*mu,Ww=4*_u,Jw=24*_u;class Gw{constructor(e,t,r,n,a={pass:""}){this._publisher=e,this._datastore=t,this._peerId=r,this._keychain=n,this._options=a,this._republishHandle=null}async start(){if(this._republishHandle)throw y(new Error("republisher is already running"),"ERR_REPUBLISH_ALREADY_RUNNING");const e={_task:null,_inflightTask:null,_timeoutId:null,runPeriodically:n=>{e._timeoutId=setTimeout(async()=>{e._timeoutId=null;try{e._inflightTask=e._task(),await e._inflightTask,e._task&&e.runPeriodically(n)}catch(a){fs.error(a)}},n())},cancel:async()=>{e._timeoutId!=null&&clearTimeout(e._timeoutId),e._task=null,await e._inflightTask}},{pass:t}=this._options;let r=!0;e._task=async()=>{const n=new Jr.TimeoutController(3e4);try{await this._republishEntries(this._peerId,t,{signal:n.signal})}finally{n.clear()}},e.runPeriodically(()=>r?(r=!1,this._options.initialBroadcastInterval||mu):this._options.broadcastInterval||Ww),this._republishHandle=e}async stop(){const e=this._republishHandle;if(!e)throw y(new Error("republisher is not running"),"ERR_REPUBLISH_NOT_RUNNING");this._republishHandle=null,await e.cancel()}async _republishEntries(e,t,r){try{await this._republishEntry(e,r)}catch{const a="cannot republish entry for the node's private key";fs.error(a);return}if(t)try{const n=await this._keychain.listKeys();for(const a of n){if(a.name==="self")continue;const i=await this._keychain.exportKey(a.name,t),o=await vl(i,t),c=await mn(o.public.bytes,o.bytes);await this._republishEntry(c,r)}}catch(n){fs.error(n)}}async _republishEntry(e,t){try{const r=await this._getPreviousValue(e);await this._publisher.publishWithEOL(e,r,Jw,t)}catch(r){if(r.code==="ERR_NO_ENTRY_FOUND")return;throw r}}async _getPreviousValue(e){if(!Lr(e))throw y(new Error("invalid peer ID"),"ERR_INVALID_PEER_ID");try{const t=await this._datastore.get(_a(e.toBytes()));if(!(t instanceof Uint8Array))throw y(new Error("found ipns record that we couldn't process"),"ERR_INVALID_IPNS_RECORD");try{return pi(t).value}catch(r){throw fs.error(r),y(new Error("found ipns record that we couldn't convert to a value"),"ERR_INVALID_IPNS_RECORD")}}catch(t){throw t&&t.notFound?y(new Error(`no previous entry for record with id: ${e.toString()}`),"ERR_NO_ENTRY_FOUND"):t}}}const ea=M("ipfs:ipns:resolver"),Qw=At().code,Jo=32;class Xw{constructor(e){this._routing=e}async resolve(e,t={}){if(typeof e!="string")throw y(new Error("invalid name"),"ERR_INVALID_NAME");const r=t.recursive&&t.recursive.toString()==="true",n=e.split("/");if(n.length!==3||n[0]!=="")throw y(new Error("invalid name"),"ERR_INVALID_NAME");const a=n[2];let i=1/0;r&&(i=Jo);const o=await this.resolver(a,i,t);return ea(`${e} was locally resolved correctly`),o}async resolver(e,t,r){if(t===0){const i=`could not resolve name (recursion limit of ${Jo} exceeded)`;throw ea.error(i),y(new Error(i),"ERR_RESOLVE_RECURSION_LIMIT")}const n=await this._resolveName(e,r),a=n.split("/");return a[1]==="ipfs"||!t?n:this.resolver(a[2],t-1,r)}async _resolveName(e,t){const r=pe(e),n=Us(r);let a;try{a=await this._routing.get(n,t)}catch(i){throw ea.error("could not get record from routing",i),i.code===Qw?y(new Error(`record requested for ${e} was not found in the network`),"ERR_NO_RECORD_FOUND"):y(new Error(`unexpected error getting the ipns record ${r.toString()}`),"ERR_UNEXPECTED_ERROR_GETTING_RECORD")}return this._validateRecord(r,a)}async _validateRecord(e,t){await fl(oe([Q("/ipns/"),e.toBytes()]),t);const r=pi(t);return R(r.value)}}class Yw{constructor(e){this.lru=fi(e)}get(e){const t=this.lru.get(e);if(t){if(t.expire&&t.expire<Date.now()){this.lru.remove(e);return}return t.value}}set(e,t,r){this.lru.set(e,{value:t,expire:Date.now()+r})}has(e){return!!this.get(e)}remove(e){this.lru.remove(e)}clear(){this.lru.clear()}}const _r=M("ipfs:ipns"),Go=60*1e3;class Qo{constructor(e,t,r,n,a){this.publisher=new Bs(e,t),this.republisher=new Gw(this.publisher,t,r,n,a),this.resolver=new Xw(e),this.cache=new Yw(1e3),this.routing=e}async publish(e,t,r=Bs.defaultRecordLifetime,n){try{await this.publisher.publishWithEOL(e,t,r,n),_r(`IPNS value ${R(t,"base32")} was published correctly`);const a=e.toString(),i=parseFloat(r),o=i<Go?i:Go;return this.cache.set(a,t,o),_r(`IPNS value ${R(t,"base32")} was cached correctly`),{name:a,value:t}}catch(a){throw _r.error(a),a}}async resolve(e,t={}){if(typeof e!="string")throw y(new Error("name received is not valid"),"ERR_INVALID_NAME");if(!t.nocache&&!t.recursive){const r=e.split("/")[2],n=this.cache.get(r);if(n)return n}try{const r=await this.resolver.resolve(e,t);return _r(`IPNS record from ${e} was resolved correctly`),r}catch(r){throw _r.error(r),r}}async initializeKeyspace(e,t,r){return this.publish(e,t,Bs.defaultRecordLifetime,r)}}const ps=M("ipfs:ipns:pubsub");class Ua{constructor(e,t,r){this._subscriptions={},this._handleSubscriptionKey=this._handleSubscriptionKey.bind(this),this._pubsubDs=new _h(e,t,r,fl,Eh,this._handleSubscriptionKey)}async put(e,t,r){try{await this._pubsubDs.put(e,t,r)}catch(n){throw ps.error(n),n}}async get(e,t){let r,n;try{r=await this._pubsubDs.get(e,t)}catch(i){n=i}const a=e.slice(0,Jn);if(R(a)===Gn){const i=U.encode(e).substring(1),o=U.encode(e.slice(Jn)).substring(1);this._subscriptions[i]=o,ps(`subscribed to pubsub topic ${i}, id ${o}`)}if(n)throw n;return r}_handleSubscriptionKey(e){e instanceof Uint8Array&&(e=R(e,"base58btc"));const t=this._subscriptions[e];if(!t)throw y(new Error(`key ${e} does not correspond to a subscription`),"ERR_INVALID_KEY");try{return Us(pe(t))}catch(r){throw ps.error(r),r}}getSubscriptions(){return Object.values(this._subscriptions).filter(Boolean).map(t=>`${Gn}${t}`)}async cancel(e){if(typeof e!="string")throw y(new Error("invalid subscription name"),"ERR_INVALID_SUBSCRIPTION_NAME");e.startsWith(Gn)&&(e=e.substring(Jn));const t=Object.keys(this._subscriptions).find(n=>this._subscriptions[n]===e);if(!t)return{canceled:!1};const r=Q(t);return this._pubsubDs.unsubscribe(r),delete this._subscriptions[t],ps(`unsubscribed pubsub ${t}: ${e}`),{canceled:!0}}}const ta=M("ipfs:ipns:offline-datastore");class Eu{constructor(e){this._datastore=e,this.stores=[]}async put(e,t,r){if(!(e instanceof Uint8Array))throw y(new Error("Offline datastore key must be a Uint8Array"),"ERR_INVALID_KEY");if(!(t instanceof Uint8Array))throw y(new Error("Offline datastore value must be a Uint8Array"),"ERR_INVALID_VALUE");let n;try{n=this._routingKey(e)}catch(i){throw ta.error(i),y(new Error("Not possible to generate the routing key"),"ERR_GENERATING_ROUTING_KEY")}const a=new po(e,t,new Date);await this._datastore.put(n,a.serialize(),r)}async get(e,t){if(!(e instanceof Uint8Array))throw y(new Error("Offline datastore key must be a Uint8Array"),"ERR_INVALID_KEY");let r;try{r=this._routingKey(e)}catch(i){throw ta.error(i),y(new Error("Not possible to generate the routing key"),"ERR_GENERATING_ROUTING_KEY")}const n=await this._datastore.get(r,t);let a;try{a=po.deserialize(n)}catch(i){throw ta.error(i),i}return a.value}_routingKey(e){return new ae("/dht/record/"+R(e,"base32"),!1)}}const Zw=M("ipfs:ipns:dht-datastore");class eg{constructor(e){this._dht=e}async put(e,t,r){try{await wn(this._dht.put(e,t,r))}catch(n){throw Zw.error(n),n}}async get(e,t){for await(const r of this._dht.get(e,t))if(r.name==="VALUE")return r.value;throw At()}}function tg({libp2p:s,repo:e,peerId:t,options:r}){const n=[];let a;if(Tr(r,"EXPERIMENTAL.ipnsPubsub",!1)&&(a=new Ua(s.pubsub,e.datastore,t),n.push(a)),Tr(r,"offline",!1)!==!0&&["dht","dhtclient","dhtserver"].includes(Tr(r,"config.Routing.Type","none"))&&n.push(new eg(s.dht)),Tr(r,"offline",!1)||n.length===0){const i=new Eu(e.datastore);n.push(i)}return new vh(n)}const rg=M("ipfs:components:ipns");class sg{constructor(e={pass:""}){this.options=e,this.offline=null,this.online=null}getIPNS(){const e=this.online||this.offline;if(e)return e;throw new ts}get routing(){return this.getIPNS().routing}startOffline({repo:e,peerId:t,keychain:r}){if(this.offline!=null)throw new Tt;rg("initializing IPNS keyspace (offline)");const n=new Eu(e.datastore),a=new Qo(n,e.datastore,t,r,this.options);this.offline=a}async startOnline({libp2p:e,repo:t,peerId:r,keychain:n}){if(this.online!=null)throw new Tt;const a=tg({libp2p:e,repo:t,peerId:r,options:this.options}),i=new Qo(a,t.datastore,r,n,this.options);await i.republisher.start(),this.online=i}async stop(){const e=this.online;e&&(await e.republisher.stop(),this.online=null)}publish(e,t,r,n){return this.getIPNS().publish(e,t,r,n)}resolve(e,t){return this.getIPNS().resolve(e,t)}initializeKeyspace(e,t,r){return this.getIPNS().initializeKeyspace(e,t,r)}}async function ng({ipns:s,repo:e,codecs:t},r,n){if(hu(r))return s.resolve(r);const{cid:a,path:i}=ns(r);await wn(Fr(a,i||"",t,e,n))}const ra=M("ipfs:name:publish");function ag({ipns:s,repo:e,codecs:t,peerId:r,isOnline:n,keychain:a}){const i=async c=>{let l;if(c==="self"&&r.privateKey!=null)l=await bi(r.privateKey);else try{const u=await a.exportKey(c,"temp");l=await vl(u,"temp")}catch(u){throw ra.error(u),y(u,"ERR_CANNOT_GET_KEY")}return mn(l.public.bytes,l.bytes)};async function o(c,l={}){const u=l.resolve!==!1,d=l.lifetime||"24h",h=l.key||"self";if(!n())throw y(new Error(pu),"OFFLINE_ERROR");try{c=Qy(c)}catch(v){throw ra.error(v),v}let f=0;try{f=pn(d)||0,f=parseFloat(f.toFixed(6))}catch(v){throw ra.error(v),v}const p=await Promise.all([i(h),u?ng({ipns:s,repo:e,codecs:t},c):Promise.resolve()]),g=Q(c),_=await s.publish(p[0],g,f,l);return{name:_.name,value:R(_.value)}}return E(o)}const ig=_e.bind({ignoreUndefined:!0}),og=M("ipfs:name:resolve"),Xo=(s,e)=>e.length>0?s+"/"+e.join("/"):s;function cg({dns:s,ipns:e,isOnline:t,options:{offline:r}}){async function*n(a,i={}){if(i=ig({nocache:!1,recursive:!0},i),r&&i&&i.nocache)throw y(new Error("cannot specify both offline and nocache"),"ERR_NOCACHE_AND_OFFLINE");if(!t()&&!r)throw y(new Error(pu),"OFFLINE_ERROR");let o=a.toString();o.startsWith("/ipns/")||(o=`/ipns/${o}`);let[c,l,...u]=o.slice(1).split("/");try{if(l.substring(0,1)==="1"){const h=pe(l),f=Et(h.toBytes());l=w.createV1(114,f).toString(Qs)}else{const h=w.parse(l);h.version===1&&(l=h.toString(Qs))}}catch(h){if(Dh(l)){yield Xo(await s(l,i),u);return}throw og.error(h),y(new Error("Invalid IPNS name"),"ERR_IPNS_INVALID_NAME")}const d=await e.resolve(`/${c}/${l}`,i);yield Xo(d instanceof Uint8Array?R(d):d,u)}return E(n)}function Ii(s,e){if(!s||!(e&&e.ipnsPubsub))throw y(new Error("IPNS pubsub subsystem is not enabled"),"ERR_IPNS_PUBSUB_NOT_ENABLED");if(s.routing instanceof Ua)return s.routing;const t=(s.routing.stores||[]).find(r=>r instanceof Ua);if(!t)throw y(new Error("IPNS pubsub datastore not found"),"ERR_PUBSUB_DATASTORE_NOT_FOUND");return t}function lg({ipns:s,options:e}){const t=e.EXPERIMENTAL;async function r(n,a={}){return Ii(s,t).cancel(n,a)}return E(r)}function ug({ipns:s,options:e}){const t=e.EXPERIMENTAL;async function r(n={}){try{return{enabled:!!Ii(s,t)}}catch{return{enabled:!1}}}return E(r)}function dg({ipns:s,options:e}){const t=e.EXPERIMENTAL;async function r(n={}){return Ii(s,t).getSubscriptions(n)}return E(r)}class hg{constructor({ipns:e,options:t}){this.cancel=lg({ipns:e,options:t}),this.state=ug({ipns:e,options:t}),this.subs=dg({ipns:e,options:t})}}class fg{constructor({dns:e,ipns:t,repo:r,codecs:n,peerId:a,isOnline:i,keychain:o,options:c}){this.publish=ag({ipns:t,repo:r,codecs:n,peerId:a,isOnline:i,keychain:o}),this.resolve=cg({dns:e,ipns:t,isOnline:i,options:c}),this.pubsub=new hg({ipns:t,options:c})}}const pg=At().code,Fa={default:"<dst>",edges:"<src> -> <dst>"};function yg({repo:s,codecs:e,resolve:t,preload:r}){async function*n(a,i={}){if(i.maxDepth===0)return;if(i.edges&&i.format&&i.format!==Fa.default)throw new Error("Cannot set edges to true and also specify format");if(i.format=i.edges?Fa.edges:i.format,typeof i.maxDepth!="number"&&(i.maxDepth=i.recursive?1/0:1),i.timeout){const u=[new Jr.TimeoutController(i.timeout).signal];i.signal&&u.push(i.signal),i.signal=yn(u)}const c=(Array.isArray(a)?a:[a]).map(l=>wg(r,l,i));for(const l of c)try{yield*gg(t,s,e,l,i)}catch(u){yield{ref:"",err:u.message}}}return n}function wg(s,e,t){const{cid:r,path:n}=ns(e);return t.preload!==!1&&s(r),`/ipfs/${r}${n||""}`}async function*gg(s,e,t,r,n){const a=await s(r,n),{cid:i}=ns(a),o=n.maxDepth!=null?n.maxDepth:1/0,c=n.unique||!1;for await(const l of mg(e,t,i,o,c,n))l.parent&&(l.isDuplicate||(yield{ref:bg(l.parent.cid,l.node.cid,l.node.name,n.format)}))}function bg(s,e,t="",r=Fa.default){let n=r.replace(/<src>/g,s.toString());return n=n.replace(/<dst>/g,e.toString()),n=n.replace(/<linkname>/g,t),n}async function*mg(s,e,t,r,n,a){const i=new Set;async function*o(c,l){const u=l+1;if(!(u>r))try{for await(const d of _g(s,e,c.cid,a))yield{parent:c,node:d,isDuplicate:n&&i.has(d.cid.toString())},n&&i.add(d.cid.toString()),yield*o(d,u)}catch(d){throw d.code===pg&&(d.message=`Could not find object with CID: ${c.cid}`),d}}yield*o({cid:t},0)}async function*_g(s,e,t,r){const n=await s.blocks.get(t,r),i=(await e.getCodec(t.code)).decode(n),o=t.code===V,c=[];for(const[l,u]of Ha(i,c)){if(o){const d=l.match(/^Links\/(\d+)\/Hash$/);if(d){const h=Number(d[1]);if(h<i.Links.length){yield{name:i.Links[h].Name,cid:u};continue}}}yield{name:l,cid:u}}}const Ha=function*(s,e){if(s!=null&&!(s instanceof Uint8Array)){for(const[t,r]of Object.entries(s)){const n=[...e,t];if(r!=null&&typeof r=="object")if(Array.isArray(r))for(const[a,i]of r.entries()){const o=[...n,a],c=w.asCID(i);c?yield[o.join("/"),c]:typeof i=="object"&&(yield*Ha(i,o))}else{const a=w.asCID(r);a?yield[n.join("/"),a]:yield*Ha(r,n)}}return[]}};function Eg({repo:s}){async function*e(t={}){for await(const r of s.blocks.queryKeys({},{signal:t.signal}))yield{ref:r.toString()}}return E(e)}function vg({network:s}){async function e(t={}){const{bitswap:r}=await s.use(t),n=r.getWantlist();return Array.from(n).map(a=>a[1].cid)}return E(e)}function Dg({network:s}){async function e(t,r={}){const{bitswap:n}=await s.use(r),a=n.wantlistForPeer(t);return Array.from(a).map(i=>i[1].cid)}return E(e)}function Sg({network:s}){async function e(t,r={}){const{bitswap:n}=await s.use(r);return Array.isArray(t)||(t=[t]),n.unwant(t)}return E(e)}function vu({network:s}){async function e(t={}){const r=(await s.use(t)).bitswap,n=r.stat().snapshot;return{provideBufLen:parseInt(n.providesBufferLength.toString()),blocksReceived:BigInt(n.blocksReceived.toString()),wantlist:Array.from(r.getWantlist()).map(a=>a[1].cid),peers:r.peers(),dupBlksReceived:BigInt(n.dupBlksReceived.toString()),dupDataReceived:BigInt(n.dupDataReceived.toString()),dataReceived:BigInt(n.dataReceived.toString()),blocksSent:BigInt(n.blocksSent.toString()),dataSent:BigInt(n.dataSent.toString())}}return E(e)}class kg{constructor({network:e}){this.wantlist=vg({network:e}),this.wantlistForPeer=Dg({network:e}),this.unwant=Sg({network:e}),this.stat=vu({network:e})}}function Du(s){try{return Ky.matches(s)}catch{return!1}}function $g({repo:s}){async function e(t,r={}){if(!Du(t))throw new Error(`${t} is not a valid Multiaddr`);const n=await s.config.getAll(r),a=n.Bootstrap||[];return a.push(t.toString()),n.Bootstrap=Array.from(new Set(a)).sort((i,o)=>i.localeCompare(o)),await s.config.replace(n),{Peers:[t]}}return E(e)}function Pg({repo:s}){async function e(t={}){const r=await s.config.getAll(t),n=r.Bootstrap||[];return r.Bootstrap=[],await s.config.replace(r),{Peers:n.map(a=>ie(a))}}return E(e)}function Ag({repo:s}){async function e(t={}){return{Peers:(await s.config.get("Bootstrap",t)||[]).map(n=>ie(n))}}return E(e)}const Jt=()=>({Addresses:{Swarm:[],Announce:[],NoAnnounce:[],API:"",Gateway:"",RPC:"",Delegates:["/dns4/node0.delegate.ipfs.io/tcp/443/https","/dns4/node1.delegate.ipfs.io/tcp/443/https","/dns4/node2.delegate.ipfs.io/tcp/443/https","/dns4/node3.delegate.ipfs.io/tcp/443/https"]},Discovery:{MDNS:{Enabled:!1,Interval:10},webRTCStar:{Enabled:!0}},Bootstrap:["/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN","/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb","/dnsaddr/bootstrap.libp2p.io/p2p/QmZa1sAxajnQjVM8WjWXoMbmPd7NsWhfKsPkErzpm9wGkp","/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa","/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt","/dns4/node0.preload.ipfs.io/tcp/443/wss/p2p/QmZMxNdpMkewiVZLMRxaNxUeZpDUb34pWjZ1kZvsd16Zic","/dns4/node1.preload.ipfs.io/tcp/443/wss/p2p/Qmbut9Ywz9YEDrz8ySBSgWyJk41Uvm2QJPhwDJzJyGFsD6","/dns4/node2.preload.ipfs.io/tcp/443/wss/p2p/QmV7gnbW5VTcJ3oyM2Xk1rdFBJ3kTkvxc87UFGsun29STS","/dns4/node3.preload.ipfs.io/tcp/443/wss/p2p/QmY7JB6MQXhxHvq7dBDh4HpbH29v4yE9JRadAVpndvzySN"],Pubsub:{Enabled:!0},Swarm:{ConnMgr:{LowWater:5,HighWater:20},DisableNatPortMap:!0},Routing:{Type:"dhtclient"}});function Rg({repo:s}){async function e(t={}){const r=await s.config.getAll(t);return r.Bootstrap=Jt().Bootstrap,await s.config.replace(r),{Peers:Jt().Bootstrap.map(n=>ie(n))}}return E(e)}function Tg({repo:s}){async function e(t,r={}){if(!Du(t))throw new Error(`${t} is not a valid Multiaddr`);const n=await s.config.getAll(r);return n.Bootstrap=(n.Bootstrap||[]).filter(a=>a.toString()!==t.toString()),await s.config.replace(n),{Peers:[t]}}return E(e)}class Og{constructor({repo:e}){this.add=$g({repo:e}),this.list=Ag({repo:e}),this.rm=Tg({repo:e}),this.clear=Pg({repo:e}),this.reset=Rg({repo:e})}}function Cg({preload:s,repo:e}){async function t(r,n={}){return n.preload!==!1&&s(r),e.blocks.get(r,n)}return E(t)}function Ig({codecs:s,hashers:e,repo:t,preload:r}){async function n(a,i={}){const o=i.pin?await t.gcLock.readLock():null;try{const c=i.version!=null?i.version:0,l=i.format||(c===0?"dag-pb":"raw"),d=await(await e.getHasher(i.mhtype||"sha2-256")).digest(a),h=await s.getCodec(l),f=w.create(c,h.code,d);return await t.blocks.put(f,a,{signal:i.signal}),i.preload!==!1&&r(f),i.pin===!0&&await t.pins.pinRecursively(f,{signal:i.signal}),f}finally{o&&o()}}return E(n)}function Su(s){return s instanceof Uint8Array?w.decode(s):w.parse(s.toString())}const Ng=8;function xg({repo:s}){async function*e(t,r={}){Array.isArray(t)||(t=[t]);const n=await s.gcLock.writeLock();try{yield*it(t,a=>Ve(a,i=>async()=>{i=Su(i);const o={cid:i};try{if(!await s.blocks.has(i))throw y(new Error("block not found"),"ERR_BLOCK_NOT_FOUND");await s.blocks.delete(i)}catch(c){r.force||(c.message=`cannot remove ${i}: ${c.message}`,o.error=c)}return o}),a=>pl(a,{concurrency:Ng}),a=>gn(a,()=>!r.quiet))}finally{n()}}return E(e)}function Lg({repo:s,preload:e}){async function t(r,n={}){r=Su(r),n.preload!==!1&&e(r);const a=await s.blocks.get(r);return{cid:r,size:a.length}}return E(t)}class Bg{constructor({codecs:e,hashers:t,preload:r,repo:n}){this.get=Cg({preload:r,repo:n}),this.put=Ig({codecs:e,hashers:t,preload:r,repo:n}),this.rm=xg({repo:n}),this.stat=Lg({preload:r,repo:n})}}function mt(s){return ArrayBuffer.isView(s)||s instanceof ArrayBuffer}function Hr(s){return s.constructor&&(s.constructor.name==="Blob"||s.constructor.name==="File")&&typeof s.stream=="function"}function qa(s){return typeof s=="object"&&(s.path||s.content)}const qr=s=>s&&typeof s.getReader=="function";async function*ys(s){yield s}async function ku(s){if(mt(s))return ys(sa(s));if(typeof s=="string"||s instanceof String)return ys(sa(s.toString()));if(Hr(s))return Sh(s);if(qr(s)&&(s=Gr(s)),Symbol.iterator in s||Symbol.asyncIterator in s){const e=Qr(s),{value:t,done:r}=await e.peek();if(r)return ys(new Uint8Array(0));if(e.push(t),Number.isInteger(t))return ys(Uint8Array.from(await yi(e)));if(mt(t)||typeof t=="string"||t instanceof String)return Ve(e,sa)}throw y(new Error(`Unexpected input: ${s}`),"ERR_UNEXPECTED_INPUT")}function sa(s){return s instanceof Uint8Array?s:ArrayBuffer.isView(s)?new Uint8Array(s.buffer,s.byteOffset,s.byteLength):s instanceof ArrayBuffer?new Uint8Array(s):Array.isArray(s)?Uint8Array.from(s):Q(s.toString())}async function*jg(s,e){if(s==null)throw y(new Error(`Unexpected input: ${s}`),"ERR_UNEXPECTED_INPUT");if(typeof s=="string"||s instanceof String){yield ws(s.toString(),e);return}if(mt(s)||Hr(s)){yield ws(s,e);return}if(qr(s)&&(s=Gr(s)),Symbol.iterator in s||Symbol.asyncIterator in s){const t=Qr(s),{value:r,done:n}=await t.peek();if(n){yield{content:[]};return}if(t.push(r),Number.isInteger(r)||mt(r)||typeof r=="string"||r instanceof String){yield ws(t,e);return}throw y(new Error("Unexpected input: multiple items passed - if you are using ipfs.add, please use ipfs.addAll instead"),"ERR_UNEXPECTED_INPUT")}if(qa(s)){yield ws(s,e);return}throw y(new Error('Unexpected input: cannot convert "'+typeof s+'" into ImportCandidate'),"ERR_UNEXPECTED_INPUT")}async function ws(s,e){const{path:t,mode:r,mtime:n,content:a}=s,i={path:t||"",mode:Wt(r),mtime:Ur(n)};return a?i.content=await e(a):t||(i.content=await e(s)),i}function $u(s){return jg(s,ku)}function Mg({addAll:s}){async function e(t,r={}){const n=await Ce(s($u(t),r));if(n==null)throw Error("Failed to add a file, if you see this please report a bug");return n}return e}const On=vi({name:"murmur3-128",code:34,encode:s=>yf(kh.x64.hash128(s))});async function zg(s){return(await On.encode(s)).slice(0,8).reverse()}const Ug={chunker:"fixed",strategy:"balanced",rawLeaves:!1,onlyHash:!1,reduceSingleLeafToSelf:!0,hasher:me,leafType:"file",cidVersion:0,progress:()=>()=>{},shardSplitThreshold:1e3,fileImportConcurrency:50,blockWriteConcurrency:10,minChunkSize:262144,maxChunkSize:262144,avgChunkSize:262144,window:16,polynomial:0x3df305dfb2a804,maxChildrenPerNode:174,layerRepeat:4,wrapWithDirectory:!1,recursive:!1,hidden:!1,timeout:void 0,hamtHashFn:zg,hamtHashCode:34,hamtBucketBits:8},Fg=(s={})=>_e.bind({ignoreUndefined:!0})(Ug,s),tr=async(s,e,t)=>{t.codec||(t.codec=Xe),t.hasher||(t.hasher=me),t.cidVersion===void 0&&(t.cidVersion=1),t.codec===Xe&&t.hasher!==me&&(t.cidVersion=1);const r=await t.hasher.digest(s),n=w.create(t.cidVersion,t.codec.code,r);return t.onlyHash||await e.put(n,s,{signal:t.signal}),n},Hg=async(s,e,t)=>{const r=new G({type:"directory",mtime:s.mtime,mode:s.mode}),n=J(gt({Data:r.marshal()})),a=await tr(n,e,t),i=s.path;return{cid:a,path:i,unixfs:r,size:n.length}};async function qg(s,e){return e(await yi(s))}function Kg(s,e,t){return Pu(s,e,t)}async function Pu(s,e,t){const r=[];for await(const n of yl(s,t.maxChildrenPerNode))r.push(await e(n));return r.length>1?Pu(r,e,t):r[0]}async function Vg(s,e,t){const r=new Wg(t.layerRepeat);let n=0,a=1,i=r;for await(const o of yl(s,t.maxChildrenPerNode))i.isFull()&&(i!==r&&r.addChild(await i.reduce(e)),n&&n%t.layerRepeat===0&&a++,i=new Au(a,t.layerRepeat,n),n++),i.append(o);return i&&i!==r&&r.addChild(await i.reduce(e)),r.reduce(e)}class Au{constructor(e,t,r=0){this.maxDepth=e,this.layerRepeat=t,this.currentDepth=1,this.iteration=r,this.root=this.node=this.parent={children:[],depth:this.currentDepth,maxDepth:e,maxChildren:(this.maxDepth-this.currentDepth)*this.layerRepeat}}isFull(){if(!this.root.data)return!1;if(this.currentDepth<this.maxDepth&&this.node.maxChildren)return this._addNextNodeToParent(this.node),!1;const e=this._findParent(this.node,this.currentDepth);return e?(this._addNextNodeToParent(e),!1):!0}_addNextNodeToParent(e){this.parent=e;const t={children:[],depth:e.depth+1,parent:e,maxDepth:this.maxDepth,maxChildren:Math.floor(e.children.length/this.layerRepeat)*this.layerRepeat};e.children.push(t),this.currentDepth=t.depth,this.node=t}append(e){this.node.data=e}reduce(e){return this._reduce(this.root,e)}async _reduce(e,t){let r=[];return e.children.length&&(r=await Promise.all(e.children.filter(n=>n.data).map(n=>this._reduce(n,t)))),t((e.data||[]).concat(r))}_findParent(e,t){const r=e.parent;if(!(!r||r.depth===0))return r.children.length===r.maxChildren||!r.maxChildren?this._findParent(r,t):r}}class Wg extends Au{constructor(e){super(0,e),this.root.depth=0,this.currentDepth=1}addChild(e){this.root.children.push(e)}reduce(e){return e((this.root.data||[]).concat(this.root.children))}}async function*Jg(s,e,t){for await(let r of s.content)yield async()=>{t.progress(r.length,s.path);let n;const a={codec:Xe,cidVersion:t.cidVersion,hasher:t.hasher,onlyHash:t.onlyHash};return t.rawLeaves?(a.codec=Nl,a.cidVersion=1):(n=new G({type:t.leafType,data:r}),r=J({Data:n.marshal(),Links:[]})),{cid:await tr(r,e,a),unixfs:n,size:r.length}}}const Gg={flat:qg,balanced:Kg,trickle:Vg};async function*Qg(s,e,t){let r=-1,n,a;typeof t.bufferImporter=="function"?a=t.bufferImporter:a=Jg;for await(const i of wi(a(s,e,t),t.blockWriteConcurrency)){if(r++,r===0){n=i;continue}else r===1&&n&&(yield n,n=null);yield i}n&&(n.single=!0,yield n)}const Xg=(s,e,t)=>{async function r(n){if(n.length===1&&n[0].single&&t.reduceSingleLeafToSelf){const u=n[0];if(s.mtime!==void 0||s.mode!==void 0){let d=await e.get(u.cid);u.unixfs=new G({type:"file",mtime:s.mtime,mode:s.mode,data:d}),d=J(gt({Data:u.unixfs.marshal()})),u.cid=await tr(d,e,{...t,codec:Xe,hasher:t.hasher,cidVersion:t.cidVersion}),u.size=d.length}return{cid:u.cid,path:s.path,unixfs:u.unixfs,size:u.size}}const a=new G({type:"file",mtime:s.mtime,mode:s.mode}),i=n.filter(u=>u.cid.code===bt&&u.size||u.unixfs&&!u.unixfs.data&&u.unixfs.fileSize()?!0:!!(u.unixfs&&u.unixfs.data&&u.unixfs.data.length)).map(u=>u.cid.code===bt?(a.addBlockSize(u.size),{Name:"",Tsize:u.size,Hash:u.cid}):(!u.unixfs||!u.unixfs.data?a.addBlockSize(u.unixfs&&u.unixfs.fileSize()||0):a.addBlockSize(u.unixfs.data.length),{Name:"",Tsize:u.size,Hash:u.cid})),o={Data:a.marshal(),Links:i},c=J(gt(o));return{cid:await tr(c,e,t),path:s.path,unixfs:a,size:c.length+o.Links.reduce((u,d)=>u+d.Tsize,0)}}return r};function Yg(s,e,t){const r=Gg[t.strategy];if(!r)throw y(new Error(`Unknown importer build strategy name: ${t.strategy}`),"ERR_BAD_STRATEGY");return r(Qg(s,e,t),Xg(s,e,t),t)}async function*Zg(s,e){let t,r,n;if(e.minChunkSize&&e.maxChunkSize&&e.avgChunkSize)n=e.avgChunkSize,t=e.minChunkSize,r=e.maxChunkSize;else if(e.avgChunkSize)n=e.avgChunkSize,t=n/3,r=n+n/2;else throw y(new Error("please specify an average chunk size"),"ERR_INVALID_AVG_CHUNK_SIZE");if(t<16)throw y(new Error("rabin min must be greater than 16"),"ERR_INVALID_MIN_CHUNK_SIZE");r<t&&(r=t),n<t&&(n=t);const a=Math.floor(Math.log2(n));for await(const i of eb(s,{min:t,max:r,bits:a,window:e.window,polynomial:e.polynomial}))yield i}async function*eb(s,e){const t=await $h.create(e.bits,e.min,e.max,e.window),r=new Ns;for await(const n of s){r.append(n);const a=t.fingerprint(n);for(let i=0;i<a.length;i++){const o=a[i],c=r.slice(0,o);r.consume(o),yield c}}r.length&&(yield r.subarray(0))}async function*tb(s,e){let t=new Ns,r=0,n=!1;const a=e.maxChunkSize;for await(const i of s)for(t.append(i),r+=i.length;r>=a;)if(yield t.slice(0,a),n=!0,a===t.length)t=new Ns,r=0;else{const o=new Ns;o.append(t.sublist(a)),t=o,r-=a}(!n||r)&&(yield t.subarray(0,r))}async function*rb(s){for await(const e of s){if(e.length===void 0)throw y(new Error("Content was invalid"),"ERR_INVALID_CONTENT");if(typeof e=="string"||e instanceof String)yield Q(e.toString());else if(Array.isArray(e))yield Uint8Array.from(e);else if(e instanceof Uint8Array)yield e;else throw y(new Error("Content was invalid"),"ERR_INVALID_CONTENT")}}function sb(s){return Symbol.iterator in s}function nb(s){return Symbol.asyncIterator in s}function ab(s){try{if(s instanceof Uint8Array)return async function*(){yield s}();if(sb(s))return async function*(){yield*s}();if(nb(s))return s}catch{throw y(new Error("Content was invalid"),"ERR_INVALID_CONTENT")}throw y(new Error("Content was invalid"),"ERR_INVALID_CONTENT")}async function*ib(s,e,t){for await(const r of s)if(r.path&&(r.path.substring(0,2)==="./"&&(t.wrapWithDirectory=!0),r.path=r.path.split("/").filter(n=>n&&n!==".").join("/")),r.content){let n;typeof t.chunker=="function"?n=t.chunker:t.chunker==="rabin"?n=Zg:n=tb;let a;typeof t.chunkValidator=="function"?a=t.chunkValidator:a=rb;const i={path:r.path,mtime:r.mtime,mode:r.mode,content:n(a(ab(r.content),t),t)};yield()=>Yg(i,e,t)}else if(r.path){const n={path:r.path,mtime:r.mtime,mode:r.mode};yield()=>Hg(n,e,t)}else throw new Error("Import candidate must have content or path or both")}let Kr=class{constructor(e,t){this.options=t||{},this.root=e.root,this.dir=e.dir,this.path=e.path,this.dirty=e.dirty,this.flat=e.flat,this.parent=e.parent,this.parentKey=e.parentKey,this.unixfs=e.unixfs,this.mode=e.mode,this.mtime=e.mtime,this.cid=void 0,this.size=void 0}async put(e,t){}get(e){return Promise.resolve(this)}async*eachChildSeries(){}async*flush(e){}};class Ni extends Kr{constructor(e,t){super(e,t),this._children={}}async put(e,t){this.cid=void 0,this.size=void 0,this._children[e]=t}get(e){return Promise.resolve(this._children[e])}childCount(){return Object.keys(this._children).length}directChildrenCount(){return this.childCount()}onlyChild(){return this._children[Object.keys(this._children)[0]]}async*eachChildSeries(){const e=Object.keys(this._children);for(let t=0;t<e.length;t++){const r=e[t];yield{key:r,child:this._children[r]}}}async*flush(e){const t=Object.keys(this._children),r=[];for(let l=0;l<t.length;l++){let u=this._children[t[l]];if(u instanceof Kr)for await(const d of u.flush(e))u=d,yield u;u.size!=null&&u.cid&&r.push({Name:t[l],Tsize:u.size,Hash:u.cid})}const n=new G({type:"directory",mtime:this.mtime,mode:this.mode}),a={Data:n.marshal(),Links:r},i=J(gt(a)),o=await tr(i,e,this.options),c=i.length+a.Links.reduce((l,u)=>l+(u.Tsize==null?0:u.Tsize),0);this.cid=o,this.size=c,yield{cid:o,unixfs:n,path:this.path,size:c}}}let ob=class extends Kr{constructor(e,t){super(e,t),this._bucket=bn({hashFn:t.hamtHashFn,bits:t.hamtBucketBits})}async put(e,t){await this._bucket.put(e,t)}get(e){return this._bucket.get(e)}childCount(){return this._bucket.leafCount()}directChildrenCount(){return this._bucket.childrenCount()}onlyChild(){return this._bucket.onlyChild()}async*eachChildSeries(){for await(const{key:e,value:t}of this._bucket.eachLeafSeries())yield{key:e,child:t}}async*flush(e){for await(const t of Ru(this._bucket,e,this,this.options))yield{...t,path:this.path}}};async function*Ru(s,e,t,r){const n=s._children,a=[];let i=0;for(let f=0;f<n.length;f++){const p=n.get(f);if(!p)continue;const g=f.toString(16).toUpperCase().padStart(2,"0");if(p instanceof nr){let _;for await(const v of await Ru(p,e,null,r))_=v;if(!_)throw new Error("Could not flush sharded directory, no subshard found");a.push({Name:g,Tsize:_.size,Hash:_.cid}),i+=_.size}else if(typeof p.value.flush=="function"){const _=p.value;let v;for await(const P of _.flush(e))v=P,yield v;const k=g+p.key;a.push({Name:k,Tsize:v.size,Hash:v.cid}),i+=v.size}else{const _=p.value;if(!_.cid)continue;const v=g+p.key,k=_.size;a.push({Name:v,Tsize:k,Hash:_.cid}),i+=k}}const o=Uint8Array.from(n.bitField().reverse()),c=new G({type:"hamt-sharded-directory",data:o,fanout:s.tableSize(),hashType:r.hamtHashCode,mtime:t&&t.mtime,mode:t&&t.mode}),l={Data:c.marshal(),Links:a},u=J(gt(l)),d=await tr(u,e,r),h=u.length+i;yield{cid:d,unixfs:c,size:h}}async function Tu(s,e,t,r){let n=e;e instanceof Ni&&e.directChildrenCount()>=t&&(n=await cb(e,r));const a=n.parent;if(a){if(n!==e){if(s&&(s.parent=n),!n.parentKey)throw new Error("No parent key found");await a.put(n.parentKey,n)}return Tu(n,a,t,r)}return n}async function cb(s,e){const t=new ob({root:s.root,dir:!0,parent:s.parent,parentKey:s.parentKey,path:s.path,dirty:s.dirty,flat:!1,mtime:s.mtime,mode:s.mode},e);for await(const{key:r,child:n}of s.eachChildSeries())await t.put(r,n);return t}const lb=(s="")=>(s.trim().match(/([^\\/]|\\\/)+/g)||[]).filter(Boolean);async function ub(s,e,t){const r=lb(s.path||""),n=r.length-1;let a=e,i="";for(let o=0;o<r.length;o++){const c=r[o];i+=`${i?"/":""}${c}`;const l=o===n;if(a.dirty=!0,a.cid=void 0,a.size=void 0,l)await a.put(c,s),e=await Tu(null,a,t.shardSplitThreshold,t);else{let u=await a.get(c);(!u||!(u instanceof Kr))&&(u=new Ni({root:!1,dir:!0,parent:a,parentKey:c,path:i,dirty:!0,flat:!0,mtime:u&&u.unixfs&&u.unixfs.mtime,mode:u&&u.unixfs&&u.unixfs.mode},t)),await a.put(c,u),a=u}}return e}async function*Yo(s,e){if(!(s instanceof Kr)){s&&s.unixfs&&s.unixfs.isDirectory()&&(yield s);return}yield*s.flush(e)}async function*db(s,e,t){let r=new Ni({root:!0,dir:!0,path:"",dirty:!0,flat:!0},t);for await(const n of s)n&&(r=await ub(n,r,t),(!n.unixfs||!n.unixfs.isDirectory())&&(yield n));if(t.wrapWithDirectory)yield*Yo(r,e);else for await(const n of r.eachChildSeries())n&&(yield*Yo(n.child,e))}async function*xi(s,e,t={}){const r=Fg(t);let n;typeof t.dagBuilder=="function"?n=t.dagBuilder:n=ib;let a;typeof t.treeBuilder=="function"?a=t.treeBuilder:a=db;let i;Symbol.asyncIterator in s||Symbol.iterator in s?i=s:i=[s];for await(const o of a(wi(n(i,e,r),r.fileImportConcurrency),e,r))yield{cid:o.cid,path:o.path,unixfs:o.unixfs,size:o.size}}async function*Ou(s,e){if(typeof s=="string"||s instanceof String||mt(s)||Hr(s)||s._readableState)throw y(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"),"ERR_UNEXPECTED_INPUT");if(qr(s)&&(s=Gr(s)),Symbol.iterator in s||Symbol.asyncIterator in s){const t=Qr(s),{value:r,done:n}=await t.peek();if(n){yield*[];return}if(t.push(r),Number.isInteger(r))throw y(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"),"ERR_UNEXPECTED_INPUT");if(r._readableState){yield*Ve(t,a=>na({content:a},e));return}if(mt(r)){yield na({content:t},e);return}if(qa(r)||r[Symbol.iterator]||r[Symbol.asyncIterator]||qr(r)||Hr(r)){yield*Ve(t,a=>na(a,e));return}}throw qa(s)?y(new Error("Unexpected input: single item passed - if you are using ipfs.addAll, please use ipfs.add instead"),"ERR_UNEXPECTED_INPUT"):y(new Error("Unexpected input: "+typeof s),"ERR_UNEXPECTED_INPUT")}async function na(s,e){const{path:t,mode:r,mtime:n,content:a}=s,i={path:t||"",mode:Wt(r),mtime:Ur(n)};return a?i.content=await e(a):t||(i.content=await e(s)),i}function hb(s){return Ou(s,ku)}const fb=s=>{if(s)if(s.startsWith("size-")){const e=s.split("-")[1],t=parseInt(e);if(isNaN(t))throw new Error("Chunker parameter size must be an integer");return{chunker:"fixed",maxChunkSize:t}}else{if(s.startsWith("rabin"))return{chunker:"rabin",...pb(s)};throw new Error(`Unrecognized chunker option: ${s}`)}else return{chunker:"fixed"}},pb=s=>{const e={},t=s.split("-");switch(t.length){case 1:e.avgChunkSize=262144;break;case 2:e.avgChunkSize=gs(t[1],"avg");break;case 4:e.minChunkSize=gs(t[1],"min"),e.avgChunkSize=gs(t[2],"avg"),e.maxChunkSize=gs(t[3],"max");break;default:throw new Error('Incorrect chunker format (expected "rabin" "rabin-[avg]" or "rabin-[min]-[avg]-[max]"')}return e},gs=(s,e)=>{const t=parseInt(s);if(isNaN(t))throw new Error(`Chunker parameter ${e} must be an integer`);return t},yb=_e.bind({ignoreUndefined:!0});function wb({repo:s,preload:e,hashers:t,options:r}){const n=r&&r.sharding;async function*a(i,o={}){const c=yb({shardSplitThreshold:n?1e3:1/0,strategy:"balanced"},o,{...fb(o.chunker)});c.hashAlg&&c.hashAlg!=="sha2-256"&&c.cidVersion!==1&&(c.cidVersion=1),c.trickle&&(c.strategy="trickle"),c.strategy==="trickle"&&(c.leafType="raw",c.reduceSingleLeafToSelf=!1),c.cidVersion>0&&c.rawLeaves===void 0&&(c.rawLeaves=!0),c.hashAlg!==void 0&&c.rawLeaves===void 0&&(c.rawLeaves=!0),delete c.trickle;const l={};if(c.progress){const f=c.progress;c.progress=(p,g)=>{l[g]||(l[g]=0),l[g]+=p,f(l[g],g)}}let u;c.hashAlg!=null&&(u=await t.getHasher(c.hashAlg));const d=it(hb(i),f=>xi(f,s.blocks,{...c,hasher:u,pin:!1}),gb(c),bb(e,c),mb(s,c)),h=await s.gcLock.readLock();try{for await(const f of d){const p=f.path??f.cid.toString();delete l[p],yield{...f,path:p}}}finally{h()}}return E(a)}function gb(s){async function*e(t){for await(const r of t){let n=r.cid;s.cidVersion===1&&(n=n.toV1());let a=r.path?r.path:n.toString();s.wrapWithDirectory&&!r.path&&(a=""),yield{path:a,cid:n,size:r.size,mode:r.unixfs&&r.unixfs.mode,mtime:r.unixfs&&r.unixfs.mtime}}}return e}function bb(s,e){async function*t(r){for await(const n of r)(!n.path||e.wrapWithDirectory?n.path==="":!n.path.includes("/"))&&!e.onlyHash&&e.preload!==!1&&s(n.cid),yield n}return t}function mb(s,e){async function*t(r){for await(const n of r){const a=!(n.path&&n.path.includes("/"));(e.pin==null?!0:e.pin)&&a&&!e.onlyHash&&await s.pins.pinRecursively(n.cid),yield n}}return t}const _b=async function(s){return(await On.encode(s)).slice(0,8).reverse()},Eb=(s,e,t)=>Promise.all(s.map(r=>{if(r.Name==null)throw new Error("Unexpected Link without a Name");if(r.Name.length===2){const n=parseInt(r.Name,16);return e._putObjectAt(n,new nr({hash:t._options.hash,bits:t._options.bits},e,n))}return t.put(r.Name.substring(2),!0)})),Zo=s=>s.toString(16).toUpperCase().padStart(2,"0").substring(0,2),vb=s=>{let e=s.bucket;const t=[];for(;e._parent;)t.push(e),e=e._parent;return t.push(e),t.reverse()},Cu=async(s,e,t,r,n)=>{if(!r){const u=bn({hashFn:_b});r={rootBucket:u,hamtDepth:1,lastBucket:u}}await Eb(s.Links,r.lastBucket,r.rootBucket);const a=await r.rootBucket._findNewBucketAndPos(e);let i=Zo(a.pos);const o=vb(a);o.length>r.hamtDepth&&(r.lastBucket=o[r.hamtDepth],i=Zo(r.lastBucket._posAtParent));const c=s.Links.find(u=>{if(u.Name==null)return!1;const d=u.Name.substring(0,2),h=u.Name.substring(2);return!(d!==i||h&&h!==e)});if(!c)return null;if(c.Name!=null&&c.Name.substring(2)===e)return c.Hash;r.hamtDepth++;const l=await t.get(c.Hash,n);return s=le(l),Cu(s,e,t,r,n)};function tn(s,e,t,r){const n=s.length,a=e+n;return t>=a||r<e?new Uint8Array(0):(r>=e&&r<a&&(s=s.subarray(0,r-e)),t>=e&&t<a&&(s=s.subarray(t-e)),s)}const Li=(s,e,t)=>{if(e||(e=0),e<0)throw y(new Error("Offset must be greater than or equal to 0"),"ERR_INVALID_PARAMS");if(e>s)throw y(new Error("Offset must be less than the file size"),"ERR_INVALID_PARAMS");if(!t&&t!==0&&(t=s-e),t<0)throw y(new Error("Length must be greater than or equal to 0"),"ERR_INVALID_PARAMS");return e+t>s&&(t=s-e),{offset:e,length:t}};async function Iu(s,e,t,r,n,a,i,o){if(e instanceof Uint8Array){t.push(tn(e,r,n,a));return}if(e.Data==null)throw y(new Error("no data in PBNode"),"ERR_NOT_UNIXFS");let c;try{c=G.unmarshal(e.Data)}catch(u){throw y(u,"ERR_NOT_UNIXFS")}if(c.data!=null){const u=c.data,d=tn(u,r,n,a);t.push(d),r+=d.byteLength}const l=[];for(let u=0;u<e.Links.length;u++){const d=e.Links[u],h=r,f=h+c.blockSizes[u];if((n>=h&&n<f||a>=h&&a<=f||n<h&&a>f)&&l.push({link:d,blockStart:r}),r=f,r>a)break}await it(l,u=>Ve(u,d=>async()=>{const h=await s.get(d.link.Hash,{signal:o.signal});return{...d,block:h}}),u=>pl(u,{ordered:!0}),async u=>{for await(const{link:d,block:h,blockStart:f}of u){let p;switch(d.Hash.code){case V:p=le(h);break;case bt:p=h;break;default:t.end(y(new Error(`Unsupported codec: ${d.Hash.code}`),"ERR_NOT_UNIXFS"));return}i.add(async()=>{await Iu(s,p,t,f,n,a,i,o)})}})}const ec=(s,e,t,r,n,a,i)=>{async function*o(c={}){const l=t.fileSize();if(l===void 0)throw new Error("File was a directory");const{offset:u,length:d}=Li(l,c.offset,c.length);if(d===0)return;const h=new Ue({concurrency:1}),f=Fs();h.add(async()=>{await Iu(i,e,f,0,u,u+d,h,c)}),h.on("error",g=>{f.end(g)});let p=0;for await(const g of f)g!=null&&(p+=g.byteLength,p===d&&f.end(),yield g)}return o},Db=(s,e,t,r,n,a,i)=>{async function*o(c={}){const l=c.offset||0,u=c.length||e.Links.length,d=e.Links.slice(l,u);for(const h of d){const f=await n(h.Hash,h.Name||"",`${r}/${h.Name||""}`,[],a+1,i,c);f.entry&&(yield f.entry)}}return o},Sb=(s,e,t,r,n,a,i)=>{function o(c={}){return Nu(e,r,n,a,i,c)}return o};async function*Nu(s,e,t,r,n,a){const i=s.Links;for(const o of i){const c=o.Name!=null?o.Name.substring(2):null;if(c)yield(await t(o.Hash,c,`${e}/${c}`,[],r+1,n,a)).entry;else{const l=await n.get(o.Hash);s=le(l);for await(const u of Nu(s,e,t,r,n,a))yield u}}}const kb=(s,e)=>{const t=s.Links.find(r=>r.Name===e);return t&&t.Hash},$b={raw:ec,file:ec,directory:Db,"hamt-sharded-directory":Sb,metadata:(s,e,t,r,n,a,i)=>()=>[],symlink:(s,e,t,r,n,a,i)=>()=>[]},Pb=async(s,e,t,r,n,a,i,o)=>{const c=await i.get(s,o),l=le(c);let u,d;if(e||(e=s.toString()),l.Data==null)throw y(new Error("no data in PBNode"),"ERR_NOT_UNIXFS");try{u=G.unmarshal(l.Data)}catch(h){throw y(h,"ERR_NOT_UNIXFS")}if(t||(t=e),r.length){let h;if(u&&u.type==="hamt-sharded-directory"?h=await Cu(l,r[0],i):h=kb(l,r[0]),!h)throw y(new Error("file does not exist"),"ERR_NOT_FOUND");const f=r.shift(),p=`${t}/${f}`;d={cid:h,toResolve:r,name:f||"",path:p}}return{entry:{type:u.isDirectory()?"directory":"file",name:e,path:t,cid:s,content:$b[u.type](s,l,u,t,n,a,i),unixfs:u,depth:a,node:l,size:u.fileSize()},next:d}},Ab=s=>{async function*e(t={}){const{offset:r,length:n}=Li(s.length,t.offset,t.length);yield tn(s,0,r,r+n)}return e},Rb=async(s,e,t,r,n,a,i,o)=>{if(r.length)throw y(new Error(`No link named ${t} found in raw node ${s}`),"ERR_NOT_FOUND");const c=await i.get(s,o);return{entry:{type:"raw",name:e,path:t,cid:s,content:Ab(c),depth:a,size:c.length,node:c}}},Tb=async(s,e,t,r,n,a,i,o)=>{const c=await i.get(s),l=Ph(c);let u=l,d=t;for(;r.length;){const h=r[0];if(h in u){r.shift(),d=`${d}/${h}`;const f=w.asCID(u[h]);if(f)return{entry:{type:"object",name:e,path:t,cid:s,node:c,depth:a,size:c.length,content:async function*(){yield l}},next:{cid:f,name:h,path:d,toResolve:r}};u=u[h]}else throw y(new Error(`No property named ${h} found in cbor node ${s}`),"ERR_NO_PROP")}return{entry:{type:"object",name:e,path:t,cid:s,node:c,depth:a,size:c.length,content:async function*(){yield l}}}},Ob=s=>{async function*e(t={}){const{offset:r,length:n}=Li(s.length,t.offset,t.length);yield tn(s,0,r,r+n)}return e},Cb=async(s,e,t,r,n,a,i,o)=>{if(r.length)throw y(new Error(`No link named ${t} found in raw node ${s}`),"ERR_NOT_FOUND");const c=await Et(s.multihash.bytes);return{entry:{type:"identity",name:e,path:t,cid:s,content:Ob(c.digest),depth:a,size:c.digest.length,node:c.digest}}},Ib={[V]:Pb,[bt]:Rb,[Xr]:Tb,[Rt.code]:Cb};function xu(s,e,t,r,n,a,i){const o=Ib[s.code];if(!o)throw y(new Error(`No resolver for code ${s.code}`),"ERR_NO_RESOLVER");return o(s,e,t,r,xu,n,a,i)}const Nb=(s="")=>(s.trim().match(/([^\\^/]|\\\/)+/g)||[]).filter(Boolean),xb=s=>{if(s instanceof Uint8Array)return{cid:w.decode(s),toResolve:[]};const e=w.asCID(s);if(e)return{cid:e,toResolve:[]};if(typeof s=="string"){s.indexOf("/ipfs/")===0&&(s=s.substring(6));const t=Nb(s);return{cid:w.parse(t[0]),toResolve:t.slice(1)}}throw y(new Error(`Unknown path type ${s}`),"ERR_BAD_PATH")};async function*Lu(s,e,t={}){let{cid:r,toResolve:n}=xb(s),a=r.toString(),i=a;const o=n.length;for(;;){const c=await xu(r,a,i,n,o,e,t);if(!c.entry&&!c.next)throw y(new Error(`Could not resolve ${s}`),"ERR_NOT_FOUND");if(c.entry&&(yield c.entry),!c.next)return;n=c.next.toResolve,r=c.next.cid,a=c.next.name,i=c.next.path}}async function lt(s,e,t={}){const r=await Ce(Lu(s,e,t));if(!r)throw y(new Error(`Could not resolve ${s}`),"ERR_NOT_FOUND");return r}async function*Bu(s,e,t={}){const r=await lt(s,e,t);if(!r)return;if(yield r,r.type==="directory")for await(const a of n(r,t))yield a;async function*n(a,i){for await(const o of a.content(i))yield o,!(o instanceof Uint8Array)&&o.type==="directory"&&(yield*n(o,i))}}function Lb({repo:s,preload:e}){async function*t(r,n={}){if(r=Oi(r),n.preload!==!1){const i=r.split("/");e(w.parse(i[0]))}const a=await lt(r,s.blocks,n);if(a.type==="directory")throw new Error("this dag node is a directory");if(!a.content)throw new Error("this dag node has no content");yield*a.content(n)}return E(t)}const tc=6;function Bb({repo:s,preload:e}){async function*t(r,n={}){if(n.compressionLevel!=null&&(n.compressionLevel<-1||n.compressionLevel>9))throw y(new Error("Compression level must be between -1 and 9"),"ERR_INVALID_PARAMS");if(n.preload!==!1){let o;try{o=Oi(r).split("/")}catch(c){throw y(c,"ERR_INVALID_PATH")}e(w.parse(o[0]))}const a=w.asCID(r)||r,i=await lt(a,s.blocks,n);if(i.type==="file"||i.type==="raw"){const o=[];!n.compress||n.archive===!0?o.push([{header:{name:i.path,mode:i.type==="file"&&i.unixfs.mode,mtime:i.type==="file"&&i.unixfs.mtime?new Date(i.unixfs.mtime.secs*1e3):void 0,size:i.size,type:"file"},body:i.content()}],co()):o.push(i.content),n.compress&&o.push(async function*(c){const l=await lo(c);yield uo.gzip(l,{level:n.compressionLevel||tc})}),yield*it(...o);return}if(i.type==="directory"){const o=[Bu(a,s.blocks,n),async function*(c){for await(const l of c){const u={header:{name:l.path,size:l.size}};if(l.type==="file")u.header.type="file",u.header.mode=l.unixfs.mode!=null?l.unixfs.mode:void 0,u.header.mtime=l.unixfs.mtime?new Date(l.unixfs.mtime.secs*1e3):void 0,u.body=l.content();else if(l.type==="raw")u.header.type="file",u.body=l.content();else if(l.type==="directory")u.header.type="directory",u.header.mode=l.unixfs.mode!=null?l.unixfs.mode:void 0,u.header.mtime=l.unixfs.mtime?new Date(l.unixfs.mtime.secs*1e3):void 0;else throw y(new Error("Not a UnixFS node"),"ERR_NOT_UNIXFS");yield u}},co()];if(n.compress){if(!n.archive)throw y(new Error("file is not regular"),"ERR_INVALID_PATH");n.compress&&o.push(async function*(c){const l=await lo(c);yield uo.gzip(l,{level:n.compressionLevel||tc})})}yield*it(...o);return}throw y(new Error("Not a UnixFS node"),"ERR_NOT_UNIXFS")}return E(t)}function jb({repo:s,preload:e}){async function*t(r,n={}){const a=Oi(r),i=a.split("/");n.preload!==!1&&e(w.parse(i[0]));const o=w.asCID(a)||a,c=await lt(o,s.blocks,n);if(c.type==="file"){yield Uo(c);return}if(c.type==="directory"){for await(const l of c.content())yield Uo(l);return}throw y(new Error(`Unknown UnixFS type ${c.type}`),"ERR_UNKNOWN_UNIXFS_TYPE")}return E(t)}class Mb{constructor({preload:e,repo:t,hashers:r,options:n}){const a=wb({preload:e,repo:t,options:n,hashers:r});this.addAll=a,this.add=Mg({addAll:a}),this.cat=Lb({repo:t,preload:e}),this.get=Bb({repo:t,preload:e}),this.ls=jb({repo:t,preload:e})}}const Ka="0.18.0",zb="",Ub="^0.158.0";function Fb({repo:s}){async function e(t={}){const r=await s.version.get();return{version:Ka,commit:zb,repo:`${r}`,"ipfs-core":Ka,"interface-ipfs-core":Ub}}return E(e)}const Hb=M("ipfs:components:id");function qb({peerId:s,network:e}){async function t(r={}){const n=e.try();if(!n){if(r.peerId)throw new rs;if(s.publicKey==null)throw y(new Error("Public key missing"),"ERR_MISSING_PUBLIC_KEY");return{id:s,publicKey:R(s.publicKey,"base64pad"),addresses:[],agentVersion:`js-ipfs/${Ka}`,protocolVersion:"9000",protocols:[]}}const{libp2p:a}=n,i=r.peerId?r.peerId:s,o=await Kb(i,a,r),c=R(o.metadata.get("AgentVersion")||new Uint8Array),l=R(o.metadata.get("ProtocolVersion")||new Uint8Array),u=o.id.toString(),d=o.publicKey?R(o.publicKey,"base64pad"):"";return{id:i,publicKey:d,addresses:(o.addresses||[]).map(h=>{const f=h.toString();return f.endsWith(`/p2p/${u}`)?f:`${f}/p2p/${u}`}).sort().map(h=>ie(h)),agentVersion:c,protocolVersion:l,protocols:(o.protocols||[]).sort()}}return E(t)}async function Kb(s,e,t){let r=await e.peerStore.get(s);r||(r=await Vb(s,e,t));let n=s.publicKey?s.publicKey:await e.peerStore.keyBook.get(s);if(n==null)try{n=await e.getPublicKey(s,t)}catch(a){Hb.error("Could not load public key for",s.toString(),a)}return{...r,publicKey:n,metadata:r.metadata||new Map,addresses:r.addresses.map(a=>a.multiaddr)}}async function Vb(s,e,t){if(e.dht==null)throw y(new Error("dht not configured"),"ERR_DHT_NOT_CONFIGURED");for await(const n of e.dht.findPeer(s,t))if(n.name==="FINAL_PEER")break;const r=await e.peerStore.get(s);if(!r)throw y(new Error("Could not find peer"),"ERR_NOT_FOUND");return r}const rn={server:{description:"Recommended for nodes with public IPv4 address (servers, VPSes, etc.), disables host and content discovery and UPnP in local networks.",transform:s=>(re(s,"Discovery.MDNS.Enabled",!1),re(s,"Discovery.webRTCStar.Enabled",!1),s.Swarm={...s.Swarm||{},DisableNatPortMap:!0},s)},"local-discovery":{description:"Sets default values to fields affected by `server` profile, enables discovery and UPnP in local networks.",transform:s=>(re(s,"Discovery.MDNS.Enabled",!0),re(s,"Discovery.webRTCStar.Enabled",!0),re(s,"Swarm",{...s.Swarm||{},DisableNatPortMap:!1}),s)},test:{description:"Reduces external interference, useful for running ipfs in test environments. Note that with these settings node won't be able to talk to the rest of the network without manual bootstrap.",transform:s=>{const e=Jt();return re(s,"Addresses.API",e.Addresses.API?"/ip4/127.0.0.1/tcp/0":""),re(s,"Addresses.Gateway",e.Addresses.Gateway?"/ip4/127.0.0.1/tcp/0":""),re(s,"Addresses.Swarm",e.Addresses.Swarm.length?["/ip4/127.0.0.1/tcp/0"]:[]),re(s,"Addresses.Delegates",[]),re(s,"Bootstrap",[]),re(s,"Discovery.MDNS.Enabled",!1),re(s,"Discovery.webRTCStar.Enabled",!1),re(s,"Swarm",{...s.Swarm||{},DisableNatPortMap:!0}),s}},"default-networking":{description:"Restores default network settings. Inverse profile of the `test` profile.",transform:s=>{const e=Jt();return re(s,"Addresses.API",e.Addresses.API),re(s,"Addresses.Gateway",e.Addresses.Gateway),re(s,"Addresses.Swarm",e.Addresses.Swarm),re(s,"Addresses.Delegates",e.Addresses.Delegates),re(s,"Bootstrap",e.Bootstrap),re(s,"Discovery.MDNS.Enabled",e.Discovery.MDNS.Enabled),re(s,"Discovery.webRTCStar.Enabled",e.Discovery.webRTCStar.Enabled),re(s,"Swarm",{...s.Swarm||{},DisableNatPortMap:!1}),s}},lowpower:{description:"Reduces daemon overhead on the system. May affect node functionality,performance of content discovery and data fetching may be degraded. Recommended for low power systems.",transform:s=>{const e=s.Swarm||{},t=e.ConnMgr||{};return t.LowWater=20,t.HighWater=40,e.ConnMgr=t,s.Swarm=e,s}},"default-power":{description:'Inverse of "lowpower" profile.',transform:s=>{const e=Jt();return s.Swarm=e.Swarm,s}}},Wb=M("ipfs:core:config");function Jb({repo:s}){return{getAll:E(e),get:E(t),set:E(r),replace:E(n),profiles:{apply:E(a),list:E(Gb)}};async function e(i={}){return s.config.getAll(i)}async function t(i,o){return i?s.config.get(i,o):Promise.reject(new Error("key argument is required"))}async function r(i,o,c){return s.config.set(i,o,c)}async function n(i,o){return s.config.replace(i,o)}async function a(i,o={dryRun:!1}){const{dryRun:c}=o,l=rn[i];if(!l)throw new Error(`No profile with name '${i}' exists`);try{const u=await s.config.getAll(o);let d=JSON.parse(JSON.stringify(u));return d=l.transform(d),c||await s.config.replace(d,o),delete u.Identity.PrivKey,delete d.Identity.PrivKey,{original:u,updated:d}}catch(u){throw Wb(u),new Error(`Could not apply profile '${i}' to config: ${u.message}`)}}}async function Gb(s){return Object.keys(rn).map(e=>({name:e,description:rn[e].description}))}function bs({enumerable:s=!0,configurable:e=!1}={}){return{enumerable:s,configurable:e,writable:!1}}function*Qb(s,e){if(e!=null&&typeof e=="object")if(Array.isArray(e))for(const[t,r]of e.entries()){const n=[...s,t],a=w.asCID(r);a?yield[n.join("/"),a]:typeof r=="object"&&(yield*Va(r,n))}else{const t=w.asCID(e);t?yield[s.join("/"),t]:yield*Va(e,s)}}function*Va(s,e){if(s==null||s instanceof Uint8Array)return;const t=w.asCID(s);t&&(yield[e.join("/"),t]);for(const[r,n]of Object.entries(s)){const a=[...e,r];yield*Qb(a,n)}}function*Xb(s,e){if(Array.isArray(e))for(const[t,r]of e.entries()){const n=[...s,t];yield n.join("/"),typeof r=="object"&&!w.asCID(r)&&(yield*Wa(r,n))}else yield*Wa(e,s)}function*Wa(s,e){if(!(s==null||typeof s!="object"))for(const[t,r]of Object.entries(s)){const n=[...e,t];yield n.join("/"),r!=null&&!(r instanceof Uint8Array)&&typeof r=="object"&&!w.asCID(r)&&(yield*Xb(n,r))}}function Yb(s,e){let t=s;for(const[r,n]of e.entries()){if(t=t[n],t==null)throw new Error(`Object has no property at ${e.slice(0,r+1).map(i=>`[${JSON.stringify(i)}]`).join("")}`);const a=w.asCID(t);if(a)return{value:a,remaining:e.slice(r+1).join("/")}}return{value:t}}let Bi=class{constructor({cid:e,bytes:t,value:r}){if(!e||!t||typeof r>"u")throw new Error("Missing required argument");this.cid=e,this.bytes=t,this.value=r,this.asBlock=this,Object.defineProperties(this,{cid:bs(),bytes:bs(),value:bs(),asBlock:bs()})}links(){return Va(this.value,[])}tree(){return Wa(this.value,[])}get(e="/"){return Yb(this.value,e.split("/").filter(Boolean))}};async function Zb({value:s,codec:e,hasher:t}){if(typeof s>"u")throw new Error('Missing required argument "value"');if(!e||!t)throw new Error("Missing required argument: codec or hasher");const r=e.encode(s),n=await t.digest(r),a=w.create(1,e.code,n);return new Bi({value:s,bytes:r,cid:a})}async function em({bytes:s,codec:e,hasher:t}){if(!s)throw new Error('Missing required argument "bytes"');if(!e||!t)throw new Error("Missing required argument: codec or hasher");const r=e.decode(s),n=await t.digest(s),a=w.create(1,e.code,n);return new Bi({value:r,bytes:s,cid:a})}function ji({bytes:s,cid:e,value:t,codec:r}){const n=t!==void 0?t:r&&r.decode(s);if(n===void 0)throw new Error('Missing required argument, must either provide "value" or "codec"');return new Bi({cid:e,bytes:s,value:n})}const ju=async({cid:s,load:e,seen:t})=>{t=t||new Set;const r=s.toString(U);if(t.has(r))return;const n=await e(s);if(t.add(r),n!==null)for(const[,a]of n.links())await ju({cid:a,load:e,seen:t})},Mu=M("ipfs:components:dag:import"),tm=[bt,xl];function rm({repo:s,preload:e,codecs:t}){async function*r(n,a={}){a.preload!==!1&&e(n);const i=w.asCID(n);if(!i)throw new Error(`Unexpected error converting CID type: ${n}`);Mu(`Exporting ${i} as car`);const{writer:o,out:c}=await Ah.create([i]);let l=null;(async()=>{try{const u=sm(s,o,{signal:a.signal,timeout:a.timeout},t);await ju({cid:i,load:u})}catch(u){l=u}finally{o.close()}})();for await(const u of c){if(l)break;yield u}if(l)throw l}return E(r)}function sm(s,e,t,r){return async n=>{const a=await r.getCodec(n.code);if(!a)throw new Error(`Can't decode links in block with codec 0x${n.code.toString(16)} to form complete DAG`);const i=await s.blocks.get(n,t);return Mu(`Adding block ${n} to car`),await e.put({cid:n,bytes:i}),tm.includes(n.code)?null:ji({bytes:i,cid:n,codec:a})}}function nm({codecs:s,repo:e,preload:t}){return E(async function(a,i={}){if(i.preload!==!1&&t(a),i.path){const d=i.localResolve?await Hs(Fr(a,i.path,s,e,i)):await Ce(Fr(a,i.path,s,e,i));if(!d)throw y(new Error("Not found"),"ERR_NOT_FOUND");return d}const o=await s.getCodec(a.code),c=await e.blocks.get(a,i);return{value:o.decode(c),remainderPath:""}})}const zu=M("ipfs:components:dag:import");function am({repo:s}){async function*e(t,r={}){const n=await s.gcLock.readLock();try{const a={signal:r.signal,timeout:r.timeout},i=Qr(t),{value:o,done:c}=await i.peek();if(c)return;o&&i.push(o);let l;o instanceof Uint8Array?l=[i]:l=i;for await(const u of l){const d=await im(s,a,u);if(r.pinRoots!==!1)for(const h of d){let f="";try{await s.blocks.has(h)?(zu(`Pinning root ${h}`),await s.pins.pinRecursively(h)):f="blockstore: block not found"}catch(p){f=p.message}yield{root:{cid:h,pinErrorMsg:f}}}}}finally{n()}}return E(e)}async function im(s,e,t){const r=await Rh.fromIterable(t),n=await r.getRoots();return await wn(s.blocks.putMany(Ve(r,({cid:a,bytes:i})=>(zu(`Import block ${a}`),{key:a,value:i})),{signal:e.signal})),n}function om({repo:s,codecs:e,hashers:t,preload:r}){async function n(a,i={}){const o=i.pin?await s.gcLock.readLock():null;try{const c=await e.getCodec(i.storeCodec||"dag-cbor");if(!c)throw new Error(`Unknown storeCodec ${i.storeCodec}, please configure additional BlockCodecs for this IPFS instance`);if(i.inputCodec){if(!(a instanceof Uint8Array))throw new Error("Can only inputCodec on raw bytes that can be decoded");const p=await e.getCodec(i.inputCodec);if(!p)throw new Error(`Unknown inputCodec ${i.inputCodec}, please configure additional BlockCodecs for this IPFS instance`);a=p.decode(a)}const l=i.version!=null?i.version:1,u=await t.getHasher(i.hashAlg||"sha2-256");if(!u)throw new Error(`Unknown hash algorithm ${i.hashAlg}, please configure additional MultihashHashers for this IPFS instance`);const d=c.encode(a),h=await u.digest(d),f=w.create(l,c.code,h);return await s.blocks.put(f,d,{signal:i.signal}),i.pin&&await s.pins.pinRecursively(f),i.preload!==!1&&r(f),f}finally{o&&o()}}return E(n)}function cm({repo:s,codecs:e,preload:t}){async function r(n,a={}){const{cid:i}=ns(n);return a.preload!==!1&&t(i),Tn(s,e,n,a)}return E(r)}class lm{constructor({repo:e,codecs:t,hashers:r,preload:n}){this.export=rm({repo:e,preload:n,codecs:t}),this.get=nm({codecs:t,repo:e,preload:n}),this.import=am({repo:e}),this.resolve=cm({repo:e,codecs:t,preload:n}),this.put=om({repo:e,codecs:t,hashers:r,preload:n})}}const ms=(s,e)=>e,um=(s,e,t,r)=>{if(r!=null&&r.assumeHttp===!1)return`tcp://${s}:${e}`;let n="tcp",a=`:${e}`;return t[t.length-1].protocol==="tcp"&&(n=e==="443"?"https":"http",a=e==="443"||e==="80"?"":a),`${n}://${s}${a}`},dm={ip4:ms,ip6:(s,e,t,r)=>r.length===1&&r[0].protocol==="ip6"?e:`[${e}]`,tcp:(s,e,t,r,n)=>r.some(a=>["http","https","ws","wss"].includes(a.protocol))?`${s}:${e}`:um(s,e,r,n),udp:(s,e)=>`udp://${s}:${e}`,dnsaddr:ms,dns4:ms,dns6:ms,ipfs:(s,e)=>`${s}/ipfs/${e}`,p2p:(s,e)=>`${s}/p2p/${e}`,http:s=>`http://${s}`,https:s=>`https://${s}`,ws:s=>`ws://${s}`,wss:s=>`wss://${s}`,"p2p-websocket-star":s=>`${s}/p2p-websocket-star`,"p2p-webrtc-star":s=>`${s}/p2p-webrtc-star`,"p2p-webrtc-direct":s=>`${s}/p2p-webrtc-direct`};function Uu(s,e){const t=ss(s),r=t.toString().split("/").slice(1);return t.tuples().map(n=>({protocol:r.shift()??"",content:n[1]!=null?r.shift()??"":""})).reduce((n,a,i,o)=>{const c=dm[a.protocol];if(c==null)throw new Error(`Unsupported protocol ${a.protocol}`);return c(n,a.content,i,o,e)},"")}const hm=M("ipfs:preload"),fm=Ue.default?Ue.default:Ue,pm=new fm({concurrency:4});function ym(s,e={}){return hm(s),pm.add(async()=>{const r=(await at.post(s,{signal:e.signal})).body.getReader();try{for(;;){const{done:n}=await r.read();if(n)return}}finally{r.releaseLock()}})}const Er=M("ipfs:preload");function wm(s={}){if(s.enabled=!!s.enabled,s.addresses=s.addresses||[],s.cache=s.cache||1e3,!s.enabled||!s.addresses.length)return Er("preload disabled"),Object.assign(()=>{},{start:()=>{},stop:()=>{}});let e=!0,t=[];const r=s.addresses.map(i=>Uu(i)),n=fi(s.cache),a=async i=>{try{if(e)throw new Error(`preload ${i} but preloader is not started`);const o=i.toString();if(n.has(o))return;n.set(o,!0);const c=Th(r);let l=!1;const u=Date.now();for(const d of c){if(e)throw new Error(`preload aborted for ${o}`);let h;try{h=new AbortController,t=t.concat(h),await ym(`${d}/api/v0/refs?r=true&arg=${encodeURIComponent(o)}`,{signal:h.signal}),l=!0}catch(f){f.type!=="aborted"&&Er.error(f)}finally{t=t.filter(f=>f!==h)}if(l)break}Er(`${l?"":"un"}successfully preloaded ${o} in ${Date.now()-u}ms`)}catch(o){Er.error(o)}};return a.start=()=>{e=!1},a.stop=()=>{e=!0,Er(`aborting ${t.length} pending preload request(s)`),t.forEach(i=>i.abort()),t=[]},a}const _s=M("ipfs:mfs-preload");function gm({preload:s,files:e,options:t={}}){if(t.interval=t.interval||30*1e3,!t.enabled){_s("MFS preload disabled");const i=async()=>{};return{start:i,stop:i}}let r="",n;const a=async()=>{try{const i=await e.stat("/"),o=i.cid.toString();r!==o&&(_s(`preloading updated MFS root ${r} -> ${i.cid}`),await s(i.cid),r=o)}catch(i){_s.error("failed to preload MFS root",i)}finally{n=setTimeout(a,t.interval)}};return{async start(){const i=await e.stat("/");r=i.cid.toString(),_s(`monitoring MFS root ${i.cid}`),n=setTimeout(a,t.interval)},stop(){clearTimeout(n)}}}let Es;function Mi(s=!1){if(Es)return Es;const e=wl({singleProcess:s});return Es={readLock:t=>async(...r)=>{const n=await e.readLock();try{return await t.apply(null,r)}finally{n()}},writeLock:t=>async(...r)=>{const n=await e.writeLock();try{return await t.apply(null,r)}finally{n()}}},Es}const rc=M("ipfs:mfs:utils:with-mfs-root");async function zi(s,e){if(e&&e.signal&&e.signal.aborted)throw y(new Error("Request aborted"),"ERR_ABORTED",{name:"Aborted"});await s.repo.datastore.open();let t;try{const r=await s.repo.datastore.get(Ma);t=w.decode(r)}catch(r){if(r.code!=="ERR_NOT_FOUND")throw r;rc("Creating new MFS root");const n=J({Data:new G({type:"directory"}).marshal(),Links:[]}),a=await me.digest(n);if(t=w.createV0(a),await s.repo.blocks.put(t,n),e&&e.signal&&e.signal.aborted)throw y(new Error("Request aborted"),"ERR_ABORTED",{name:"Aborted"});await s.repo.datastore.put(Ma,t.bytes)}return rc(`Loaded MFS root /ipfs/${t}`),t}function Ui(s=""){return(s.trim().match(/([^\\^/]|\\\/)+/g)||[]).filter(Boolean)}const aa="ipfs",Te=async(s,e,t)=>{const r=await zi(s,t);let n={entryType:"file"},a="";if(w.asCID(e)?a=`/ipfs/${e}`:a=e.toString(),a=a.trim(),a=a.replace(/(\/\/+)/g,"/"),a.endsWith("/")&&a.length>1&&(a=a.substring(0,a.length-1)),!a)throw y(new Error("paths must not be empty"),"ERR_NO_PATH");if(a.substring(0,1)!=="/")throw y(new Error("paths must start with a leading slash"),"ERR_INVALID_PATH");a.substring(a.length-1)==="/"&&(a=a.substring(0,a.length-1));const i=Ui(a);if(i[0]===aa){let c;i.length===2?c=`/${i.join("/")}`:c=`/${i.slice(0,i.length-1).join("/")}`,n={type:"ipfs",depth:i.length-2,entryType:"file",mfsPath:`/${i.join("/")}`,mfsDirectory:c,parts:i,path:`/${i.join("/")}`,name:i[i.length-1]}}else{const c=`/${aa}/${r}${i.length?"/"+i.join("/"):""}`,l=`/${aa}/${r}/${i.slice(0,i.length-1).join("/")}`;n={type:"mfs",depth:i.length,entryType:"file",mfsDirectory:l,mfsPath:c,parts:i,path:`/${i.join("/")}`,name:i[i.length-1]}}const o=n.type==="mfs"?n.mfsPath:n.path;try{const c=await lt(o,s.repo.blocks,t);n.cid=c.cid,n.mfsPath=`/ipfs/${c.path}`,n.entryType=c.type,n.content=c.content,(n.entryType==="file"||n.entryType==="directory")&&(c.type==="file"||c.type==="directory")&&(n.unixfs=c.unixfs)}catch(c){if(c.code!=="ERR_NOT_FOUND")throw c}return n.exists=!!n.cid,n},bm=_e.bind({ignoreUndefined:!0}),mm=M("ipfs:mfs:stat"),_m={withLocal:!1};function Cn(s){async function e(t,r={}){r=bm(_m,r),mm(`Fetching stats for ${t}`);const{type:n,cid:a,mfsPath:i}=await Te(s,t,r),o=n==="ipfs"&&a?a:i;let c;try{c=await lt(o,s.repo.blocks)}catch(l){throw l.code==="ERR_NOT_FOUND"?y(new Error(`${t} does not exist`),"ERR_NOT_FOUND"):l}if(!sc[c.type])throw new Error(`Cannot stat codec ${c.cid.code}`);return sc[c.type](c)}return E(e)}const sc={raw:s=>({cid:s.cid,size:s.node.length,cumulativeSize:s.node.length,blocks:0,type:"file",local:void 0,sizeLocal:void 0,withLocality:!1}),file:s=>{const e={cid:s.cid,type:"file",size:s.unixfs.fileSize(),cumulativeSize:J(s.node).length+(s.node.Links||[]).reduce((t,r)=>t+(r.Tsize||0),0),blocks:s.unixfs.blockSizes.length,local:void 0,sizeLocal:void 0,withLocality:!1,mode:s.unixfs.mode};return s.unixfs.mtime&&(e.mtime=s.unixfs.mtime),e},directory:s=>{const e={cid:s.cid,type:"directory",size:0,cumulativeSize:J(s.node).length+(s.node.Links||[]).reduce((t,r)=>t+(r.Tsize||0),0),blocks:s.node.Links.length,local:void 0,sizeLocal:void 0,withLocality:!1,mode:s.unixfs.mode};return s.unixfs.mtime&&(e.mtime=s.unixfs.mtime),e},object:s=>({cid:s.cid,size:s.node.length,cumulativeSize:s.node.length,type:"file",blocks:0,local:void 0,sizeLocal:void 0,withLocality:!1}),identity:s=>({cid:s.cid,size:s.node.length,cumulativeSize:s.node.length,blocks:0,type:"file",local:void 0,sizeLocal:void 0,withLocality:!1})},Em=M("ipfs:mfs:utils:to-trail");async function os(s,e){Em(`Creating trail for path ${e}`);const t=[];for await(const r of Lu(e,s.repo.blocks))t.push({name:r.name,cid:r.cid,size:r.size,type:r.type});return t}const Fu=async(s,e,t)=>{t.codec||(t.codec=Xe),t.hasher||(t.hasher=me),t.cidVersion===void 0&&(t.cidVersion=1),t.codec===Xe&&t.hasher!==me&&(t.cidVersion=1);const r=await t.hasher.digest(s),n=w.create(t.cidVersion,t.codec.code,r);return t.onlyHash||await e.put(n,s,{signal:t.signal}),n},Hu=On.code,qu=8;async function Ku(s){return(await On.encode(s)).subarray(0,8).reverse()}class vm{constructor(e,t){this.options=t||{},this.root=e.root,this.dir=e.dir,this.path=e.path,this.dirty=e.dirty,this.flat=e.flat,this.parent=e.parent,this.parentKey=e.parentKey,this.unixfs=e.unixfs,this.mode=e.mode,this.mtime=e.mtime,this.cid=void 0,this.size=void 0}async put(e,t){}get(e){return Promise.resolve(this)}async*eachChildSeries(){}async*flush(e){}}class Vu extends vm{constructor(e,t){super(e,t),this._bucket=bn({hashFn:Ku,bits:qu})}async put(e,t){await this._bucket.put(e,t)}get(e){return this._bucket.get(e)}childCount(){return this._bucket.leafCount()}directChildrenCount(){return this._bucket.childrenCount()}onlyChild(){return this._bucket.onlyChild()}async*eachChildSeries(){for await(const{key:e,value:t}of this._bucket.eachLeafSeries())yield{key:e,child:t}}async*flush(e){yield*Wu(this._bucket,e,this,this.options)}}async function*Wu(s,e,t,r){const n=s._children,a=[];let i=0;for(let f=0;f<n.length;f++){const p=n.get(f);if(!p)continue;const g=f.toString(16).toUpperCase().padStart(2,"0");if(p instanceof nr){let _;for await(const v of await Wu(p,e,null,r))_=v;if(!_)throw new Error("Could not flush sharded directory, no subshard found");a.push({Name:g,Tsize:_.size,Hash:_.cid}),i+=_.size}else if(typeof p.value.flush=="function"){const _=p.value;let v;for await(const P of _.flush(e))v=P,yield v;const k=g+p.key;a.push({Name:k,Tsize:v.size,Hash:v.cid}),i+=v.size}else{const _=p.value;if(!_.cid)continue;const v=g+p.key,k=_.size;a.push({Name:v,Tsize:k,Hash:_.cid}),i+=k}}const o=Uint8Array.from(n.bitField().reverse()),l={Data:new G({type:"hamt-sharded-directory",data:o,fanout:s.tableSize(),hashType:Hu,mtime:t&&t.mtime,mode:t&&t.mode}).marshal(),Links:a},u=J(gt(l)),d=await Fu(u,e,r),h=u.length+i;yield{cid:d,node:l,size:h}}const Or=M("ipfs:mfs:core:utils:hamt-utils"),In=async(s,e,t,r)=>{if(!r.parent.Data)throw new Error("Could not update HAMT directory because parent had no data");const n=Uint8Array.from(t._children.bitField().reverse()),a=G.unmarshal(r.parent.Data),i=new G({type:"hamt-sharded-directory",data:n,fanout:t.tableSize(),hashType:Hu,mode:a.mode,mtime:a.mtime}),o=await s.hashers.getHasher(r.hashAlg),c={Data:i.marshal(),Links:e.sort((h,f)=>(h.Name||"").localeCompare(f.Name||""))},l=J(c),u=await o.digest(l),d=w.create(r.cidVersion,V,u);return r.flush&&await s.repo.blocks.put(d,l),{node:c,cid:d,size:e.reduce((h,f)=>h+(f.Tsize||0),l.length)}},Ju=async(s,e,t,r,n)=>{const a=new nr({hash:t._options.hash,bits:t._options.bits},r,n);return r._putObjectAt(n,a),await Nn(s,e,a,t),a},Gu=async s=>{const e=bn({hashFn:Ku,bits:qu});return await Promise.all(s.map(async t=>{const r=t.Name||"";if(r.length===2){const n=parseInt(r,16),a=new nr({hash:e._options.hash,bits:e._options.bits},e,n);return e._putObjectAt(n,a),Promise.resolve()}return e.put(r.substring(2),{size:t.Tsize,cid:t.Hash})})),e},Nn=async(s,e,t,r)=>{await Promise.all(e.map(async n=>{const a=n.Name||"";if(a.length===2){Or("Populating sub bucket",a);const i=parseInt(a,16),o=await s.repo.blocks.get(n.Hash),c=le(o),l=new nr({hash:r._options.hash,bits:r._options.bits},t,i);return t._putObjectAt(i,l),await Nn(s,c.Links,l,r),Promise.resolve()}return r.put(a.substring(2),{size:n.Tsize,cid:n.Hash})}))},Gt=s=>s.toString(16).toUpperCase().padStart(2,"0").substring(0,2),Dm=async(s,e,t)=>{const r=await Gu(t.Links),n=await r._findNewBucketAndPos(e),a=[{bucket:n.bucket,prefix:Gt(n.pos)}];let i=n.bucket;for(;i!==r;)a.push({bucket:i,prefix:Gt(i._posAtParent)}),i=i._parent;a.reverse(),a[0].node=t;for(let o=0;o<a.length;o++){const c=a[o];if(!c.node)throw new Error("Could not generate HAMT path");const l=c.node.Links.filter(f=>(f.Name||"").substring(0,2)===c.prefix).pop();if(!l){Or(`Link ${c.prefix}${e} will be added`);continue}if(l.Name===`${c.prefix}${e}`){Or(`Link ${c.prefix}${e} will be replaced`);continue}Or(`Found subshard ${c.prefix}`);const u=await s.repo.blocks.get(l.Hash),d=le(u);if(!a[o+1]){Or(`Loaded new subshard ${c.prefix}`),await Ju(s,d.Links,r,c.bucket,parseInt(c.prefix,16));const f=await r._findNewBucketAndPos(e);a.push({bucket:f.bucket,prefix:Gt(f.pos),node:d});continue}const h=a[o+1];await Nn(s,d.Links,h.bucket,r),h.node=d}return await r.put(e,!0),a.reverse(),{rootBucket:r,path:a}},Sm=async(s,e,t={})=>{const r=new Vu({root:!0,dir:!0,parent:void 0,parentKey:void 0,path:"",dirty:!0,flat:!1,mtime:t.mtime,mode:t.mode},t);for(let a=0;a<e.length;a++)await r._bucket.put(e[a].name,{size:e[a].size,cid:e[a].cid});const n=await Ce(r.flush(s.repo.blocks));if(!n)throw new Error("Flushing shard yielded no result");return n},Qe=M("ipfs:mfs:core:utils:add-link");async function or(s,e){let t=e.parent;if(e.parentCid){const n=w.asCID(e.parentCid);if(n===null)throw y(new Error("Invalid CID passed to addLink"),"EINVALIDPARENTCID");if(n.code!==V)throw y(new Error("Unsupported codec. Only DAG-PB is supported"),"EINVALIDPARENTCID");Qe(`Loading parent node ${n}`);const a=await s.repo.blocks.get(n);t=le(a)}if(!t)throw y(new Error("No parent node or CID passed to addLink"),"EINVALIDPARENT");if(!e.cid)throw y(new Error("No child cid passed to addLink"),"EINVALIDCHILDCID");if(!e.name)throw y(new Error("No child name passed to addLink"),"EINVALIDCHILDNAME");if(!e.size&&e.size!==0)throw y(new Error("No child size passed to addLink"),"EINVALIDCHILDSIZE");if(!t.Data)throw y(new Error("Parent node with no data passed to addLink"),"ERR_INVALID_PARENT");const r=G.unmarshal(t.Data);return r.type==="hamt-sharded-directory"?(Qe("Adding link to sharded directory"),Pm(s,{...e,parent:t})):t.Links.length>=e.shardSplitThreshold?(Qe("Converting directory to sharded directory"),km(s,{...e,parent:t,mtime:r.mtime,mode:r.mode})):(Qe(`Adding ${e.name} (${e.cid}) to regular directory`),$m(s,{...e,parent:t}))}const km=async(s,e)=>{const t=await Sm(s,e.parent.Links.map(r=>({name:r.Name||"",size:r.Tsize||0,cid:r.Hash})).concat({name:e.name,size:e.size,cid:e.cid}),e);return Qe(`Converted directory to sharded directory ${t.cid}`),t},$m=async(s,e)=>{const t=e.parent.Links.filter(l=>l.Name!==e.name);if(t.push({Name:e.name,Tsize:e.size,Hash:e.cid}),!e.parent.Data)throw y(new Error("Parent node with no data passed to addToDirectory"),"ERR_INVALID_PARENT");const r=G.unmarshal(e.parent.Data);let n;if(r.mtime){const l=Date.now(),u=Math.floor(l/1e3);r.mtime={secs:u,nsecs:(l-u*1e3)*1e3},n=r.marshal()}else n=e.parent.Data;e.parent=gt({Data:n,Links:t});const a=await s.hashers.getHasher(e.hashAlg),i=J(e.parent),o=await a.digest(i),c=w.create(e.cidVersion,V,o);return e.flush&&await s.repo.blocks.put(c,i),{node:e.parent,cid:c,size:i.length}},Pm=async(s,e)=>{const{shard:t,path:r}=await Am(s,e),n=await Ce(t.flush(s.repo.blocks));if(!n)throw new Error("No result from flushing shard");const a=await s.repo.blocks.get(n.cid),i=le(a),o=e.parent.Links.filter(l=>(l.Name||"").substring(0,2)!==r[0].prefix),c=i.Links.find(l=>(l.Name||"").substring(0,2)===r[0].prefix);if(!c)throw new Error(`No link found with prefix ${r[0].prefix}`);return o.push(c),In(s,o,r[0].bucket,e)},Am=async(s,e)=>{const t={name:e.name,cid:e.cid,size:e.size};if(!e.parent.Data)throw y(new Error("Parent node with no data passed to addFileToShardedDirectory"),"ERR_INVALID_PARENT");const r=await Gu(e.parent.Links),n=G.unmarshal(e.parent.Data),a=new Vu({root:!0,dir:!0,parent:void 0,parentKey:void 0,path:"",dirty:!0,flat:!1,mode:n.mode},e);a._bucket=r,n.mtime&&(a.mtime={secs:Math.round(Date.now()/1e3)});const i=await r._findNewBucketAndPos(t.name),o=Rm(i);o[0].node=e.parent;let c=0;for(;c<o.length;){const l=o[c];c++;const u=l.node;if(!u)throw new Error("Segment had no node");const d=u.Links.find(g=>(g.Name||"").substring(0,2)===l.prefix);if(!d){Qe(`Link ${l.prefix}${t.name} will be added`),c=o.length;break}if(d.Name===`${l.prefix}${t.name}`){Qe(`Link ${l.prefix}${t.name} will be replaced`),c=o.length;break}if((d.Name||"").length>2){Qe(`Link ${d.Name} ${d.Hash} will be replaced with a subshard`),c=o.length;break}Qe(`Found subshard ${l.prefix}`);const h=await s.repo.blocks.get(d.Hash),f=le(h);if(!o[c]){Qe(`Loaded new subshard ${l.prefix}`),await Ju(s,f.Links,r,l.bucket,parseInt(l.prefix,16));const g=await r._findNewBucketAndPos(t.name);o.push({bucket:g.bucket,prefix:Gt(g.pos),node:f});break}const p=o[c];await Nn(s,f.Links,p.bucket,r),p.node=f}return await a._bucket.put(t.name,{size:t.size,cid:t.cid}),{shard:a,path:o}},Rm=s=>{const e=[{bucket:s.bucket,prefix:Gt(s.pos)}];let t=s.bucket._parent,r=s.bucket._posAtParent;for(;t;)e.push({bucket:t,prefix:Gt(r)}),r=t._posAtParent,t=t._parent;return e.reverse(),e},nc=M("ipfs:mfs:utils:update-tree"),Tm={shardSplitThreshold:1e3};async function It(s,e,t){t=Object.assign({},Tm,t),nc("Trail",e),e=e.slice().reverse();let r=0,n;for await(const i of s.repo.blocks.getMany(e.map(o=>o.cid))){const o=le(i),c=e[r].cid,l=e[r].name;if(r++,!n){n={cid:c,name:l,size:i.length};continue}const u=await or(s,{parent:o,name:n.name,cid:n.cid,size:n.size,flush:t.flush,shardSplitThreshold:t.shardSplitThreshold,hashAlg:t.hashAlg,cidVersion:t.cidVersion});n={cid:u.cid,name:l,size:u.size}}const{cid:a}=n;return nc(`Final CID ${a}`),a}const Om=M("ipfs:mfs:utils:update-mfs-root");async function Nt(s,e,t){if(t&&t.signal&&t.signal.aborted)throw y(new Error("Request aborted"),"ERR_ABORTED",{name:"Aborted"});return Om(`New MFS root will be ${e}`),await s.repo.datastore.put(Ma,e.bytes),e}async function Cm(s,e,t){const r=new G({type:e,mode:t.mode,mtime:t.mtime}),n=await s.hashers.getHasher(t.hashAlg),a={Data:r.marshal(),Links:[]},i=J(a),o=await n.digest(i),c=w.create(t.cidVersion,V,o);return t.flush&&await s.repo.blocks.put(c,i),{cid:c,node:a}}const Im=_e.bind({ignoreUndefined:!0}),Qu=M("ipfs:mfs:mkdir"),Nm={parents:!1,hashAlg:"sha2-256",cidVersion:0,shardSplitThreshold:1e3,flush:!0};function sn(s){async function e(t,r={}){const n=Im(Nm,r);if(!t)throw new Error("no path given to Mkdir");if(t=t.trim(),t==="/"){if(n.parents)return;throw y(new Error("cannot create directory '/': Already exists"),"ERR_INVALID_PATH")}if(t.substring(0,1)!=="/")throw y(new Error("paths must start with a leading slash"),"ERR_INVALID_PATH");Qu(`Creating ${t}`);const a=Ui(t);if(a[0]==="ipfs")throw y(new Error("path cannot have the prefix 'ipfs'"),"ERR_INVALID_PATH");const i=await zi(s,n);let o;const c=[],l=await Cm(s,"directory",n);for(let d=0;d<=a.length;d++){const h=a.slice(0,d),f=`/ipfs/${i}/${h.join("/")}`;try{if(o=await lt(f,s.repo.blocks),o.type!=="file"&&o.type!=="directory")throw y(new Error(`${t} was not a UnixFS node`),"ERR_NOT_UNIXFS");if(d===a.length){if(n.parents)return;throw y(new Error("file already exists"),"ERR_ALREADY_EXISTS")}c.push({name:o.name,cid:o.cid})}catch(p){if(p.code==="ERR_NOT_FOUND"){if(d<a.length&&!n.parents)throw y(new Error(`Intermediate directory path ${f} does not exist, use the -p flag to create it`),"ERR_NOT_FOUND");await xm(s,h[h.length-1],l,c[c.length-1],c,n)}else throw p}}const u=await It(s,c,n);await Nt(s,u,n)}return E(e)}const xm=async(s,e,t,r,n,a)=>{Qu(`Adding empty dir called ${e} to ${r.cid}`);const i=await or(s,{parent:r.node,parentCid:r.cid,size:0,cid:t.cid,name:e,hashAlg:a.hashAlg,cidVersion:a.cidVersion,flush:a.flush,shardSplitThreshold:a.shardSplitThreshold});n[n.length-1].cid=i.cid,n.push({name:e,cid:t.cid})},Lm=_e.bind({ignoreUndefined:!0}),vs=M("ipfs:mfs:cp"),Bm={parents:!1,flush:!0,hashAlg:"sha2-256",cidVersion:0,shardSplitThreshold:1e3};function Fi(s){async function e(t,r,n={}){const a=Lm(Bm,n);Array.isArray(t)||(t=[t]);const i=await Promise.all(t.map(h=>Te(s,h,a)));let o=await Te(s,r,a);if(!i.length||!o)throw y(new Error("Please supply at least one source"),"ERR_INVALID_PARAMS");const c=i.find(h=>!h.exists);if(c)throw y(new Error(`${c.path} does not exist`),"ERR_INVALID_PARAMS");const l=ac(o);if(o.exists){if(vs("Destination exists"),i.length===1&&!l)throw y(new Error("directory already has entry by that name"),"ERR_ALREADY_EXISTS")}else if(vs("Destination does not exist"),i.length>1){if(!a.parents)throw y(new Error("destination did not exist, pass -p to create intermediate directories"),"ERR_INVALID_PARAMS");await sn(s)(o.path,a),o=await Te(s,o.path,a)}else if(o.parts.length>1){const h=`/${o.parts.slice(0,-1).join("/")}`;try{await Cn(s)(h,a)}catch(f){if(f.code!=="ERR_NOT_FOUND")throw f;if(!a.parents)throw y(new Error("destination did not exist, pass -p to create intermediate directories"),"ERR_INVALID_PARAMS");await sn(s)(h,a),o=await Te(s,o.path,a)}}const u=ac(o)?o.mfsPath:o.mfsDirectory,d=await os(s,u);if(i.length===1){const h=i.pop();if(!h)throw y(new Error("could not find source"),"ERR_INVALID_PARAMS");const f=l?h.name:o.name;return vs(`Only one source, copying to destination ${l?"directory":"file"} ${f}`),jm(s,h,f,d,a)}return vs("Multiple sources, wrapping in a directory"),Mm(s,i,o,d,a)}return E(e)}const ac=s=>s.unixfs&&s.unixfs.type&&s.unixfs.type.includes("directory"),jm=async(s,e,t,r,n)=>{let a=r.pop();if(!a)throw y(new Error("destination had no parent"),"ERR_INVALID_PARAMS");a=await Xu(s,e,t,a,n),r.push(a);const i=await It(s,r,n);await Nt(s,i,n)},Mm=async(s,e,t,r,n)=>{for(let i=0;i<e.length;i++){const o=e[i];t=await Xu(s,o,o.name,t,n)}r[r.length-1]=t;const a=await It(s,r,n);await Nt(s,a,n)},Xu=async(s,e,t,r,n)=>{const a=await s.repo.blocks.get(e.cid),{node:i,cid:o,size:c}=await or(s,{parentCid:r.cid,size:a.length,cid:e.cid,name:t,hashAlg:n.hashAlg,cidVersion:n.cidVersion,flush:n.flush,shardSplitThreshold:n.shardSplitThreshold});return r.node=i,r.cid=o,r.size=c,r},pt=M("ipfs:mfs:core:utils:remove-link");async function zm(s,e){let t=e.parent;if(e.parentCid){const n=w.asCID(e.parentCid);if(n===null)throw y(new Error("Invalid CID passed to removeLink"),"EINVALIDPARENTCID");pt(`Loading parent node ${n}`);const a=await s.repo.blocks.get(n);t=le(a)}if(!t)throw y(new Error("No parent node or CID passed to removeLink"),"EINVALIDPARENT");if(!e.name)throw y(new Error("No child name passed to removeLink"),"EINVALIDCHILDNAME");if(!t.Data)throw y(new Error("Parent node had no data"),"ERR_INVALID_NODE");return G.unmarshal(t.Data).type==="hamt-sharded-directory"?(pt(`Removing ${e.name} from sharded directory`),Fm(s,{...e,parent:t})):(pt(`Removing link ${e.name} regular directory`),Um(s,{...e,parent:t}))}const Um=async(s,e)=>{e.parent.Links=e.parent.Links.filter(i=>i.Name!==e.name);const t=await J(e.parent),n=await(await s.hashers.getHasher(e.hashAlg)).digest(t),a=w.create(e.cidVersion,V,n);return await s.repo.blocks.put(a,t),pt(`Updated regular directory ${a}`),{node:e.parent,cid:a}},Fm=async(s,e)=>{const{rootBucket:t,path:r}=await Dm(s,e.name,e.parent);await t.del(e.name);const{node:n}=await Yu(s,r,e.name,e);return In(s,n.Links,t,e)},Yu=async(s,e,t,r)=>{const n=e.pop();if(!n)throw y(new Error("Could not find parent"),"EINVALIDPARENT");const{bucket:a,prefix:i,node:o}=n;if(!o)throw y(new Error("Could not find parent"),"EINVALIDPARENT");const c=o.Links.find(f=>(f.Name||"").substring(0,2)===i);if(!c)throw y(new Error(`No link found with prefix ${i} for file ${t}`),"ERR_NOT_FOUND");if(c.Name===`${i}${t}`){pt(`Removing existing link ${c.Name}`);const f=o.Links.filter(p=>p.Name!==c.Name);return await a.del(t),In(s,f,a,r)}pt(`Descending into sub-shard ${c.Name} for ${i}${t}`);const l=await Yu(s,e,t,r);let u=l.cid,d=l.size,h=i;if(l.node.Links.length===1){pt(`Removing subshard for ${i}`);const f=l.node.Links[0];h=`${i}${(f.Name||"").substring(2)}`,u=f.Hash,d=f.Tsize||0}return pt(`Updating shard ${i} with name ${h}`),Hm(s,a,o,i,h,d,u,r)},Hm=(s,e,t,r,n,a,i,o)=>{const c=t.Links.filter(l=>l.Name!==r);return c.push({Name:n,Tsize:a,Hash:i}),In(s,c,e,o)},qm=_e.bind({ignoreUndefined:!0}),Km={recursive:!1,cidVersion:0,hashAlg:"sha2-256",flush:!0,shardSplitThreshold:1e3};function Hi(s){async function e(t,r={}){const n=qm(Km,r);Array.isArray(t)||(t=[t]);const a=await Promise.all(t.map(i=>Te(s,i,n)));if(!a.length)throw y(new Error("Please supply at least one path to remove"),"ERR_INVALID_PARAMS");a.forEach(i=>{if(i.path==="/")throw y(new Error("Cannot delete root"),"ERR_INVALID_PARAMS")});for(const i of a)await Vm(s,i.path,n)}return E(e)}const Vm=async(s,e,t)=>{const r=await Te(s,e,t),n=await os(s,r.mfsPath),a=n[n.length-1];n.pop();const i=n[n.length-1];if(!i)throw y(new Error(`${e} does not exist`),"ERR_NOT_FOUND");if(a.type==="directory"&&!t.recursive)throw y(new Error(`${e} is a directory, use -r to remove directories`),"ERR_WAS_DIR");const{cid:o}=await zm(s,{parentCid:i.cid,name:a.name,hashAlg:t.hashAlg,cidVersion:t.cidVersion,flush:t.flush,shardSplitThreshold:t.shardSplitThreshold});i.cid=o;const c=await It(s,n,t);await Nt(s,c,t)},Wm=_e.bind({ignoreUndefined:!0}),Jm=M("ipfs:mfs:touch"),ic={flush:!0,shardSplitThreshold:1e3,hashAlg:"sha2-256",cidVersion:0,recursive:!1};function Gm(s,e,t){let r=0;return(s.includes("x")||s.includes("X")&&(t||e&1||e&8||e&64))&&(r+=1),s.includes("w")&&(r+=2),s.includes("r")&&(r+=4),r}function Qm(s,e){let t=0;return s.includes("u")&&(t+=e<<6),s.includes("g")&&(t+=e<<3),s.includes("o")&&(t+=e),t}function Xm(s,e,t){return e.includes("t")&&(t+=parseInt("1000",8)),e.includes("s")&&(s.includes("u")&&(t+=parseInt("4000",8)),s.includes("g")&&(t+=parseInt("2000",8))),t}function Ym(s,e,t){e||(e=0);const r=s.match(/^(u?g?o?a?)(-?\+?=?)?(r?w?x?X?s?t?)$/);if(!r)throw new Error(`Invalid file mode: ${s}`);let[,n,a,i]=r;(n==="a"||!n)&&(n="ugo");let o=Gm(i,e,t);return o=Qm(n,o),o=Xm(n,i,o),a==="="?(n.includes("u")&&(e=e&parseInt("7077",8),e=e|o),n.includes("g")&&(e=e&parseInt("7707",8),e=e|o),n.includes("o")&&(e=e&parseInt("7770",8),e=e|o),e):a==="+"?o|e:a==="-"?o^e:e}function oc(s,e){if(s instanceof String||typeof s=="string"){const t=`${s}`;t.match(/^\d+$/g)?s=parseInt(t,8):s=0+t.split(",").reduce((r,n)=>Ym(n,r,e.isDirectory()),e.mode||0)}return s}function Zm(s){async function e(t,r,n={}){const a=Wm(ic,n);Jm(`Fetching stats for ${t}`);const{cid:i,mfsDirectory:o,name:c}=await Te(s,t,a);if(i.code!==V)throw y(new Error(`${t} was not a UnixFS node`),"ERR_NOT_UNIXFS");if(a.recursive){const S=await it(async function*(){for await(const L of Bu(i,s.repo.blocks)){if(L.type!=="file"&&L.type!=="directory")throw y(new Error(`${t} was not a UnixFS node`),"ERR_NOT_UNIXFS");L.unixfs.mode=oc(r,L.unixfs);const Ie=gt({Data:L.unixfs.marshal(),Links:L.node.Links});yield{path:L.path,content:Ie}}},L=>xi(L,s.repo.blocks,{...a,pin:!1,dagBuilder:async function*(Ie,tt,Ne){for await(const H of Ie)yield async function(){const ue=H.content,Bt=J(ue),vt=await Fu(Bt,tt,Ne);if(!ue.Data)throw y(new Error(`${vt} had no data`),"ERR_INVALID_NODE");const ut=G.unmarshal(ue.Data);return{cid:vt,size:Bt.length,path:H.path,unixfs:ut}}}}),L=>Ce(L));if(!S)throw y(new Error(`Could not chmod ${t}`),"ERR_COULD_NOT_CHMOD");await Hi(s)(t,a),await Fi(s)(`/ipfs/${S.cid}`,t,a);return}const l=await s.repo.blocks.get(i),u=le(l);if(!u.Data)throw y(new Error(`${i} had no data`),"ERR_INVALID_NODE");const d=G.unmarshal(u.Data);d.mode=oc(r,d);const h=J({Data:d.marshal(),Links:u.Links}),f=a.hashAlg||ic.hashAlg,g=await(await s.hashers.getHasher(f)).digest(h),_=w.create(a.cidVersion,V,g);a.flush&&await s.repo.blocks.put(_,h);const v=await os(s,o),k=v[v.length-1],P=w.decode(k.cid.bytes),T=await s.repo.blocks.get(P),I=le(T),x=await or(s,{parent:I,name:c,cid:_,size:h.length,flush:a.flush,hashAlg:f,cidVersion:i.version,shardSplitThreshold:1/0});k.cid=x.cid;const C=await It(s,v,a);await Nt(s,C,a)}return E(e)}const e_=_e.bind({ignoreUndefined:!0}),t_={};function r_(s){async function e(t,r={}){r=e_(t_,r);const{cid:n}=await Cn(s)(t,r);return n}return E(e)}const s_=_e.bind({ignoreUndefined:!0}),n_={parents:!1,flush:!0,cidVersion:0,hashAlg:"sha2-256",shardSplitThreshold:1e3};function a_(s){async function e(t,r,n={}){const a=s_(n_,n);await Fi(s)(t,r,a),await Hi(s)(t,{...a,recursive:!0})}return E(e)}const i_=_e.bind({ignoreUndefined:!0}),o_=M("ipfs:mfs:touch"),cc={flush:!0,shardSplitThreshold:1e3,cidVersion:0,hashAlg:"sha2-256"};function c_(s){async function e(t,r={}){const n=i_(cc,r);n.mtime=n.mtime||new Date,o_(`Touching ${t} mtime: ${n.mtime}`);const{cid:a,mfsDirectory:i,name:o,exists:c}=await Te(s,t,n),l=r.hashAlg||cc.hashAlg,u=await s.hashers.getHasher(l);let d,h,f=n.cidVersion;if(c){if(a.code!==V)throw y(new Error(`${t} was not a UnixFS node`),"ERR_NOT_UNIXFS");f=a.version;const I=await s.repo.blocks.get(a),x=le(I);if(!x.Data)throw y(new Error(`${t} had no data`),"ERR_INVALID_NODE");const C=G.unmarshal(x.Data);C.mtime=n.mtime,d=J({Data:C.marshal(),Links:x.Links});const S=await u.digest(d);h=w.create(n.cidVersion,V,S),n.flush&&await s.repo.blocks.put(h,d)}else{const I=new G({type:"file",mtime:n.mtime});d=J({Data:I.marshal(),Links:[]});const x=await u.digest(d);h=w.create(n.cidVersion,V,x),n.flush&&await s.repo.blocks.put(h,d)}const p=await os(s,i),g=p[p.length-1],_=g.cid,v=await s.repo.blocks.get(_),k=le(v),P=await or(s,{parent:k,name:o,cid:h,size:d.length,flush:n.flush,shardSplitThreshold:n.shardSplitThreshold,hashAlg:n.hashAlg,cidVersion:f});g.cid=P.cid;const T=await It(s,p,n);await Nt(s,T,n)}return E(e)}const l_=_e.bind({ignoreUndefined:!0}),u_={offset:0,length:1/0};function d_(s){function e(t,r={}){return r=l_(u_,r),{[Symbol.asyncIterator]:async function*(){const a=await Te(s,t,r),i=await lt(a.mfsPath,s.repo.blocks);if(i.type!=="file"&&i.type!=="raw")throw y(new Error(`${t} was not a file or raw bytes`),"ERR_NOT_FILE");if(!i.content)throw y(new Error(`Could not load content stream from ${t}`),"ERR_NO_CONTENT");for await(const o of i.content({offset:r.offset,length:r.length}))yield o}}}return E(e)}const vr=M("ipfs:mfs:utils:to-async-iterator");function h_(s){if(!s)throw y(new Error("paths must start with a leading slash"),"ERR_INVALID_PATH");if((typeof s=="string"||s instanceof String)&&(vr("Content was a string"),s=Q(s.toString())),s.length)return vr("Content was array-like"),{[Symbol.asyncIterator]:function*(){yield s}};if(s[Symbol.asyncIterator])return vr("Content was an async iterator"),s;if(s[Symbol.iterator])return vr("Content was an iterator"),s;if(ho.Blob&&s instanceof ho.Blob)return vr("Content was an HTML5 Blob"),Gr(s.stream());throw y(new Error(`Don't know how to convert ${s} into an async iterator`),"ERR_INVALID_PARAMS")}const f_=_e.bind({ignoreUndefined:!0}),Ge=M("ipfs:mfs:write"),p_={offset:0,length:1/0,create:!1,truncate:!1,rawLeaves:!1,reduceSingleLeafToSelf:!1,cidVersion:0,hashAlg:"sha2-256",parents:!1,progress:(s,e)=>{},strategy:"trickle",flush:!0,leafType:"raw",shardSplitThreshold:1e3};function y_(s){async function e(t,r,n={}){const a=f_(p_,n);let i,o,c;if(Ge("Reading source, destination and parent"),await Mi().readLock(async()=>{i=await h_(r),o=await Te(s,t,a),c=await Te(s,o.mfsDirectory,a)})(),Ge("Read source, destination and parent"),!a.parents&&!c.exists)throw y(new Error("directory does not exist"),"ERR_NO_EXIST");if(i==null)throw y(new Error("could not create source"),"ERR_NO_SOURCE");if(o==null)throw y(new Error("could not create destination"),"ERR_NO_DESTINATION");if(!a.create&&!o.exists)throw y(new Error("file does not exist"),"ERR_NO_EXIST");if(o.entryType!=="file")throw y(new Error("not a file"),"ERR_NOT_A_FILE");return w_(s,t,i,o,a)}return E(e)}const w_=async(s,e,t,r,n)=>{const a=await g_(s,t,r,n);await Mi().writeLock(async()=>{const i=Ui(e),o=i.pop();if(o==null)throw y(new Error("source does not exist"),"ERR_NO_EXIST");let c=!1;try{await Cn(s)(`/${i.join("/")}`,n),c=!0}catch(_){if(_.code!=="ERR_NOT_FOUND")throw _}c||await sn(s)(`/${i.join("/")}`,n);const l=await Te(s,e,n),u=await os(s,l.mfsDirectory),d=u[u.length-1];if(!d)throw y(new Error("directory does not exist"),"ERR_NO_EXIST");if(!d.type||!d.type.includes("directory"))throw y(new Error(`cannot write to ${d.name}: Not a directory`),"ERR_NOT_A_DIRECTORY");const h=await s.repo.blocks.get(d.cid),f=le(h),p=await or(s,{parent:f,name:o,cid:a.cid,size:a.size,flush:n.flush,shardSplitThreshold:n.shardSplitThreshold,hashAlg:n.hashAlg,cidVersion:n.cidVersion});d.cid=p.cid;const g=await It(s,u,n);await Nt(s,g,n)})()},g_=async(s,e,t,r)=>{t.exists?Ge(`Overwriting file ${t.cid} offset ${r.offset} length ${r.length}`):Ge(`Writing file offset ${r.offset} length ${r.length}`);const n=[];if(r.offset>0)if(t.unixfs){if(Ge(`Writing first ${r.offset} bytes of original file`),n.push(()=>t.content({offset:0,length:r.offset})),t.unixfs.fileSize()<r.offset){const u=r.offset-t.unixfs.fileSize();Ge(`Writing zeros for extra ${u} bytes`),n.push(lc(u))}}else Ge(`Writing zeros for first ${r.offset} bytes`),n.push(lc(r.offset));n.push(Zu(e,r.length));const a=m_(b_(n),u=>{if(t.unixfs&&!r.truncate){const d=t.unixfs.fileSize();if(d>u)return Ge(`Writing last ${d-u} of ${d} bytes from original file starting at offset ${u}`),t.content({offset:u});Ge("Not writing last bytes from original file")}return{[Symbol.asyncIterator]:async function*(){}}});let i;r.mode!==void 0&&r.mode!==null?i=Wt(r.mode):t&&t.unixfs&&(i=t.unixfs.mode);let o;r.mtime!=null?o=Ur(r.mtime):t&&t.unixfs&&(o=t.unixfs.mtime);const c=await s.hashers.getHasher(r.hashAlg),l=await Ce(xi([{content:a,mode:i,mtime:o}],s.repo.blocks,{progress:r.progress,hasher:c,cidVersion:r.cidVersion,strategy:r.strategy,rawLeaves:r.rawLeaves,reduceSingleLeafToSelf:r.reduceSingleLeafToSelf,leafType:r.leafType}));if(!l)throw y(new Error(`cannot write to ${parent.name}`),"ERR_COULD_NOT_WRITE");return Ge(`Wrote ${l.cid}`),{cid:l.cid,size:l.size}},Zu=(s,e)=>async function*(){let r=0;for await(const n of s){if(r+=n.length,r>e){yield n.subarray(0,e-r);return}yield n}},lc=(s,e=Gy)=>{const t=new Uint8Array(e);async function*r(){for(;;)yield t}return Zu(r(),s)},b_=async function*(s){for(let e=0;e<s.length;e++)yield*s[e]()},m_=async function*(s,e){let t=0;for await(const r of s)t+=r.length,yield r;for await(const r of e(t))t+=r.length,yield r},uc=s=>{const e={cid:s.cid,name:s.name,type:s.type==="directory"?"directory":"file",size:s.size};return(s.type==="file"||s.type==="directory")&&(e.mode=s.unixfs.mode,e.mtime=s.unixfs.mtime),e};function __(s){async function*e(t,r={}){const n=await Te(s,t,r),a=await lt(n.mfsPath,s.repo.blocks);if(a.type==="directory"){yield*Ve(a.content(r),uc);return}yield uc(a)}return E(e)}const E_={stat:Cn},v_={chmod:Zm,cp:Fi,flush:r_,mkdir:sn,mv:a_,rm:Hi,touch:c_},dc={write:y_,read:d_,ls:__},hc=({options:s,mfs:e,operations:t,lock:r})=>{Object.keys(t).forEach(n=>{e[n]=r(t[n](s))})},D_={repoOwner:!0,repo:null};function S_(s){const{repoOwner:e}=Object.assign({},D_||{},s),t=Mi(e),r=i=>t.readLock(i),n=i=>t.writeLock(i),a={};return hc({options:s,mfs:a,operations:E_,lock:r}),hc({options:s,mfs:a,operations:v_,lock:n}),Object.keys(dc).forEach(i=>{a[i]=dc[i](s)}),a}function k_({repo:s,preload:e,hashers:t,options:r}){const n=S_({repo:s,repoOwner:r.repoOwner!==!1,hashers:t}),a=i=>(...c)=>{const l=c.filter(u=>Wy(u)||Ti(u));if(l.length){const u=c[c.length-1];u&&u.preload!==!1&&l.forEach(d=>e(d))}return i(...c)};return{...n,chmod:n.chmod,cp:a(n.cp),mkdir:n.mkdir,stat:a(n.stat),rm:n.rm,read:a(n.read),touch:n.touch,write:n.write,mv:a(n.mv),flush:n.flush,ls:a(async function*(...i){for await(const o of n.ls(...i))yield{...o,size:o.size||0}})}}function $_({keychain:s}){return E((t,r)=>s.exportKey(t,r))}const fc="Ed25519",pc=2048;function P_({keychain:s}){return E((t,r={type:fc,size:pc})=>s.createKey(t,r.type||fc,r.size||pc))}function A_({keychain:s}){return E((t,r,n)=>s.importKey(t,r,n))}function R_({keychain:s}){return E(t=>s.findKeyByName(t))}function T_({keychain:s}){return E(()=>s.listKeys())}function O_({keychain:s}){return E(async(t,r)=>{const n=await s.renameKey(t,r);return{was:t,now:n.name,id:n.id,overwrite:!1}})}function C_({keychain:s}){return E(t=>s.removeKey(t))}class I_{constructor({keychain:e}){this.gen=P_({keychain:e}),this.list=T_({keychain:e}),this.rm=C_({keychain:e}),this.rename=O_({keychain:e}),this.export=$_({keychain:e}),this.import=A_({keychain:e}),this.info=R_({keychain:e})}}function xt({repo:s,preload:e}){async function t(r,n={}){n.preload!==!1&&e(r);const a=await s.blocks.get(r,n);return le(a)}return E(t)}function N_({repo:s,preload:e}){const t=xt({repo:s,preload:e});async function r(n,a={}){return(await t(n,a)).Data||new Uint8Array(0)}return E(r)}function Ja(s,e=[]){for(const t in s){const r=s[t];if(t==="/"&&Object.keys(s).length===1)try{e.push({Name:"",Tsize:0,Hash:w.parse(r)});continue}catch{}const n=w.asCID(r);if(n){e.push({Name:"",Tsize:0,Hash:n});continue}Array.isArray(r)&&Ja(r,e),r&&typeof r=="object"&&Ja(r,e)}return e}function x_({repo:s,codecs:e}){async function t(r,n={}){const a=await e.getCodec(r.code),i=await s.blocks.get(r,n),o=a.decode(i);switch(r.code){case bt:return[];case V:return o.Links;case Xr:case Oh:return Ja(o);default:throw new Error(`Cannot resolve links from codec ${r.code}`)}}return E(t)}function L_({repo:s,preload:e}){async function t(r={}){let n;if(r.template)if(r.template==="unixfs-dir")n=new G({type:"directory"}).marshal();else throw new Error("unknown template");const a=J({Data:n,Links:[]}),i=await me.digest(a),o=w.createV0(i);return await s.blocks.put(o,a,{signal:r.signal}),r.preload!==!1&&e(o),o}return E(t)}function cs({repo:s,preload:e}){async function t(r,n={}){const a=await s.gcLock.readLock();try{const i=J(r),o=await me.digest(i),c=w.createV1(V,o);return await s.blocks.put(c,i,{signal:n.signal}),n.preload!==!1&&e(c),n.pin&&await s.pins.pinRecursively(c,{signal:n.signal}),c}finally{a()}}return E(t)}function B_({repo:s,preload:e}){const t=xt({repo:s,preload:e});async function r(n,a={}){const i=await t(n,a),c=J(i).length,l=i.Links.reduce((u,d)=>u+(d.Tsize||0),0);return{Hash:n,NumLinks:i.Links.length,BlockSize:c,LinksSize:c-(i.Data||[]).length,DataSize:(i.Data||[]).length,CumulativeSize:c+l}}return E(r)}function j_({repo:s,preload:e}){const t=xt({repo:s,preload:e}),r=cs({repo:s,preload:e});async function n(a,i,o={}){const c=await t(a,o);return r({...c,Links:c.Links.concat([i])},o)}return E(n)}function M_({repo:s,preload:e}){const t=xt({repo:s,preload:e}),r=cs({repo:s,preload:e});async function n(a,i,o={}){const c=await t(a,o),l=oe([c.Data||[],i]);return r({...c,Data:l},o)}return E(n)}function z_({repo:s,preload:e}){const t=xt({repo:s,preload:e}),r=cs({repo:s,preload:e});async function n(a,i,o={}){const c=await t(a,o),l=(typeof i=="string"?i:i.Name)||"";return c.Links=c.Links.filter(u=>u.Name!==l),r(c,o)}return E(n)}function U_({repo:s,preload:e}){const t=xt({repo:s,preload:e}),r=cs({repo:s,preload:e});async function n(a,i,o={}){const c=await t(a,o);return r({...c,Data:i},o)}return E(n)}class F_{constructor({repo:e,preload:t}){this.addLink=j_({repo:e,preload:t}),this.appendData=M_({repo:e,preload:t}),this.rmLink=z_({repo:e,preload:t}),this.setData=U_({repo:e,preload:t})}}class H_{constructor({repo:e,codecs:t,preload:r}){this.data=N_({repo:e,preload:r}),this.get=xt({repo:e,preload:r}),this.links=x_({repo:e,codecs:t}),this.new=L_({repo:e,preload:r}),this.put=cs({repo:e,preload:r}),this.stat=B_({repo:e,preload:r}),this.patch=new F_({repo:e,preload:r})}}const q_=M("ipfs:repo:gc");function K_({repo:s,hashers:e}){async function*t(r={}){const n=Date.now();let a;try{a=await zi({repo:s,hashers:e},r),await s.pins.pinRecursively(a),yield*s.gc()}finally{a&&await s.pins.unpin(a)}q_(`Complete (${Date.now()-n}ms)`)}return E(t)}function ed({repo:s}){async function e(t={}){const r=await s.stat();return{numObjects:BigInt(r.numObjects.toString()),repoSize:BigInt(r.repoSize.toString()),repoPath:r.repoPath,version:`${r.version}`,storageMax:BigInt(r.storageMax.toString())}}return E(e)}const js=12;function V_({repo:s}){async function e(t={}){try{await s._checkInitialized(t)}catch(r){if([/Key not found in database \[\/version\]/,/ENOENT/,/repo is not initialized yet/].some(a=>a.test(r.message)))return js;throw r}return s.version.get()}return E(e)}class W_{constructor({repo:e,hashers:t}){this.gc=K_({repo:e,hashers:t}),this.stat=ed({repo:e}),this.version=V_({repo:e}),this.setApiAddr=r=>e.apiAddr.set(r)}}function yc(s,e){return{totalIn:BigInt(0),totalOut:BigInt(0),rateIn:0,rateOut:0}}function J_({network:s}){return E(async function*(t={}){const{libp2p:r}=await s.use(t);if(!t.poll){yield yc();return}const n=t.interval||1e3;let a=-1;try{if(a=typeof n=="string"?pn(n)||-1:n,!a||a<0)throw new Error("invalid duration")}catch(o){throw y(o,"ERR_INVALID_POLL_INTERVAL")}let i;try{for(;;)yield yc(r,t),await new Promise(o=>{i=setTimeout(o,a)})}finally{clearTimeout(i)}})}class G_{constructor({repo:e,network:t}){this.repo=ed({repo:e}),this.bw=J_({network:t}),this.bitswap=vu({network:t})}}const Q_=ct("ipfs:repo:migrator:migration-8");function td(s){return s.child?td(s.child):s}function X_(s){try{const e=he.decode(`b${s.toString().toLowerCase().slice(1)}`),t=w.decode(e).multihash.bytes,r=he.encode(t).slice(1).toUpperCase();return new ae(`/${r}`,!1)}catch{return s}}function Y_(s){try{const e=he.decode(`b${s.toString().toLowerCase().slice(1)}`),t=Et(e),r=he.encode(w.createV1(bt,t).bytes).slice(1);return new ae(`/${r.toUpperCase()}`,!1)}catch{return s}}async function wc(s,e,t){const r=s.blocks;await r.open();const n=td(r),a=await qs(n.queryKeys({filters:[i=>t(i).toString()!==i.toString()]}));try{let i=0;for await(const o of n.query({})){const c=t(o.key);c.toString()!==o.key.toString()&&(i+=1,Q_(`Migrating Block from ${o.key} to ${c}`,await n.has(o.key)),await n.delete(o.key),await n.put(c,o.value),e(i/a*100,`Migrated Block from ${o.key} to ${c}`))}}finally{await r.close()}}const Z_={version:8,description:"Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32",migrate:(s,e=()=>{})=>wc(s,e,X_),revert:(s,e=()=>{})=>wc(s,e,Y_)},gc=D.Reader,eE=D.Writer;D.util;const Ds=D.roots.default||(D.roots.default={}),tE=Ds.ipfs=(()=>{const s={};return s.pin=function(){const e={};return e.Set=function(){function t(r){if(r)for(var n=Object.keys(r),a=0;a<n.length;++a)r[n[a]]!=null&&(this[n[a]]=r[n[a]])}return t.prototype.version=0,t.prototype.fanout=0,t.prototype.seed=0,t.encode=function(n,a){return a||(a=eE.create()),n.version!=null&&Object.hasOwnProperty.call(n,"version")&&a.uint32(8).uint32(n.version),n.fanout!=null&&Object.hasOwnProperty.call(n,"fanout")&&a.uint32(16).uint32(n.fanout),n.seed!=null&&Object.hasOwnProperty.call(n,"seed")&&a.uint32(29).fixed32(n.seed),a},t.decode=function(n,a){n instanceof gc||(n=gc.create(n));for(var i=a===void 0?n.len:n.pos+a,o=new Ds.ipfs.pin.Set;n.pos<i;){var c=n.uint32();switch(c>>>3){case 1:o.version=n.uint32();break;case 2:o.fanout=n.uint32();break;case 3:o.seed=n.fixed32();break;default:n.skipType(c&7);break}}return o},t.fromObject=function(n){if(n instanceof Ds.ipfs.pin.Set)return n;var a=new Ds.ipfs.pin.Set;return n.version!=null&&(a.version=n.version>>>0),n.fanout!=null&&(a.fanout=n.fanout>>>0),n.seed!=null&&(a.seed=n.seed>>>0),a},t.toObject=function(n,a){a||(a={});var i={};return a.defaults&&(i.version=0,i.fanout=0,i.seed=0),n.version!=null&&n.hasOwnProperty("version")&&(i.version=n.version),n.fanout!=null&&n.hasOwnProperty("fanout")&&(i.fanout=n.fanout),n.seed!=null&&n.hasOwnProperty("seed")&&(i.seed=n.seed),i},t.prototype.toJSON=function(){return this.constructor.toObject(this,D.util.toJSONOptions)},t}(),e}(),s})(),Ms=new ae("/local/pins"),ia=256,rE=8192,rd=w.parse("QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n"),Vt={direct:"direct",recursive:"recursive"};function bc(s){return new ae(`/${he.encode(s.multihash.bytes).toUpperCase().substring(1)}`)}const Ga=tE.pin.Set;function sE(s){const e=s.Data;if(!e)throw new Error("No data present");const t=j.decode(e),r=j.decode.bytes??0;if(r<=0)throw new Error("Invalid Set header length");if(r+t>e.length)throw new Error("Impossibly large set header length");const n=e.slice(r,t+r),a=Ga.toObject(Ga.decode(n),{defaults:!1,arrays:!0,longs:Number,objects:!1});if(a.version!==1)throw new Error(`Unsupported Set version: ${a.version}`);if(a.fanout>s.Links.length)throw new Error("Impossibly large fanout");return{header:a,data:e.slice(t+r)}}function nE(s,e){const t=new Uint8Array(4);new DataView(t.buffer).setUint32(0,s,!0);const n=Q(e.toString()),a=oe([t,n],t.byteLength+n.byteLength);return Ih(R(a))}async function*sd(s,e){const t=sE(e);let r=0;for(const n of e.Links){if(r<t.header.fanout){const a=n.Hash;if(!rd.equals(a)){const i=await s.get(a),o=le(i);yield*sd(s,o)}}else yield n.Hash;r++}}async function*Ss(s,e,t){const r=e.Links.find(i=>i.Name===t);if(!r)throw new Error("No link found with name "+t);const n=await s.get(r.Hash),a=le(n);yield*sd(s,a)}function aE(s,e){return t(e,0);async function t(r,n){const a=Ga.encode({version:1,fanout:ia,seed:n}).finish(),i=j.encode(a.length),o=oe([i,a]),c=[];for(let u=0;u<ia;u++)c.push({Name:"",Tsize:1,Hash:rd});if(r.length<=rE){const u=r.map(f=>({link:{Name:"",Tsize:1,Hash:f.key},data:f.data||new Uint8Array})).sort((f,p)=>Ch(f.link.Hash.bytes,p.link.Hash.bytes)),d=c.concat(u.map(f=>f.link));return{Data:oe([o,...u.map(f=>f.data)]),Links:d}}else{const u=r.reduce((h,f)=>{const p=nE(n,f.key)%ia;return h[p]=p in h?h[p].concat([f]):[f],h},[]);let d=0;for(const h of u){const f=await t(h,n+1);await l(f,d),d++}return{Data:o,Links:c}}async function l(u,d){const h=J(u),f=await me.digest(h),p=w.createV0(f);await s.put(p,h);const g=u.Links.reduce((_,v)=>_+(v.Tsize||0),0)+h.length;c[d]={Name:"",Tsize:g,Hash:p}}}}async function mc(s,e,t){const r=await aE(s,t.map(c=>({key:c}))),n=J(r),a=await me.digest(n),i=w.createV0(a);await s.put(i,n);const o=r.Links.reduce((c,l)=>c+l.Tsize,0)+n.length;return{Name:e,Tsize:o,Hash:i}}async function iE(s,e,t,r){if(!await e.has(Ms))return;const n=await e.get(Ms),a=w.decode(n),i=await s.get(a),o=le(i);let c=0;const l=await qs(Ss(s,o,Vt.recursive))+await qs(Ss(s,o,Vt.direct));for await(const u of Ss(s,o,Vt.recursive)){c++;const d={depth:1/0};u.version!==0&&(d.version=u.version),u.code!==V&&(d.codec=u.code),await t.put(bc(u),Ks(d)),r(c/l*100,`Migrated recursive pin ${u}`)}for await(const u of Ss(s,o,Vt.direct)){c++;const d={depth:0};u.version!==0&&(d.version=u.version),u.code!==V&&(d.codec=u.code),await t.put(bc(u),Ks(d)),r(c/l*100,`Migrated direct pin ${u}`)}await s.delete(a),await e.delete(Ms)}async function oE(s,e,t,r){const n=[],a=[];let i=0;const o=await qs(t.queryKeys({}));for await(const{key:h,value:f}of t.query({})){i++;const p=kt(f),g=w.create(p.version||0,p.codec||V,Et(he.decode("b"+h.toString().toLowerCase().split("/").pop())));p.depth===0?(r(i/o*100,`Reverted direct pin ${g}`),a.push(g)):(r(i/o*100,`Reverted recursive pin ${g}`),n.push(g))}r(100,"Updating pin root");const c={Links:[await mc(s,Vt.direct,a),await mc(s,Vt.recursive,n)]},l=J(c),u=await me.digest(l),d=w.createV0(u);await s.put(d,l),await e.put(Ms,d.bytes)}async function _c(s,e,t){const r=s.blocks,n=s.datastore,a=s.pins;await r.open(),await n.open(),await a.open();try{await t(r,n,a,e)}finally{await a.close(),await n.close(),await r.close()}}const cE={version:9,description:"Migrates pins to datastore",migrate:(s,e=()=>{})=>_c(s,e,iE),revert:(s,e=()=>{})=>_c(s,e,oE)},lE=new ae("/config"),qi=new ae("/version");function xn(s){let e=s;for(;e.db||e.child;)if(e=e.db||e.child,e.type==="level-js"||e.constructor.name==="Level")return e}async function uE(s,e,t){const r=await e(s);if(r)return r;const n=xn(t);return n?new Promise((a,i)=>{const o=n.store("readonly").get(s.toString());o.transaction.onabort=()=>{i(o.transaction.error)},o.transaction.oncomplete=()=>{a(!!o.result)}}):!1}async function dE(s,e,t,r){if(await t(s))return e(s);const n=xn(r);if(!n)throw At();return new Promise((a,i)=>{const o=n.store("readonly").get(s.toString());o.transaction.onabort=()=>{i(o.transaction.error)},o.transaction.oncomplete=()=>{if(o.result)return a(o.result);i(At())}})}function ks(s){const e=s.get.bind(s),t=s.has.bind(s);return s.get=r=>dE(r,e,t,s),s.has=r=>uE(r,t,s),s}function nd(s){return{...s,root:ks(s.root),datastore:ks(s.datastore),pins:ks(s.pins),keys:ks(s.keys)}}async function hE(s,e,t=()=>{}){const r=xn(e);if(!r){t(`${s} did not need an upgrade`);return}t(`Upgrading ${s}`),await id(r,(a,i)=>[{type:"del",key:a},{type:"put",key:Q(a),value:i}])}async function fE(s,e,t=()=>{}){const r=xn(e);if(!r){t(`${s} did not need a downgrade`);return}t(`Downgrading ${s}`),await id(r,(a,i)=>[{type:"del",key:a},{type:"put",key:R(a),value:i}])}function ad(s){return s.child?ad(s.child):s}async function Ec(s,e,t){const r=Object.entries(s).map(([i,o])=>({key:i,backend:ad(o)})).filter(({key:i,backend:o})=>o.constructor.name==="LevelDatastore").map(({key:i,backend:o})=>({name:i,store:o}));e(0,`Migrating ${r.length} dbs`);let n=0;const a=i=>{e(Math.round(n/r.length*100),i)};for(const{name:i,store:o}of r){await o.open();try{await t(i,o,a)}finally{n++,await o.close()}}e(100,`Migrated ${r.length} dbs`)}const pE={version:10,description:"Migrates datastore-level keys to binary",migrate:(s,e=()=>{})=>Ec(s,e,hE),revert:(s,e=()=>{})=>Ec(s,e,fE)};function id(s,e){function t(r,n){const a=s.store("readwrite"),i=a.transaction;let o=0,c;i.onabort=()=>n(c||i.error||new Error("aborted by user")),i.oncomplete=()=>n();function l(){const u=r[o++],d=u.key;let h;try{h=u.type==="del"?a.delete(d):a.put(u.value,d)}catch(f){c=f,i.abort();return}o<r.length&&(h.onsuccess=l)}l()}return new Promise((r,n)=>{const a=s.iterator(),i=c=>c;a._deserializeKey=a._deserializeValue=i,o();function o(){const c=(l,u,d)=>{if(l||u===void 0){const h=f=>{if(f){n(f);return}r()};a.end(h);return}t(e(u,d),o)};a.next(c)}})}const yt=new ae("/local/filesroot");async function yE(s,e=()=>{}){if(e(100,"Migrating MFS root to repo datastore"),await s.root.open(),await s.datastore.open(),await s.root.has(yt)){const t=await s.root.get(yt);await s.datastore.put(yt,t),await s.root.delete(yt)}await s.datastore.close(),await s.root.close(),e(100,"Stored MFS root in repo datastore")}async function wE(s,e=()=>{}){if(e(100,"Migrating MFS root to repo root datastore"),await s.root.open(),await s.datastore.open(),await s.datastore.has(yt)){const t=await s.datastore.get(yt);await s.root.put(yt,t),await s.datastore.delete(yt)}await s.datastore.close(),await s.root.close(),e(100,"Stored MFS root in repo root datastore")}const gE={version:11,description:"Store mfs root in the datastore",migrate:yE,revert:wE},vc=D.Reader,bE=D.Writer,mE=D.util,$s=D.roots.default||(D.roots.default={}),od=$s.Protocols=(()=>{function s(e){if(this.protocols=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return s.prototype.protocols=mE.emptyArray,s.encode=function(t,r){if(r||(r=bE.create()),t.protocols!=null&&t.protocols.length)for(var n=0;n<t.protocols.length;++n)r.uint32(10).string(t.protocols[n]);return r},s.decode=function(t,r){t instanceof vc||(t=vc.create(t));for(var n=r===void 0?t.len:t.pos+r,a=new $s.Protocols;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:a.protocols&&a.protocols.length||(a.protocols=[]),a.protocols.push(t.string());break;default:t.skipType(i&7);break}}return a},s.fromObject=function(t){if(t instanceof $s.Protocols)return t;var r=new $s.Protocols;if(t.protocols){if(!Array.isArray(t.protocols))throw TypeError(".Protocols.protocols: array expected");r.protocols=[];for(var n=0;n<t.protocols.length;++n)r.protocols[n]=String(t.protocols[n])}return r},s.toObject=function(t,r){r||(r={});var n={};if((r.arrays||r.defaults)&&(n.protocols=[]),t.protocols&&t.protocols.length){n.protocols=[];for(var a=0;a<t.protocols.length;++a)n.protocols[a]=t.protocols[a]}return n},s.prototype.toJSON=function(){return this.constructor.toObject(this,D.util.toJSONOptions)},s})(),Mt=D.Reader,oa=D.Writer,X=D.util,fe=D.roots.default||(D.roots.default={}),cd=fe.Addresses=(()=>{function s(e){if(this.addrs=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return s.prototype.addrs=X.emptyArray,s.prototype.certifiedRecord=null,s.encode=function(t,r){if(r||(r=oa.create()),t.addrs!=null&&t.addrs.length)for(var n=0;n<t.addrs.length;++n)fe.Addresses.Address.encode(t.addrs[n],r.uint32(10).fork()).ldelim();return t.certifiedRecord!=null&&Object.hasOwnProperty.call(t,"certifiedRecord")&&fe.Addresses.CertifiedRecord.encode(t.certifiedRecord,r.uint32(18).fork()).ldelim(),r},s.decode=function(t,r){t instanceof Mt||(t=Mt.create(t));for(var n=r===void 0?t.len:t.pos+r,a=new fe.Addresses;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:a.addrs&&a.addrs.length||(a.addrs=[]),a.addrs.push(fe.Addresses.Address.decode(t,t.uint32()));break;case 2:a.certifiedRecord=fe.Addresses.CertifiedRecord.decode(t,t.uint32());break;default:t.skipType(i&7);break}}return a},s.fromObject=function(t){if(t instanceof fe.Addresses)return t;var r=new fe.Addresses;if(t.addrs){if(!Array.isArray(t.addrs))throw TypeError(".Addresses.addrs: array expected");r.addrs=[];for(var n=0;n<t.addrs.length;++n){if(typeof t.addrs[n]!="object")throw TypeError(".Addresses.addrs: object expected");r.addrs[n]=fe.Addresses.Address.fromObject(t.addrs[n])}}if(t.certifiedRecord!=null){if(typeof t.certifiedRecord!="object")throw TypeError(".Addresses.certifiedRecord: object expected");r.certifiedRecord=fe.Addresses.CertifiedRecord.fromObject(t.certifiedRecord)}return r},s.toObject=function(t,r){r||(r={});var n={};if((r.arrays||r.defaults)&&(n.addrs=[]),r.defaults&&(n.certifiedRecord=null),t.addrs&&t.addrs.length){n.addrs=[];for(var a=0;a<t.addrs.length;++a)n.addrs[a]=fe.Addresses.Address.toObject(t.addrs[a],r)}return t.certifiedRecord!=null&&t.hasOwnProperty("certifiedRecord")&&(n.certifiedRecord=fe.Addresses.CertifiedRecord.toObject(t.certifiedRecord,r)),n},s.prototype.toJSON=function(){return this.constructor.toObject(this,D.util.toJSONOptions)},s.Address=function(){function e(r){if(r)for(var n=Object.keys(r),a=0;a<n.length;++a)r[n[a]]!=null&&(this[n[a]]=r[n[a]])}e.prototype.multiaddr=X.newBuffer([]),e.prototype.isCertified=null;let t;return Object.defineProperty(e.prototype,"_isCertified",{get:X.oneOfGetter(t=["isCertified"]),set:X.oneOfSetter(t)}),e.encode=function(n,a){return a||(a=oa.create()),n.multiaddr!=null&&Object.hasOwnProperty.call(n,"multiaddr")&&a.uint32(10).bytes(n.multiaddr),n.isCertified!=null&&Object.hasOwnProperty.call(n,"isCertified")&&a.uint32(16).bool(n.isCertified),a},e.decode=function(n,a){n instanceof Mt||(n=Mt.create(n));for(var i=a===void 0?n.len:n.pos+a,o=new fe.Addresses.Address;n.pos<i;){var c=n.uint32();switch(c>>>3){case 1:o.multiaddr=n.bytes();break;case 2:o.isCertified=n.bool();break;default:n.skipType(c&7);break}}return o},e.fromObject=function(n){if(n instanceof fe.Addresses.Address)return n;var a=new fe.Addresses.Address;return n.multiaddr!=null&&(typeof n.multiaddr=="string"?X.base64.decode(n.multiaddr,a.multiaddr=X.newBuffer(X.base64.length(n.multiaddr)),0):n.multiaddr.length&&(a.multiaddr=n.multiaddr)),n.isCertified!=null&&(a.isCertified=!!n.isCertified),a},e.toObject=function(n,a){a||(a={});var i={};return a.defaults&&(a.bytes===String?i.multiaddr="":(i.multiaddr=[],a.bytes!==Array&&(i.multiaddr=X.newBuffer(i.multiaddr)))),n.multiaddr!=null&&n.hasOwnProperty("multiaddr")&&(i.multiaddr=a.bytes===String?X.base64.encode(n.multiaddr,0,n.multiaddr.length):a.bytes===Array?Array.prototype.slice.call(n.multiaddr):n.multiaddr),n.isCertified!=null&&n.hasOwnProperty("isCertified")&&(i.isCertified=n.isCertified,a.oneofs&&(i._isCertified="isCertified")),i},e.prototype.toJSON=function(){return this.constructor.toObject(this,D.util.toJSONOptions)},e}(),s.CertifiedRecord=function(){function e(t){if(t)for(var r=Object.keys(t),n=0;n<r.length;++n)t[r[n]]!=null&&(this[r[n]]=t[r[n]])}return e.prototype.seq=X.Long?X.Long.fromBits(0,0,!0):0,e.prototype.raw=X.newBuffer([]),e.encode=function(r,n){return n||(n=oa.create()),r.seq!=null&&Object.hasOwnProperty.call(r,"seq")&&n.uint32(8).uint64(r.seq),r.raw!=null&&Object.hasOwnProperty.call(r,"raw")&&n.uint32(18).bytes(r.raw),n},e.decode=function(r,n){r instanceof Mt||(r=Mt.create(r));for(var a=n===void 0?r.len:r.pos+n,i=new fe.Addresses.CertifiedRecord;r.pos<a;){var o=r.uint32();switch(o>>>3){case 1:i.seq=r.uint64();break;case 2:i.raw=r.bytes();break;default:r.skipType(o&7);break}}return i},e.fromObject=function(r){if(r instanceof fe.Addresses.CertifiedRecord)return r;var n=new fe.Addresses.CertifiedRecord;return r.seq!=null&&(X.Long?(n.seq=X.Long.fromValue(r.seq)).unsigned=!0:typeof r.seq=="string"?n.seq=parseInt(r.seq,10):typeof r.seq=="number"?n.seq=r.seq:typeof r.seq=="object"&&(n.seq=new X.LongBits(r.seq.low>>>0,r.seq.high>>>0).toNumber(!0))),r.raw!=null&&(typeof r.raw=="string"?X.base64.decode(r.raw,n.raw=X.newBuffer(X.base64.length(r.raw)),0):r.raw.length&&(n.raw=r.raw)),n},e.toObject=function(r,n){n||(n={});var a={};if(n.defaults){if(X.Long){var i=new X.Long(0,0,!0);a.seq=n.longs===String?i.toString():n.longs===Number?i.toNumber():i}else a.seq=n.longs===String?"0":0;n.bytes===String?a.raw="":(a.raw=[],n.bytes!==Array&&(a.raw=X.newBuffer(a.raw)))}return r.seq!=null&&r.hasOwnProperty("seq")&&(typeof r.seq=="number"?a.seq=n.longs===String?String(r.seq):r.seq:a.seq=n.longs===String?X.Long.prototype.toString.call(r.seq):n.longs===Number?new X.LongBits(r.seq.low>>>0,r.seq.high>>>0).toNumber(!0):r.seq),r.raw!=null&&r.hasOwnProperty("raw")&&(a.raw=n.bytes===String?X.base64.encode(r.raw,0,r.raw.length):n.bytes===Array?Array.prototype.slice.call(r.raw):r.raw),a},e.prototype.toJSON=function(){return this.constructor.toObject(this,D.util.toJSONOptions)},e}(),s})(),rr=D.Reader,Ki=D.Writer,K=D.util,ce=D.roots.default||(D.roots.default={}),ld=ce.Peer=(()=>{function s(t){if(this.addresses=[],this.protocols=[],this.metadata=[],t)for(var r=Object.keys(t),n=0;n<r.length;++n)t[r[n]]!=null&&(this[r[n]]=t[r[n]])}s.prototype.addresses=K.emptyArray,s.prototype.protocols=K.emptyArray,s.prototype.metadata=K.emptyArray,s.prototype.pubKey=null,s.prototype.peerRecordEnvelope=null;let e;return Object.defineProperty(s.prototype,"_pubKey",{get:K.oneOfGetter(e=["pubKey"]),set:K.oneOfSetter(e)}),Object.defineProperty(s.prototype,"_peerRecordEnvelope",{get:K.oneOfGetter(e=["peerRecordEnvelope"]),set:K.oneOfSetter(e)}),s.encode=function(r,n){if(n||(n=Ki.create()),r.addresses!=null&&r.addresses.length)for(var a=0;a<r.addresses.length;++a)ce.Address.encode(r.addresses[a],n.uint32(10).fork()).ldelim();if(r.protocols!=null&&r.protocols.length)for(var a=0;a<r.protocols.length;++a)n.uint32(18).string(r.protocols[a]);if(r.metadata!=null&&r.metadata.length)for(var a=0;a<r.metadata.length;++a)ce.Metadata.encode(r.metadata[a],n.uint32(26).fork()).ldelim();return r.pubKey!=null&&Object.hasOwnProperty.call(r,"pubKey")&&n.uint32(34).bytes(r.pubKey),r.peerRecordEnvelope!=null&&Object.hasOwnProperty.call(r,"peerRecordEnvelope")&&n.uint32(42).bytes(r.peerRecordEnvelope),n},s.decode=function(r,n){r instanceof rr||(r=rr.create(r));for(var a=n===void 0?r.len:r.pos+n,i=new ce.Peer;r.pos<a;){var o=r.uint32();switch(o>>>3){case 1:i.addresses&&i.addresses.length||(i.addresses=[]),i.addresses.push(ce.Address.decode(r,r.uint32()));break;case 2:i.protocols&&i.protocols.length||(i.protocols=[]),i.protocols.push(r.string());break;case 3:i.metadata&&i.metadata.length||(i.metadata=[]),i.metadata.push(ce.Metadata.decode(r,r.uint32()));break;case 4:i.pubKey=r.bytes();break;case 5:i.peerRecordEnvelope=r.bytes();break;default:r.skipType(o&7);break}}return i},s.fromObject=function(r){if(r instanceof ce.Peer)return r;var n=new ce.Peer;if(r.addresses){if(!Array.isArray(r.addresses))throw TypeError(".Peer.addresses: array expected");n.addresses=[];for(var a=0;a<r.addresses.length;++a){if(typeof r.addresses[a]!="object")throw TypeError(".Peer.addresses: object expected");n.addresses[a]=ce.Address.fromObject(r.addresses[a])}}if(r.protocols){if(!Array.isArray(r.protocols))throw TypeError(".Peer.protocols: array expected");n.protocols=[];for(var a=0;a<r.protocols.length;++a)n.protocols[a]=String(r.protocols[a])}if(r.metadata){if(!Array.isArray(r.metadata))throw TypeError(".Peer.metadata: array expected");n.metadata=[];for(var a=0;a<r.metadata.length;++a){if(typeof r.metadata[a]!="object")throw TypeError(".Peer.metadata: object expected");n.metadata[a]=ce.Metadata.fromObject(r.metadata[a])}}return r.pubKey!=null&&(typeof r.pubKey=="string"?K.base64.decode(r.pubKey,n.pubKey=K.newBuffer(K.base64.length(r.pubKey)),0):r.pubKey.length&&(n.pubKey=r.pubKey)),r.peerRecordEnvelope!=null&&(typeof r.peerRecordEnvelope=="string"?K.base64.decode(r.peerRecordEnvelope,n.peerRecordEnvelope=K.newBuffer(K.base64.length(r.peerRecordEnvelope)),0):r.peerRecordEnvelope.length&&(n.peerRecordEnvelope=r.peerRecordEnvelope)),n},s.toObject=function(r,n){n||(n={});var a={};if((n.arrays||n.defaults)&&(a.addresses=[],a.protocols=[],a.metadata=[]),r.addresses&&r.addresses.length){a.addresses=[];for(var i=0;i<r.addresses.length;++i)a.addresses[i]=ce.Address.toObject(r.addresses[i],n)}if(r.protocols&&r.protocols.length){a.protocols=[];for(var i=0;i<r.protocols.length;++i)a.protocols[i]=r.protocols[i]}if(r.metadata&&r.metadata.length){a.metadata=[];for(var i=0;i<r.metadata.length;++i)a.metadata[i]=ce.Metadata.toObject(r.metadata[i],n)}return r.pubKey!=null&&r.hasOwnProperty("pubKey")&&(a.pubKey=n.bytes===String?K.base64.encode(r.pubKey,0,r.pubKey.length):n.bytes===Array?Array.prototype.slice.call(r.pubKey):r.pubKey,n.oneofs&&(a._pubKey="pubKey")),r.peerRecordEnvelope!=null&&r.hasOwnProperty("peerRecordEnvelope")&&(a.peerRecordEnvelope=n.bytes===String?K.base64.encode(r.peerRecordEnvelope,0,r.peerRecordEnvelope.length):n.bytes===Array?Array.prototype.slice.call(r.peerRecordEnvelope):r.peerRecordEnvelope,n.oneofs&&(a._peerRecordEnvelope="peerRecordEnvelope")),a},s.prototype.toJSON=function(){return this.constructor.toObject(this,D.util.toJSONOptions)},s})();ce.Address=(()=>{function s(t){if(t)for(var r=Object.keys(t),n=0;n<r.length;++n)t[r[n]]!=null&&(this[r[n]]=t[r[n]])}s.prototype.multiaddr=K.newBuffer([]),s.prototype.isCertified=null;let e;return Object.defineProperty(s.prototype,"_isCertified",{get:K.oneOfGetter(e=["isCertified"]),set:K.oneOfSetter(e)}),s.encode=function(r,n){return n||(n=Ki.create()),r.multiaddr!=null&&Object.hasOwnProperty.call(r,"multiaddr")&&n.uint32(10).bytes(r.multiaddr),r.isCertified!=null&&Object.hasOwnProperty.call(r,"isCertified")&&n.uint32(16).bool(r.isCertified),n},s.decode=function(r,n){r instanceof rr||(r=rr.create(r));for(var a=n===void 0?r.len:r.pos+n,i=new ce.Address;r.pos<a;){var o=r.uint32();switch(o>>>3){case 1:i.multiaddr=r.bytes();break;case 2:i.isCertified=r.bool();break;default:r.skipType(o&7);break}}return i},s.fromObject=function(r){if(r instanceof ce.Address)return r;var n=new ce.Address;return r.multiaddr!=null&&(typeof r.multiaddr=="string"?K.base64.decode(r.multiaddr,n.multiaddr=K.newBuffer(K.base64.length(r.multiaddr)),0):r.multiaddr.length&&(n.multiaddr=r.multiaddr)),r.isCertified!=null&&(n.isCertified=!!r.isCertified),n},s.toObject=function(r,n){n||(n={});var a={};return n.defaults&&(n.bytes===String?a.multiaddr="":(a.multiaddr=[],n.bytes!==Array&&(a.multiaddr=K.newBuffer(a.multiaddr)))),r.multiaddr!=null&&r.hasOwnProperty("multiaddr")&&(a.multiaddr=n.bytes===String?K.base64.encode(r.multiaddr,0,r.multiaddr.length):n.bytes===Array?Array.prototype.slice.call(r.multiaddr):r.multiaddr),r.isCertified!=null&&r.hasOwnProperty("isCertified")&&(a.isCertified=r.isCertified,n.oneofs&&(a._isCertified="isCertified")),a},s.prototype.toJSON=function(){return this.constructor.toObject(this,D.util.toJSONOptions)},s})();ce.Metadata=(()=>{function s(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return s.prototype.key="",s.prototype.value=K.newBuffer([]),s.encode=function(t,r){return r||(r=Ki.create()),t.key!=null&&Object.hasOwnProperty.call(t,"key")&&r.uint32(10).string(t.key),t.value!=null&&Object.hasOwnProperty.call(t,"value")&&r.uint32(18).bytes(t.value),r},s.decode=function(t,r){t instanceof rr||(t=rr.create(t));for(var n=r===void 0?t.len:t.pos+r,a=new ce.Metadata;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:a.key=t.string();break;case 2:a.value=t.bytes();break;default:t.skipType(i&7);break}}return a},s.fromObject=function(t){if(t instanceof ce.Metadata)return t;var r=new ce.Metadata;return t.key!=null&&(r.key=String(t.key)),t.value!=null&&(typeof t.value=="string"?K.base64.decode(t.value,r.value=K.newBuffer(K.base64.length(t.value)),0):t.value.length&&(r.value=t.value)),r},s.toObject=function(t,r){r||(r={});var n={};return r.defaults&&(n.key="",r.bytes===String?n.value="":(n.value=[],r.bytes!==Array&&(n.value=K.newBuffer(n.value)))),t.key!=null&&t.hasOwnProperty("key")&&(n.key=t.key),t.value!=null&&t.hasOwnProperty("value")&&(n.value=r.bytes===String?K.base64.encode(t.value,0,t.value.length):r.bytes===Array?Array.prototype.slice.call(t.value):t.value),n},s.prototype.toJSON=function(){return this.constructor.toObject(this,D.util.toJSONOptions)},s})();const Dc=D.Reader,_E=D.Writer,Y=D.util,Ps=D.roots.default||(D.roots.default={}),EE=Ps.Envelope=(()=>{function s(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return s.prototype.publicKey=Y.newBuffer([]),s.prototype.payloadType=Y.newBuffer([]),s.prototype.payload=Y.newBuffer([]),s.prototype.signature=Y.newBuffer([]),s.encode=function(t,r){return r||(r=_E.create()),t.publicKey!=null&&Object.hasOwnProperty.call(t,"publicKey")&&r.uint32(10).bytes(t.publicKey),t.payloadType!=null&&Object.hasOwnProperty.call(t,"payloadType")&&r.uint32(18).bytes(t.payloadType),t.payload!=null&&Object.hasOwnProperty.call(t,"payload")&&r.uint32(26).bytes(t.payload),t.signature!=null&&Object.hasOwnProperty.call(t,"signature")&&r.uint32(42).bytes(t.signature),r},s.decode=function(t,r){t instanceof Dc||(t=Dc.create(t));for(var n=r===void 0?t.len:t.pos+r,a=new Ps.Envelope;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:a.publicKey=t.bytes();break;case 2:a.payloadType=t.bytes();break;case 3:a.payload=t.bytes();break;case 5:a.signature=t.bytes();break;default:t.skipType(i&7);break}}return a},s.fromObject=function(t){if(t instanceof Ps.Envelope)return t;var r=new Ps.Envelope;return t.publicKey!=null&&(typeof t.publicKey=="string"?Y.base64.decode(t.publicKey,r.publicKey=Y.newBuffer(Y.base64.length(t.publicKey)),0):t.publicKey.length&&(r.publicKey=t.publicKey)),t.payloadType!=null&&(typeof t.payloadType=="string"?Y.base64.decode(t.payloadType,r.payloadType=Y.newBuffer(Y.base64.length(t.payloadType)),0):t.payloadType.length&&(r.payloadType=t.payloadType)),t.payload!=null&&(typeof t.payload=="string"?Y.base64.decode(t.payload,r.payload=Y.newBuffer(Y.base64.length(t.payload)),0):t.payload.length&&(r.payload=t.payload)),t.signature!=null&&(typeof t.signature=="string"?Y.base64.decode(t.signature,r.signature=Y.newBuffer(Y.base64.length(t.signature)),0):t.signature.length&&(r.signature=t.signature)),r},s.toObject=function(t,r){r||(r={});var n={};return r.defaults&&(r.bytes===String?n.publicKey="":(n.publicKey=[],r.bytes!==Array&&(n.publicKey=Y.newBuffer(n.publicKey))),r.bytes===String?n.payloadType="":(n.payloadType=[],r.bytes!==Array&&(n.payloadType=Y.newBuffer(n.payloadType))),r.bytes===String?n.payload="":(n.payload=[],r.bytes!==Array&&(n.payload=Y.newBuffer(n.payload))),r.bytes===String?n.signature="":(n.signature=[],r.bytes!==Array&&(n.signature=Y.newBuffer(n.signature)))),t.publicKey!=null&&t.hasOwnProperty("publicKey")&&(n.publicKey=r.bytes===String?Y.base64.encode(t.publicKey,0,t.publicKey.length):r.bytes===Array?Array.prototype.slice.call(t.publicKey):t.publicKey),t.payloadType!=null&&t.hasOwnProperty("payloadType")&&(n.payloadType=r.bytes===String?Y.base64.encode(t.payloadType,0,t.payloadType.length):r.bytes===Array?Array.prototype.slice.call(t.payloadType):t.payloadType),t.payload!=null&&t.hasOwnProperty("payload")&&(n.payload=r.bytes===String?Y.base64.encode(t.payload,0,t.payload.length):r.bytes===Array?Array.prototype.slice.call(t.payload):t.payload),t.signature!=null&&t.hasOwnProperty("signature")&&(n.signature=r.bytes===String?Y.base64.encode(t.signature,0,t.signature.length):r.bytes===Array?Array.prototype.slice.call(t.signature):t.signature),n},s.prototype.toJSON=function(){return this.constructor.toObject(this,D.util.toJSONOptions)},s})(),As=D.Reader,Sc=D.Writer,te=D.util,Fe=D.roots.default||(D.roots.default={}),vE=Fe.PeerRecord=(()=>{function s(e){if(this.addresses=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return s.prototype.peerId=te.newBuffer([]),s.prototype.seq=te.Long?te.Long.fromBits(0,0,!0):0,s.prototype.addresses=te.emptyArray,s.encode=function(t,r){if(r||(r=Sc.create()),t.peerId!=null&&Object.hasOwnProperty.call(t,"peerId")&&r.uint32(10).bytes(t.peerId),t.seq!=null&&Object.hasOwnProperty.call(t,"seq")&&r.uint32(16).uint64(t.seq),t.addresses!=null&&t.addresses.length)for(var n=0;n<t.addresses.length;++n)Fe.PeerRecord.AddressInfo.encode(t.addresses[n],r.uint32(26).fork()).ldelim();return r},s.decode=function(t,r){t instanceof As||(t=As.create(t));for(var n=r===void 0?t.len:t.pos+r,a=new Fe.PeerRecord;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:a.peerId=t.bytes();break;case 2:a.seq=t.uint64();break;case 3:a.addresses&&a.addresses.length||(a.addresses=[]),a.addresses.push(Fe.PeerRecord.AddressInfo.decode(t,t.uint32()));break;default:t.skipType(i&7);break}}return a},s.fromObject=function(t){if(t instanceof Fe.PeerRecord)return t;var r=new Fe.PeerRecord;if(t.peerId!=null&&(typeof t.peerId=="string"?te.base64.decode(t.peerId,r.peerId=te.newBuffer(te.base64.length(t.peerId)),0):t.peerId.length&&(r.peerId=t.peerId)),t.seq!=null&&(te.Long?(r.seq=te.Long.fromValue(t.seq)).unsigned=!0:typeof t.seq=="string"?r.seq=parseInt(t.seq,10):typeof t.seq=="number"?r.seq=t.seq:typeof t.seq=="object"&&(r.seq=new te.LongBits(t.seq.low>>>0,t.seq.high>>>0).toNumber(!0))),t.addresses){if(!Array.isArray(t.addresses))throw TypeError(".PeerRecord.addresses: array expected");r.addresses=[];for(var n=0;n<t.addresses.length;++n){if(typeof t.addresses[n]!="object")throw TypeError(".PeerRecord.addresses: object expected");r.addresses[n]=Fe.PeerRecord.AddressInfo.fromObject(t.addresses[n])}}return r},s.toObject=function(t,r){r||(r={});var n={};if((r.arrays||r.defaults)&&(n.addresses=[]),r.defaults)if(r.bytes===String?n.peerId="":(n.peerId=[],r.bytes!==Array&&(n.peerId=te.newBuffer(n.peerId))),te.Long){var a=new te.Long(0,0,!0);n.seq=r.longs===String?a.toString():r.longs===Number?a.toNumber():a}else n.seq=r.longs===String?"0":0;if(t.peerId!=null&&t.hasOwnProperty("peerId")&&(n.peerId=r.bytes===String?te.base64.encode(t.peerId,0,t.peerId.length):r.bytes===Array?Array.prototype.slice.call(t.peerId):t.peerId),t.seq!=null&&t.hasOwnProperty("seq")&&(typeof t.seq=="number"?n.seq=r.longs===String?String(t.seq):t.seq:n.seq=r.longs===String?te.Long.prototype.toString.call(t.seq):r.longs===Number?new te.LongBits(t.seq.low>>>0,t.seq.high>>>0).toNumber(!0):t.seq),t.addresses&&t.addresses.length){n.addresses=[];for(var i=0;i<t.addresses.length;++i)n.addresses[i]=Fe.PeerRecord.AddressInfo.toObject(t.addresses[i],r)}return n},s.prototype.toJSON=function(){return this.constructor.toObject(this,D.util.toJSONOptions)},s.AddressInfo=function(){function e(t){if(t)for(var r=Object.keys(t),n=0;n<r.length;++n)t[r[n]]!=null&&(this[r[n]]=t[r[n]])}return e.prototype.multiaddr=te.newBuffer([]),e.encode=function(r,n){return n||(n=Sc.create()),r.multiaddr!=null&&Object.hasOwnProperty.call(r,"multiaddr")&&n.uint32(10).bytes(r.multiaddr),n},e.decode=function(r,n){r instanceof As||(r=As.create(r));for(var a=n===void 0?r.len:r.pos+n,i=new Fe.PeerRecord.AddressInfo;r.pos<a;){var o=r.uint32();switch(o>>>3){case 1:i.multiaddr=r.bytes();break;default:r.skipType(o&7);break}}return i},e.fromObject=function(r){if(r instanceof Fe.PeerRecord.AddressInfo)return r;var n=new Fe.PeerRecord.AddressInfo;return r.multiaddr!=null&&(typeof r.multiaddr=="string"?te.base64.decode(r.multiaddr,n.multiaddr=te.newBuffer(te.base64.length(r.multiaddr)),0):r.multiaddr.length&&(n.multiaddr=r.multiaddr)),n},e.toObject=function(r,n){n||(n={});var a={};return n.defaults&&(n.bytes===String?a.multiaddr="":(a.multiaddr=[],n.bytes!==Array&&(a.multiaddr=te.newBuffer(a.multiaddr)))),r.multiaddr!=null&&r.hasOwnProperty("multiaddr")&&(a.multiaddr=n.bytes===String?te.base64.encode(r.multiaddr,0,r.multiaddr.length):n.bytes===Array?Array.prototype.slice.call(r.multiaddr):r.multiaddr),a},e.prototype.toJSON=function(){return this.constructor.toObject(this,D.util.toJSONOptions)},e}(),s})();D.util.Long=void 0;D.configure();async function DE(s,e=()=>{}){e(0,"Storing each peerstore key under a single datastore key"),await s.datastore.open();const t={},r=[];for await(const{key:n,value:a}of s.datastore.query({prefix:"/peers"})){r.push(n);const i=n.toString(),[,o,c,l,u]=i.split("/");if(o==="peers"&&["protos","addrs","metadata","keys"].includes(c)&&l)if(t[l]=t[l]||{addresses:[],protocols:[],metadata:[]},c==="protos"){const d=od.decode(a);t[l].protocols=d.protocols.sort()}else if(c==="addrs"){const d=cd.decode(a);t[l].addresses=d.addrs.sort((h,f)=>ie(h.multiaddr).toString().localeCompare(ie(f.multiaddr).toString())),d.certifiedRecord&&d.certifiedRecord.raw&&(t[l].peerRecordEnvelope=d.certifiedRecord.raw)}else c==="metadata"?t[l].metadata.push({key:u,value:a}):c==="keys"&&(t[l].pubKey=a)}e(33,"Read peer data from store");for(const n of r)await s.datastore.delete(n);e(66,"Removed existing peer data from store");for(const n of Object.keys(t)){const a=t[n];a.metadata=a.metadata.sort((o,c)=>o.key.localeCompare(c.key));const i=ld.encode(a).finish();await s.datastore.put(new ae(`/peers/${n}`),i)}await s.datastore.close(),e(100,"Stored each peerstore key under a single datastore key")}async function SE(s,e=()=>{}){e(0,"Storing each peerstore key under a multiple datastore keys"),await s.datastore.open();const t={},r=[];for await(const{key:n,value:a}of s.datastore.query({prefix:"/peers"})){r.push(n);const i=n.toString(),[,,o]=i.split("/");t[o]=ld.decode(a)}e(33,"Read peer data from store");for(const n of r)await s.datastore.delete(n);e(66,"Removed existing peer data from store");for(const[n,a]of Object.entries(t)){if(a.protocols&&a.protocols.length>0&&await s.datastore.put(new ae(`/peers/protos/${n}`),od.encode({protocols:a.protocols}).finish()),a.addresses&&a.addresses.length>0){const i=a.peerRecordEnvelope;let o;if(i){const c=EE.decode(i),l=vE.decode(c.payload);o={raw:i,seq:l.seq}}await s.datastore.put(new ae(`/peers/addrs/${n}`),cd.encode({addrs:a.addresses,certifiedRecord:o}).finish())}if(a.metadata&&a.metadata.length>0)for(const{key:i,value:o}of a.metadata)await s.datastore.put(new ae(`/peers/metadata/${n}/${i}`),o);a.pubKey&&await s.datastore.put(new ae(`/peers/keys/${n}`),a.pubKey)}await s.datastore.close(),e(100,"Stored each peerstore key under multiple datastore keys")}const kE={version:12,description:"Store each peerstore peer under a single datastore key",migrate:DE,revert:SE},St={description:"Empty migration.",migrate:()=>{},revert:()=>{},empty:!0},Vi=[Object.assign({version:1},St),Object.assign({version:2},St),Object.assign({version:3},St),Object.assign({version:4},St),Object.assign({version:5},St),Object.assign({version:6},St),Object.assign({version:7},St),Z_,cE,pE,gE,kE];class Ln extends Error{constructor(e){super(e),this.name="NonReversibleMigrationError",this.code=Ln.code,this.message=e}}Ln.code="ERR_NON_REVERSIBLE_MIGRATION";class ls extends Error{constructor(e){super(e),this.name="NotInitializedRepoError",this.code=ls.code,this.message=e}}ls.code="ERR_NOT_INITIALIZED_REPO";class Bn extends Error{constructor(e){super(e),this.name="RequiredParameterError",this.code=Bn.code,this.message=e}}Bn.code="ERR_REQUIRED_PARAMETER";class jn extends Error{constructor(e){super(e),this.name="InvalidValueError",this.code=jn.code,this.message=e}}jn.code="ERR_INVALID_VALUE";class cr extends Error{constructor(e){super(e),this.name="MissingRepoOptionsError",this.code=cr.code,this.message=e}}cr.code="ERR_MISSING_REPO_OPTIONS";const $E=Object.freeze(Object.defineProperty({__proto__:null,InvalidValueError:jn,MissingRepoOptionsError:cr,NonReversibleMigrationError:Ln,NotInitializedRepoError:ls,RequiredParameterError:Bn},Symbol.toStringTag,{value:"Module"})),ca=ct("ipfs:repo:migrator:repo:init");async function PE(s){if(!s)throw new cr("Please pass repo options when trying to open a repo");const e=s.root;try{await e.open();const t=await e.has(qi),r=await e.has(lE);return!t||!r?(ca(`Version entry present: ${t}`),ca(`Config entry present: ${r}`),!1):!0}catch(t){return ca("While checking if repo is initialized error was thrown: "+t.message),!1}finally{if(e!==void 0)try{await e.close()}catch{}}}async function ud(s){if(!await PE(s))throw new ls("Repo is not initialized!");const e=s.root;await e.open();try{return parseInt(R(await e.get(qi)))}finally{await e.close()}}async function nn(s,e){if(!e)throw new cr("Please pass repo options when trying to open a repo");const t=e.root;await t.open(),await t.put(qi,Q(String(s))),await t.close()}const qe=ct("ipfs:repo:migrator");function AE(s){return s=s||Vi,!Array.isArray(s)||s.length===0?0:s[s.length-1].version}async function RE(s,e,t,r,n={}){const a=n.ignoreLock??!1,i=n.onProgress,o=n.isDryRun??!1,c=n.migrations??Vi;if(!s)throw new Me.RequiredParameterError("Path argument is required!");if(!t)throw new Me.RequiredParameterError("repoOptions argument is required!");if(!r)throw new Me.RequiredParameterError("toVersion argument is required!");if(!Number.isInteger(r)||r<=0)throw new Me.InvalidValueError("Version has to be positive integer!");e=nd(e);const l=await ud(e);if(l===r){qe("Nothing to migrate.");return}if(l>r)throw new Me.InvalidValueError(`Current repo's version (${l}) is higher then toVersion (${r}), you probably wanted to revert it?`);dd(c,l,r);let u;!o&&!a&&(u=await t.repoLock.lock(s));try{for(const d of c){if(r!==void 0&&d.version>r)break;if(!(d.version<=l)){qe(`Migrating version ${d.version}`);try{if(!o){let h=()=>{};i&&(h=(f,p)=>i(d.version,f.toFixed(2),p)),await d.migrate(e,h)}}catch(h){const f=d.version-1;throw qe(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${f}`),await nn(f,e),new Error(`During migration to version ${d.version} exception was raised: ${h.stack||h.message||h}`)}qe(`Migrating to version ${d.version} finished`)}}o||await nn(r||AE(c),e),qe("Repo successfully migrated",r!==void 0?`to version ${r}!`:"to latest version!")}finally{!o&&!a&&u&&await u.close()}}async function TE(s,e,t,r,n={}){const a=n.ignoreLock??!1,i=n.onProgress,o=n.isDryRun??!1,c=n.migrations??Vi;if(!s)throw new Me.RequiredParameterError("Path argument is required!");if(!t)throw new Me.RequiredParameterError("repoOptions argument is required!");if(!r)throw new Me.RequiredParameterError("When reverting migrations, you have to specify to which version to revert!");if(!Number.isInteger(r)||r<=0)throw new Me.InvalidValueError("Version has to be positive integer!");e=nd(e);const l=await ud(e);if(l===r){qe("Nothing to revert.");return}if(l<r)throw new Me.InvalidValueError(`Current repo's version (${l}) is lower then toVersion (${r}), you probably wanted to migrate it?`);dd(c,r,l,!0);let u;!o&&!a&&(u=await t.repoLock.lock(s)),qe(`Reverting from version ${l} to ${r}`);try{const d=c.slice().reverse();for(const h of d){if(h.version<=r)break;if(!(h.version>l)){qe(`Reverting migration version ${h.version}`);try{if(!o){let f=()=>{};i&&(f=(p,g)=>i(h.version,p.toFixed(2),g)),await h.revert(e,f)}}catch(f){const p=h.version;throw qe(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${p}`),await nn(p,e),f.message=`During reversion to version ${h.version} exception was raised: ${f.message}`,f}qe(`Reverting to version ${h.version} finished`)}}o||await nn(r,e),qe(`All migrations successfully reverted to version ${r}!`)}finally{!o&&!a&&u&&await u.close()}}function dd(s,e,t,r=!1){let n=0;for(const a of s){if(a.version>t)break;if(a.version>e){if(r&&!a.revert)throw new Me.NonReversibleMigrationError(`It is not possible to revert to version ${e} because migration version ${a.version} is not reversible. Cancelling reversion.`);n++}}if(n!==t-e)throw new Me.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${e} to ${t}`)}const Me=$E;class Mn extends Error{constructor(e){super(e),this.name="LockExistsError",this.code=Mn.code}}Mn.code="ERR_LOCK_EXISTS";class _t extends Error{constructor(e){super(e),this.name="NotFoundError",this.code=_t.code}}_t.code="ERR_NOT_FOUND";class zn extends Error{constructor(e){super(e),this.name="InvalidRepoVersionError",this.code=zn.code}}zn.code="ERR_INVALID_REPO_VERSION";const Cr="ERR_REPO_NOT_INITIALIZED",OE="ERR_REPO_ALREADY_OPEN",CE="ERR_REPO_ALREADY_CLOSED";async function hd(s,e,t){const r=await e(s);if(r)return r;const n=pd(t);return n?new Promise((a,i)=>{const o=n.store("readonly").get(s.toString());o.transaction.onabort=()=>{i(o.transaction.error)},o.transaction.oncomplete=()=>{a(!!o.result)}}):!1}async function fd(s,e,t,r){if(await t(s))return e(s);const n=pd(r);if(!n)throw new _t;return new Promise((a,i)=>{const o=n.store("readonly").get(s.toString());o.transaction.onabort=()=>{i(o.transaction.error)},o.transaction.oncomplete=()=>{if(o.result)return a(o.result);i(new _t)}})}function pd(s){let e=s;for(;e.db||e.child;)if(e=e.db||e.child,e.type==="level-js"||e.constructor.name==="Level")return e}const IE=ct("ipfs:repo:version"),la=new ae("version");function NE(s){return{async exists(){return hd(la,s.has.bind(s),s)},async get(){const e=await fd(la,s.get.bind(s),s.has.bind(s),s);return parseInt(R(e),10)},set(e){return s.put(la,Q(String(e)))},async check(e){const t=await this.get();return IE("comparing version: %s and %s",t,e),t===e||(t===6&&e===7||e===6&&t===7)}}}const xE=Ue.default?Ue.default:Ue,ua=new ae("config");function LE(s){const e=new xE({concurrency:1}),t={async getAll(a={}){const i=await fd(ua,s.get.bind(s),s.has.bind(s),s);return JSON.parse(R(i))},async get(a,i={}){if(a==null)throw new _t(`Key ${a} does not exist in config`);const o=await this.getAll(i),c=gi(o,a);if(c===void 0)throw new _t(`Key ${a} does not exist in config`);return c},set(a,i,o={}){if(typeof a!="string"&&!(a instanceof String))throw y(new Error("Invalid key type: "+typeof a),"ERR_INVALID_KEY");if(i===void 0||i instanceof Uint8Array)throw y(new Error("Invalid value type: "+typeof i),"ERR_INVALID_VALUE");return e.add(()=>r({key:a,value:i},o.signal))},replace(a,i={}){if(!a||a instanceof Uint8Array)throw y(new Error("Invalid value type: "+typeof a),"ERR_INVALID_VALUE");return e.add(()=>r({key:void 0,value:a},i.signal))},async exists(){return hd(ua,s.has.bind(s),s)}};return t;async function r(a,i){if(i&&i.aborted)return;const o=a.key,c=a.value;if(o){const l=await t.getAll();return typeof l=="object"&&l!==null&&re(l,o,c),n(l)}return n(c)}function n(a){const i=Q(JSON.stringify(a,null,2));return s.put(ua,i)}}const da=new ae("datastore_spec");function BE(s){return{exists(){return s.has(da)},async get(){const e=await s.get(da);return JSON.parse(R(e))},async set(e){return s.put(da,Q(JSON.stringify(Nh(e,{deep:!0}))))}}}const ha=new ae("api");function jE(s){return{async get(){const e=await s.get(ha);return e&&e.toString()},set(e){return s.put(ha,Q(e.toString()))},delete(){return s.delete(ha)}}}function ME(s){return{open(){return s.open()},close(){return s.close()},query(e,t){return s.query(e,t)},queryKeys(e,t){return s.queryKeys(e,t)},async get(e,t){const r=dt(e);return r.isIdentity?Promise.resolve(r.digest):s.get(e,t)},async*getMany(e,t){for await(const r of e)yield this.get(r,t)},async put(e,t,r){const{isIdentity:n}=dt(e);n||await s.put(e,t,r)},async*putMany(e,t){const r=Fs({objectMode:!0});(globalThis.process&&globalThis.process.nextTick?globalThis.process.nextTick:globalThis.setImmediate||globalThis.setTimeout)(async()=>{try{await wn(s.putMany(async function*(){for await(const{key:a,value:i}of e)dt(a).isIdentity||(yield{key:a,value:i}),r.push({key:a,value:i})}())),r.end()}catch(a){r.end(a)}}),yield*r},has(e,t){const{isIdentity:r}=dt(e);return r?Promise.resolve(!0):s.has(e,t)},delete(e,t){const{isIdentity:r}=dt(e);return r?Promise.resolve():s.delete(e,t)},deleteMany(e,t){return s.deleteMany(gn(e,r=>!dt(r).isIdentity),t)},batch(){const e=s.batch();return{put(t,r){const{isIdentity:n}=dt(t);n||e.put(t,r)},delete(t){const{isIdentity:r}=dt(t);r||e.delete(t)},commit:t=>e.commit(t)}}}}function dt(s){const e=w.asCID(s);if(e==null)throw y(new Error("Not a valid cid"),"ERR_INVALID_CID");return e.multihash.code!==Rt.code?{isIdentity:!1}:{isIdentity:!0,digest:e.multihash.digest}}const yd=ct("ipfs:repo:lock:memory"),wd="repo.lock",Ir={};async function zE(s){const e=s+"/"+wd;if(yd("locking %s",e),Ir[e]===!0)throw new Mn(`Lock already being held for file: ${e}`);return Ir[e]=!0,{async close(){Ir[e]&&delete Ir[e]}}}async function UE(s){const e=s+"/"+wd;return yd(`checking lock: ${e}`),!!Ir[e]}const gd={lock:zE,locked:UE},FE={autoMigrate:!0,onMigrationProgress:()=>{},repoOwner:!0,repoLock:gd},bd={Spec:{type:"mount",mounts:[{mountpoint:"/blocks",type:"measure",prefix:"flatfs.datastore",child:{type:"flatfs",path:"blocks",sync:!0,shardFunc:"/repo/flatfs/shard/v1/next-to-last/2"}},{mountpoint:"/",type:"measure",prefix:"leveldb.datastore",child:{type:"levelds",path:"datastore",compression:"none"}}]}};function Rs(s){const e=w.asCID(s);if(e==null)throw y(new Error("Not a valid cid"),"ERR_INVALID_CID");const t=he.encode(e.multihash.bytes);return new ae("/"+t.slice(1).toUpperCase(),!1)}function kc(s){return Et(he.decode(`b${s.toString().toLowerCase().substring(1)}`))}const HE=ct("ipfs:repo:utils:walk-dag");async function*an(s,e,t,r){try{const n=await e.get(s,r),a=await t(s.code),i=ji({bytes:n,cid:s,codec:a});for(const[,o]of i.links())yield o,yield*an(o,e,t,r)}catch(n){throw HE("Could not walk DAG for CID",s.toString(),n),n}}const qE=2048;function KE(s){const e=`Invalid type '${s}', must be one of {direct, indirect, recursive, all}`;return y(new Error(e),"ERR_INVALID_PIN_TYPE")}class VE{constructor({pinstore:e,blockstore:t,loadCodec:r}){this.pinstore=e,this.blockstore=t,this.loadCodec=r,this.log=ct("ipfs:repo:pin"),this.directPins=new Set,this.recursivePins=new Set}async pinDirectly(e,t={}){await this.blockstore.get(e,t);const r={depth:0};return e.version!==0&&(r.version=e.version),e.code!==V&&(r.codec=e.code),t.metadata&&(r.metadata=t.metadata),this.pinstore.put(Rs(e),Ks(r))}unpin(e,t){return this.pinstore.delete(Rs(e),t)}async pinRecursively(e,t={}){await this.fetchCompleteDag(e,t);const r={depth:1/0};e.version!==0&&(r.version=e.version),e.code!==V&&(r.codec=e.code),t.metadata&&(r.metadata=t.metadata),await this.pinstore.put(Rs(e),Ks(r))}async*directKeys(e){for await(const t of this.pinstore.query({filters:[r=>kt(r.value).depth===0]})){const r=kt(t.value),n=r.version||0,a=r.codec!=null?r.codec:V,i=kc(t.key);yield{cid:w.create(n,a,i),metadata:r.metadata}}}async*recursiveKeys(e){for await(const t of this.pinstore.query({filters:[r=>kt(r.value).depth===1/0]})){const r=kt(t.value),n=r.version||0,a=r.codec!=null?r.codec:V,i=kc(t.key);yield{cid:w.create(n,a,i),metadata:r.metadata}}}async*indirectKeys(e){for await(const{cid:t}of this.recursiveKeys())for await(const r of an(t,this.blockstore,this.loadCodec,e)){const n=[q.recursive];(await this.isPinnedWithType(r,n)).pinned||(yield r)}}async isPinnedWithType(e,t,r){Array.isArray(t)||(t=[t]);const n=t.includes(q.all),a=t.includes(q.direct),i=t.includes(q.recursive),o=t.includes(q.indirect);if(i||a||n){const u=await Hs(this.pinstore.query({prefix:Rs(e).toString(),filters:[d=>{if(n)return!0;const h=kt(d.value);return t.includes(h.depth===0?q.direct:q.recursive)}],limit:1}));if(u){const d=kt(u.value);return{cid:e,pinned:!0,reason:d.depth===0?q.direct:q.recursive,metadata:d.metadata}}}const c=this;async function*l(u,d){for await(const{cid:h}of d)for await(const f of an(h,c.blockstore,c.loadCodec))if(f.equals(u)){yield h;return}}if(n||o){const u=await Hs(l(e,this.recursiveKeys()));if(u)return{cid:e,pinned:!0,reason:q.indirect,parent:u}}return{cid:e,pinned:!1}}async fetchCompleteDag(e,t={}){const r=new xh({maxSize:t.cidCacheMaxSize??qE}),n=async(a,i)=>{if(r.has(a.toString()))return;r.set(a.toString(),!0);const o=await this.blockstore.get(a,i),c=await this.loadCodec(a.code),l=ji({bytes:o,cid:a,codec:c});await Promise.all([...l.links()].map(([,u])=>n(u,i)))};await n(e,t)}static checkPinType(e){if(typeof e!="string"||!Object.keys(q).includes(e))throw KE(e);return!0}}function WE(s,e){return{open(){return e.open()},close(){return e.close()},query(t,r){return e.query(t,r)},queryKeys(t,r){return e.queryKeys(t,r)},async get(t,r){return e.get(t,r)},async*getMany(t,r){yield*e.getMany(t,r)},async put(t,r,n){await e.put(t,r,n)},async*putMany(t,r){yield*e.putMany(t,r)},has(t,r){return e.has(t,r)},async delete(t,r){return await $c(t,s),e.delete(t,r)},deleteMany(t,r){return e.deleteMany(Ve(t,async n=>(await $c(n,s),n)),r)},batch(){return e.batch()}}}async function $c(s,e){const{pinned:t,reason:r}=await e.isPinnedWithType(s,q.all);if(t)throw y(new Error(`pinned: ${r}`),"ERR_BLOCK_PINNED")}const Vr=ct("ipfs:repo:gc"),JE=At().code,GE=256,QE=new ae("/local/filesroot");function XE({gcLock:s,pins:e,blockstore:t,root:r,loadCodec:n}){async function*a(){const i=Date.now();Vr("Creating set of marked blocks");const o=await s.writeLock();try{const c=await YE({pins:e,blockstore:t,root:r,loadCodec:n}),l=t.queryKeys({});yield*ZE({blockstore:t},c,l),Vr(`Complete (${Date.now()-i}ms)`)}finally{o()}}return a}async function YE({pins:s,blockstore:e,loadCodec:t,root:r}){const n=async function*(){let o;try{o=await r.get(QE)}catch(l){if(l.code===JE){Vr("No blocks in MFS");return}throw l}const c=w.decode(o);yield c,yield*an(c,e,t)}(),a=Ea(Ve(s.recursiveKeys(),({cid:o})=>o),s.indirectKeys(),Ve(s.directKeys(),({cid:o})=>o),n),i=new Set;for await(const o of Ea(a,n))i.add(he.encode(o.multihash.bytes));return i}async function*ZE({blockstore:s},e,t){let r=0,n=0;yield*it(wi(Ve(t,async i=>async function(){r++;try{const c=he.encode(i.multihash.bytes);if(e.has(c))return null;try{await s.delete(i),n++}catch(l){return{err:new Error(`Could not delete block with CID ${i}: ${l.message}`)}}return{cid:i}}catch(c){const l=`Could delete block with CID ${i}`;return Vr(l,c),{err:new Error(l+`: ${c.message}`)}}}),GE),i=>gn(i,Boolean)),Vr(`Marked set has ${e.size} unique blocks. Blockstore has ${r} blocks. Deleted ${n} blocks.`)}const Re=ct("ipfs:repo"),ev=Number.MAX_SAFE_INTEGER,tv="repoAutoMigrate";class rv{constructor(e,t,r,n){if(typeof e!="string")throw new Error("missing repo path");if(typeof t!="function")throw new Error("missing codec loader");this.options=_e(FE,n),this.closed=!0,this.path=e,this.root=r.root,this.datastore=r.datastore,this.keys=r.keys;const a=r.blocks,i=r.pins;this.pins=new VE({pinstore:i,blockstore:a,loadCodec:t});const o=WE(this.pins,a);this.blocks=ME(o),this.version=NE(this.root),this.config=LE(this.root),this.spec=BE(this.root),this.apiAddr=jE(this.root),this.gcLock=wl({name:e,singleProcess:this.options.repoOwner!==!1}),this.gc=XE({gcLock:this.gcLock,pins:this.pins,blockstore:this.blocks,root:this.root,loadCodec:t})}async init(e){Re("initializing at: %s",this.path),await this._openRoot(),await this.config.replace(nv(e)),await this.spec.set(av(e)),await this.version.set(js)}async isInitialized(){if(!this.closed)return!0;try{return await this._openRoot(),await this._checkInitialized(),await this.root.close(),!0}catch{return!1}}async open(){if(!this.closed)throw y(new Error("repo is already open"),OE);Re("opening at: %s",this.path);try{if(await this._openRoot(),await this._checkInitialized(),this._lockfile=await this._openLock(),Re("acquired repo.lock"),!await this.version.check(js))if(await this._isAutoMigrationEnabled())await this._migrate(js,{root:this.root,datastore:this.datastore,pins:this.pins.pinstore,blocks:this.pins.blockstore,keys:this.keys});else throw new zn("Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.");Re("creating datastore"),await this.datastore.open(),Re("creating blocks"),await this.blocks.open(),Re("creating keystore"),await this.keys.open(),Re("creating pins"),await this.pins.pinstore.open(),this.closed=!1,Re("all opened")}catch(e){if(this._lockfile)try{await this._closeLock(),this._lockfile=null}catch(t){Re("error removing lock",t)}throw e}}async _openRoot(){try{await this.root.open()}catch(e){if(e.message!=="Already open")throw e}}async _openLock(){const e=await this.options.repoLock.lock(this.path);if(typeof e.close!="function")throw y(new Error("Locks must have a close method"),"ERR_NO_CLOSE_FUNCTION");return e}_closeLock(){return this._lockfile&&this._lockfile.close()}async _checkInitialized(){Re("init check");let e;try{[e]=await Promise.all([this.config.exists(),this.spec.exists(),this.version.exists()])}catch(t){throw t.code==="ERR_NOT_FOUND"?y(new Error("repo is not initialized yet"),Cr,{path:this.path}):t}if(!e)throw y(new Error("repo is not initialized yet"),Cr,{path:this.path})}async close(){if(this.closed)throw y(new Error("repo is already closed"),CE);Re("closing at: %s",this.path);try{await this.apiAddr.delete()}catch(e){if(e.code!==Cr&&!e.message.startsWith("ENOENT"))throw e}await Promise.all([this.root,this.blocks,this.keys,this.datastore,this.pins.pinstore].map(e=>e&&e.close())),Re("unlocking"),this.closed=!0,await this._closeLock()}exists(){return this.version.exists()}async stat(){if(this.datastore&&this.keys){const[e,t,r,n,a]=await Promise.all([this._storageMaxStat(),this._blockStat(),this.version.get(),Pc(this.datastore),Pc(this.keys)]),i=t.size+n+a;return{repoPath:this.path,storageMax:e,version:r,numObjects:t.count,repoSize:i}}throw y(new Error("repo is not initialized yet"),Cr,{path:this.path})}async _isAutoMigrationEnabled(){if(this.options.autoMigrate!==void 0)return this.options.autoMigrate;let e;try{e=await this.config.get(tv)}catch(t){if(t.code===_t.code)e=!0;else throw t}return e}async _migrate(e,t){return await this.version.get()>e?(Re(`reverting to version ${e}`),TE(this.path,t,this.options,e,{ignoreLock:!0,onProgress:this.options.onMigrationProgress})):(Re(`migrating to version ${e}`),RE(this.path,t,this.options,e,{ignoreLock:!0,onProgress:this.options.onMigrationProgress}))}async _storageMaxStat(){try{const e=await this.config.get("Datastore.StorageMax");return BigInt(Lh(e))}catch{return BigInt(ev)}}async _blockStat(){let e=BigInt(0),t=BigInt(0);if(this.blocks)for await(const{key:r,value:n}of this.blocks.query({}))e+=BigInt(1),t+=BigInt(n.byteLength),t+=BigInt(r.bytes.byteLength);return{count:e,size:t}}}async function Pc(s){let e=BigInt(0);for await(const t of s.query({}))e+=BigInt(t.value.byteLength),e+=BigInt(t.key.uint8Array().byteLength);return e}function sv(s,e,t,r){return new rv(s,e,t,r)}function nv(s){return s.Datastore=Object.assign({},bd,gi(s,"datastore")),s}function av(s){const e={...bd.Spec,...gi(s,"Datastore.Spec")};return{type:e.type,mounts:e.mounts.map(t=>({mountpoint:t.mountpoint,type:t.child.type,path:t.child.path,shardFunc:t.child.shardFunc}))}}function iv(s,e,t){const r=t.path||"ipfs";return sv(r,n=>e.getCodec(n),{root:new fr(r,{prefix:"",version:2}),blocks:new Bh(new fr(`${r}/blocks`,{prefix:"",version:2})),datastore:new fr(`${r}/datastore`,{prefix:"",version:2}),keys:new fr(`${r}/keys`,{prefix:"",version:2}),pins:new fr(`${r}/pins`,{prefix:"",version:2})},{autoMigrate:t.autoMigrate,onMigrationProgress:t.onMigrationProgress||s,repoLock:gd})}function ov(s,e){if(s.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),r=0;r<t.length;r++)t[r]=255;for(var n=0;n<s.length;n++){var a=s.charAt(n),i=a.charCodeAt(0);if(t[i]!==255)throw new TypeError(a+" is ambiguous");t[i]=n}var o=s.length,c=s.charAt(0),l=Math.log(o)/Math.log(256),u=Math.log(256)/Math.log(o);function d(p){if(p instanceof Uint8Array||(ArrayBuffer.isView(p)?p=new Uint8Array(p.buffer,p.byteOffset,p.byteLength):Array.isArray(p)&&(p=Uint8Array.from(p))),!(p instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(p.length===0)return"";for(var g=0,_=0,v=0,k=p.length;v!==k&&p[v]===0;)v++,g++;for(var P=(k-v)*u+1>>>0,T=new Uint8Array(P);v!==k;){for(var I=p[v],x=0,C=P-1;(I!==0||x<_)&&C!==-1;C--,x++)I+=256*T[C]>>>0,T[C]=I%o>>>0,I=I/o>>>0;if(I!==0)throw new Error("Non-zero carry");_=x,v++}for(var S=P-_;S!==P&&T[S]===0;)S++;for(var L=c.repeat(g);S<P;++S)L+=s.charAt(T[S]);return L}function h(p){if(typeof p!="string")throw new TypeError("Expected String");if(p.length===0)return new Uint8Array;var g=0;if(p[g]!==" "){for(var _=0,v=0;p[g]===c;)_++,g++;for(var k=(p.length-g)*l+1>>>0,P=new Uint8Array(k);p[g];){var T=t[p.charCodeAt(g)];if(T===255)return;for(var I=0,x=k-1;(T!==0||I<v)&&x!==-1;x--,I++)T+=o*P[x]>>>0,P[x]=T%256>>>0,T=T/256>>>0;if(T!==0)throw new Error("Non-zero carry");v=I,g++}if(p[g]!==" "){for(var C=k-v;C!==k&&P[C]===0;)C++;for(var S=new Uint8Array(_+(k-C)),L=_;C!==k;)S[L++]=P[C++];return S}}}function f(p){var g=h(p);if(g)return g;throw new Error(`Non-${e} character`)}return{encode:d,decodeUnsafe:h,decode:f}}var cv=ov,lv=cv;const uv=s=>{if(s instanceof Uint8Array&&s.constructor.name==="Uint8Array")return s;if(s instanceof ArrayBuffer)return new Uint8Array(s);if(ArrayBuffer.isView(s))return new Uint8Array(s.buffer,s.byteOffset,s.byteLength);throw new Error("Unknown type, must be binary type")},dv=s=>new TextEncoder().encode(s),hv=s=>new TextDecoder().decode(s);let fv=class{constructor(e,t,r){this.name=e,this.prefix=t,this.baseEncode=r}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}},pv=class{constructor(e,t,r){if(this.name=e,this.prefix=t,t.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=r}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return md(this,e)}},yv=class{constructor(e){this.decoders=e}or(e){return md(this,e)}decode(e){const t=e[0],r=this.decoders[t];if(r)return r.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};const md=(s,e)=>new yv({...s.decoders||{[s.prefix]:s},...e.decoders||{[e.prefix]:e}});let wv=class{constructor(e,t,r,n){this.name=e,this.prefix=t,this.baseEncode=r,this.baseDecode=n,this.encoder=new fv(e,t,r),this.decoder=new pv(e,t,n)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}};const Un=({name:s,prefix:e,encode:t,decode:r})=>new wv(s,e,t,r),us=({prefix:s,name:e,alphabet:t})=>{const{encode:r,decode:n}=lv(t,e);return Un({prefix:s,name:e,encode:r,decode:a=>uv(n(a))})},gv=(s,e,t,r)=>{const n={};for(let u=0;u<e.length;++u)n[e[u]]=u;let a=s.length;for(;s[a-1]==="=";)--a;const i=new Uint8Array(a*t/8|0);let o=0,c=0,l=0;for(let u=0;u<a;++u){const d=n[s[u]];if(d===void 0)throw new SyntaxError(`Non-${r} character`);c=c<<t|d,o+=t,o>=8&&(o-=8,i[l++]=255&c>>o)}if(o>=t||255&c<<8-o)throw new SyntaxError("Unexpected end of data");return i},bv=(s,e,t)=>{const r=e[e.length-1]==="=",n=(1<<t)-1;let a="",i=0,o=0;for(let c=0;c<s.length;++c)for(o=o<<8|s[c],i+=8;i>t;)i-=t,a+=e[n&o>>i];if(i&&(a+=e[n&o<<t-i]),r)for(;a.length*t&7;)a+="=";return a},ve=({name:s,prefix:e,bitsPerChar:t,alphabet:r})=>Un({prefix:e,name:s,encode(n){return bv(n,r,t)},decode(n){return gv(n,r,t,s)}}),mv=us({prefix:"9",name:"base10",alphabet:"0123456789"}),_v=Object.freeze(Object.defineProperty({__proto__:null,base10:mv},Symbol.toStringTag,{value:"Module"})),Ev=ve({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),vv=ve({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),Dv=Object.freeze(Object.defineProperty({__proto__:null,base16:Ev,base16upper:vv},Symbol.toStringTag,{value:"Module"})),Sv=ve({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),kv=Object.freeze(Object.defineProperty({__proto__:null,base2:Sv},Symbol.toStringTag,{value:"Module"})),_d=Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),$v=_d.reduce((s,e,t)=>(s[t]=e,s),[]),Pv=_d.reduce((s,e,t)=>(s[e.codePointAt(0)]=t,s),[]);function Av(s){return s.reduce((e,t)=>(e+=$v[t],e),"")}function Rv(s){const e=[];for(const t of s){const r=Pv[t.codePointAt(0)];if(r===void 0)throw new Error(`Non-base256emoji character: ${t}`);e.push(r)}return new Uint8Array(e)}const Tv=Un({prefix:"🚀",name:"base256emoji",encode:Av,decode:Rv}),Ov=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:Tv},Symbol.toStringTag,{value:"Module"})),Cv=ve({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Iv=ve({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),Nv=ve({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),xv=ve({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Lv=ve({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Bv=ve({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),jv=ve({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Mv=ve({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),zv=ve({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),Uv=Object.freeze(Object.defineProperty({__proto__:null,base32:Cv,base32hex:Lv,base32hexpad:jv,base32hexpadupper:Mv,base32hexupper:Bv,base32pad:Nv,base32padupper:xv,base32upper:Iv,base32z:zv},Symbol.toStringTag,{value:"Module"})),Fv=us({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Hv=us({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),qv=Object.freeze(Object.defineProperty({__proto__:null,base36:Fv,base36upper:Hv},Symbol.toStringTag,{value:"Module"})),Kv=us({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),Vv=us({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),Wv=Object.freeze(Object.defineProperty({__proto__:null,base58btc:Kv,base58flickr:Vv},Symbol.toStringTag,{value:"Module"})),Jv=ve({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),Gv=ve({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Qv=ve({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Xv=ve({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),Yv=Object.freeze(Object.defineProperty({__proto__:null,base64:Jv,base64pad:Gv,base64url:Qv,base64urlpad:Xv},Symbol.toStringTag,{value:"Module"})),Zv=ve({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),eD=Object.freeze(Object.defineProperty({__proto__:null,base8:Zv},Symbol.toStringTag,{value:"Module"})),tD=Un({prefix:"\0",name:"identity",encode:s=>hv(s),decode:s=>dv(s)}),rD=Object.freeze(Object.defineProperty({__proto__:null,identity:tD},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;const iR={...rD,...kv,...eD,..._v,...Dv,...Uv,...qv,...Wv,...Yv,...Ov},sD=s=>Promise.reject(new Error(`No base found for "${s}"`));class Ed{constructor(e){this._basesByName={},this._basesByPrefix={},this._loadBase=e.loadBase||sD;for(const t of e.bases)this.addBase(t)}addBase(e){if(this._basesByName[e.name]||this._basesByPrefix[e.prefix])throw new Error(`Codec already exists for codec "${e.name}"`);this._basesByName[e.name]=e,this._basesByPrefix[e.prefix]=e}removeBase(e){delete this._basesByName[e.name],delete this._basesByPrefix[e.prefix]}async getBase(e){if(this._basesByName[e])return this._basesByName[e];if(this._basesByPrefix[e])return this._basesByPrefix[e];const t=await this._loadBase(e);return this._basesByName[t.name]==null&&this._basesByPrefix[t.prefix]==null&&this.addBase(t),t}listBases(){return Object.values(this._basesByName)}}const nD=s=>Promise.reject(new Error(`No codec found for "${s}"`));class vd{constructor(e){this._codecsByName={},this._codecsByCode={},this._loadCodec=e.loadCodec||nD;for(const t of e.codecs)this.addCodec(t)}addCodec(e){if(this._codecsByName[e.name]||this._codecsByCode[e.code])throw new Error(`Resolver already exists for codec "${e.name}"`);this._codecsByName[e.name]=e,this._codecsByCode[e.code]=e}removeCodec(e){delete this._codecsByName[e.name],delete this._codecsByCode[e.code]}async getCodec(e){const t=typeof e=="string"?this._codecsByName:this._codecsByCode;if(t[e])return t[e];const r=await this._loadCodec(e);return t[e]==null&&this.addCodec(r),r}listCodecs(){return Object.values(this._codecsByName)}}const aD=s=>Promise.reject(new Error(`No hasher found for "${s}"`));class Dd{constructor(e){this._hashersByName={},this._hashersByCode={},this._loadHasher=e.loadHasher||aD;for(const t of e.hashers)this.addHasher(t)}addHasher(e){if(this._hashersByName[e.name]||this._hashersByCode[e.code])throw new Error(`Resolver already exists for codec "${e.name}"`);this._hashersByName[e.name]=e,this._hashersByCode[e.code]=e}removeHasher(e){delete this._hashersByName[e.name],delete this._hashersByCode[e.code]}async getHasher(e){const t=typeof e=="string"?this._hashersByName:this._hashersByCode;if(t[e])return t[e];const r=await this._loadHasher(e);return t[e]==null&&this.addHasher(r),r}listHashers(){return Object.values(this._hashersByName)}}function Ac(s){try{s=Uu(ie(s))}catch{}return s=s.toString(),s}const iD=()=>{},Rc=M("ipfs-http-client:lib:error-handler"),oD=_e.bind({ignoreUndefined:!0}),cD=ot.isBrowser||ot.isWebWorker?location.protocol:"http",lD=ot.isBrowser||ot.isWebWorker?location.hostname:"localhost",uD=ot.isBrowser||ot.isWebWorker?location.port:"5001",dD=(s={})=>{let e,t={},r;if(typeof s=="string"||Ys(s))e=new URL(Ac(s));else if(s instanceof URL)e=s;else if(typeof s.url=="string"||Ys(s.url))e=new URL(Ac(s.url)),t=s;else if(s.url instanceof URL)e=s.url,t=s;else{t=s||{};const n=(t.protocol||cD).replace(":",""),a=(t.host||lD).split(":")[0],i=t.port||uD;e=new URL(`${n}://${a}:${i}`)}if(t.apiPath?e.pathname=t.apiPath:(e.pathname==="/"||e.pathname===void 0)&&(e.pathname="api/v0"),ot.isNode){const n=iD();r=t.agent||new n({keepAlive:!0,maxSockets:6})}return{...t,host:e.host,protocol:e.protocol.replace(":",""),port:Number(e.port),apiPath:e.pathname,url:e,agent:r}},hD=async s=>{let e;try{if((s.headers.get("Content-Type")||"").startsWith("application/json")){const r=await s.json();Rc(r),e=r.Message||r.message}else e=await s.text()}catch(r){Rc("Failed to parse error response",r),e=r.message}let t=new at.HTTPError(s);throw e&&(e.includes("deadline has elapsed")&&(t=new at.TimeoutError),e&&e.includes("context deadline exceeded")&&(t=new at.TimeoutError)),e&&e.includes("request timed out")&&(t=new at.TimeoutError),e&&(t.message=e),t},fD=/[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g,Tc=s=>s.replace(fD,function(e){return"-"+e.toLowerCase()}),pD=s=>typeof s=="string"?pn(s):s;class Wi extends at{constructor(e={}){const t=dD(e);super({timeout:pD(t.timeout||0)||void 0,headers:t.headers,base:`${t.url}`,handleError:hD,transformSearchParams:n=>{const a=new URLSearchParams;for(const[i,o]of n)o!=="undefined"&&o!=="null"&&i!=="signal"&&a.append(Tc(i),o),i==="timeout"&&!isNaN(o)&&a.append(Tc(i),o);return a},agent:t.agent}),delete this.get,delete this.put,delete this.delete,delete this.options;const r=this.fetch;this.fetch=(n,a={})=>(typeof n=="string"&&!n.startsWith("/")&&(n=`${t.url}/${n}`),r.call(this,n,oD(a,{method:"POST"})))}}at.HTTPError;const b=s=>e=>s(new Wi(e),e);function Sd(s){if(s!=null)return typeof s=="string"?s:s.toString(8).padStart(4,"0")}function kd(s){if(s==null)return;let e;if(s.secs!=null&&(e={secs:s.secs,nsecs:s.nsecs}),s.Seconds!=null&&(e={secs:s.Seconds,nsecs:s.FractionalNanoseconds}),Array.isArray(s)&&(e={secs:s[0],nsecs:s[1]}),s instanceof Date){const t=s.getTime(),r=Math.floor(t/1e3);e={secs:r,nsecs:(t-r*1e3)*1e3}}if(Object.prototype.hasOwnProperty.call(e,"secs")){if(e!=null&&e.nsecs!=null&&(e.nsecs<0||e.nsecs>999999999))throw y(new Error("mtime-nsecs must be within the range [0,999999999]"),"ERR_INVALID_MTIME_NSECS");return e}}function m({arg:s,searchParams:e,hashAlg:t,mtime:r,mode:n,...a}={}){e&&(a={...a,...e}),t&&(a.hash=t),r!=null&&(r=kd(r),a.mtime=r.secs,a.mtimeNsecs=r.nsecs),n!=null&&(a.mode=Sd(n)),a.timeout&&!isNaN(a.timeout)&&(a.timeout=`${a.timeout}ms`),s==null?s=[]:Array.isArray(s)||(s=[s]);const i=new URLSearchParams(a);return s.forEach(o=>i.append("arg",o)),i}const yD=b(s=>{async function e(t={}){return((await(await s.post("bitswap/wantlist",{signal:t.signal,searchParams:m(t),headers:t.headers})).json()).Keys||[]).map(n=>w.parse(n["/"]))}return e}),wD=b(s=>{async function e(t,r={}){return((await(await s.post("bitswap/wantlist",{signal:r.signal,searchParams:m({...r,peer:t.toString()}),headers:r.headers})).json()).Keys||[]).map(a=>w.parse(a["/"]))}return e}),$d=b(s=>{async function e(t={}){const r=await s.post("bitswap/stat",{searchParams:m(t),signal:t.signal,headers:t.headers});return gD(await r.json())}return e});function gD(s){return{provideBufLen:s.ProvideBufLen,wantlist:(s.Wantlist||[]).map(e=>w.parse(e["/"])),peers:(s.Peers||[]).map(e=>pe(e)),blocksReceived:BigInt(s.BlocksReceived),dataReceived:BigInt(s.DataReceived),blocksSent:BigInt(s.BlocksSent),dataSent:BigInt(s.DataSent),dupBlksReceived:BigInt(s.DupBlksReceived),dupDataReceived:BigInt(s.DupDataReceived)}}const bD=b(s=>{async function e(t,r={}){return(await s.post("bitswap/unwant",{signal:r.signal,searchParams:m({arg:t.toString(),...r}),headers:r.headers})).json()}return e});function mD(s){return{wantlist:yD(s),wantlistForPeer:wD(s),unwant:bD(s),stat:$d(s)}}const Pd=b(s=>{async function e(t,r={}){const n=await s.post("block/get",{signal:r.signal,searchParams:m({arg:t.toString(),...r}),headers:r.headers});return new Uint8Array(await n.arrayBuffer())}return e});async function _D(s){if(mt(s))return new Blob([s]);if(typeof s=="string"||s instanceof String)return new Blob([s.toString()]);if(Hr(s))return s;if(qr(s)&&(s=Gr(s)),Symbol.iterator in s||Symbol.asyncIterator in s){const e=Qr(s),{value:t,done:r}=await e.peek();if(r)return Oc(e);if(e.push(t),Number.isInteger(t))return new Blob([Uint8Array.from(await yi(e))]);if(mt(t)||typeof t=="string"||t instanceof String)return Oc(e)}throw y(new Error(`Unexpected input: ${s}`),"ERR_UNEXPECTED_INPUT")}async function Oc(s){const e=[];for await(const t of s)e.push(t);return new Blob(e)}function ED(s){return Ou(s,_D)}function vD(s){if(s!=null)return typeof s=="string"?s:s.toString(8).padStart(4,"0")}async function Ze(s,e,t={}){const r=[],n=new FormData;let a=0,i=0;for await(const{content:o,path:c,mode:l,mtime:u}of ED(s)){let d="";const h=o?"file":"dir";a>0&&(d=`-${a}`);let f=h+d;const p=[];if(l!=null&&p.push(`mode=${vD(l)}`),u!=null){const{secs:g,nsecs:_}=u;p.push(`mtime=${g}`),_!=null&&p.push(`mtime-nsecs=${_}`)}if(p.length&&(f=`${f}?${p.join("&")}`),o){n.set(f,o,c!=null?encodeURIComponent(c):void 0);const g=i+o.size;r.push({name:c,start:i,end:g}),i=g}else if(c!=null)n.set(f,new File([""],encodeURIComponent(c),{type:"application/x-directory"}));else throw new Error("path or content or both must be set");a++}return{total:i,parts:r,headers:t,body:n}}function DD(s){return s.filter(Boolean)}function et(...s){return yn(DD(s))}const SD=b(s=>{async function e(t,r={}){const n=new AbortController,a=et(n.signal,r.signal);let i;try{i=await(await s.post("block/put",{signal:a,searchParams:m(r),...await Ze([t],n,r.headers)})).json()}catch(o){if(r.format==="dag-pb")return e(t,{...r,format:"protobuf"});if(r.format==="dag-cbor")return e(t,{...r,format:"cbor"});throw o}return w.parse(i.Key)}return e}),kD=b(s=>{async function*e(t,r={}){Array.isArray(t)||(t=[t]);const n=await s.post("block/rm",{signal:r.signal,searchParams:m({arg:t.map(a=>a.toString()),"stream-channels":!0,...r}),headers:r.headers});for await(const a of n.ndjson())yield $D(a)}return e});function $D(s){const e={cid:w.parse(s.Hash)};return s.Error&&(e.error=new Error(s.Error)),e}const PD=b(s=>{async function e(t,r={}){const a=await(await s.post("block/stat",{signal:r.signal,searchParams:m({arg:t.toString(),...r}),headers:r.headers})).json();return{cid:w.parse(a.Key),size:a.Size}}return e});function AD(s){return{get:Pd(s),put:SD(s),rm:kD(s),stat:PD(s)}}const RD=b(s=>{async function e(t,r={}){const n=await s.post("bootstrap/add",{signal:r.signal,searchParams:m({arg:t,...r}),headers:r.headers}),{Peers:a}=await n.json();return{Peers:a.map(i=>ie(i))}}return e}),TD=b(s=>{async function e(t={}){const r=await s.post("bootstrap/rm",{signal:t.signal,searchParams:m({...t,all:!0}),headers:t.headers}),{Peers:n}=await r.json();return{Peers:n.map(a=>ie(a))}}return e}),OD=b(s=>{async function e(t={}){const r=await s.post("bootstrap/list",{signal:t.signal,searchParams:m(t),headers:t.headers}),{Peers:n}=await r.json();return{Peers:n.map(a=>ie(a))}}return e}),CD=b(s=>{async function e(t={}){const r=await s.post("bootstrap/add",{signal:t.signal,searchParams:m({...t,default:!0}),headers:t.headers}),{Peers:n}=await r.json();return{Peers:n.map(a=>ie(a))}}return e}),ID=b(s=>{async function e(t,r={}){const n=await s.post("bootstrap/rm",{signal:r.signal,searchParams:m({arg:t,...r}),headers:r.headers}),{Peers:a}=await n.json();return{Peers:a.map(i=>ie(i))}}return e});function ND(s){return{add:RD(s),clear:TD(s),list:OD(s),reset:CD(s),rm:ID(s)}}const xD=b(s=>{async function e(t,r={}){const a=await(await s.post("config/profile/apply",{signal:r.signal,searchParams:m({arg:t,...r}),headers:r.headers})).json();return{original:a.OldCfg,updated:a.NewCfg}}return e});function we(s){if(s==null)return s;const e=/^[A-Z]+$/,t={};return Object.keys(s).reduce((r,n)=>(e.test(n)?r[n.toLowerCase()]=s[n]:e.test(n[0])?r[n[0].toLowerCase()+n.slice(1)]=s[n]:r[n]=s[n],r),t)}const LD=b(s=>{async function e(t={}){return(await(await s.post("config/profile/list",{signal:t.signal,searchParams:m(t),headers:t.headers})).json()).map(a=>we(a))}return e});function BD(s){return{apply:xD(s),list:LD(s)}}const jD=b(s=>async(t,r={})=>{if(!t)throw new Error("key argument is required");return(await(await s.post("config",{signal:r.signal,searchParams:m({arg:t,...r}),headers:r.headers})).json()).Value}),MD=b(s=>async(t={})=>await(await s.post("config/show",{signal:t.signal,searchParams:m({...t}),headers:t.headers})).json()),zD=b(s=>async(t,r={})=>{const n=new AbortController,a=et(n.signal,r.signal);await(await s.post("config/replace",{signal:a,searchParams:m(r),...await Ze([Q(JSON.stringify(t))],n,r.headers)})).text()}),UD=b(s=>async(t,r,n={})=>{if(typeof t!="string")throw new Error("Invalid key type");const a={...n,...FD(t,r)};await(await s.post("config",{signal:n.signal,searchParams:m(a),headers:n.headers})).text()}),FD=(s,e)=>{switch(typeof e){case"boolean":return{arg:[s,e.toString()],bool:!0};case"string":return{arg:[s,e]};default:return{arg:[s,JSON.stringify(e)],json:!0}}};function HD(s){return{getAll:MD(s),get:jD(s),set:UD(s),replace:zD(s),profiles:BD(s)}}const qD=b(s=>{async function*e(t,r={}){yield*(await s.post("dag/export",{signal:r.signal,searchParams:m({arg:t.toString()}),headers:r.headers})).iterator()}return e});async function*Cc(s,e,t,r,n){const a=async l=>{const u=await t.getCodec(l.code),d=await r(l,n);return u.decode(d)},i=e.split("/").filter(Boolean);let o=await a(s),c=s;for(;i.length;){const l=i.shift();if(!l)throw y(new Error(`Could not resolve path "${e}"`),"ERR_INVALID_PATH");if(Object.prototype.hasOwnProperty.call(o,l))o=o[l],yield{value:o,remainderPath:i.join("/")};else throw y(new Error(`no link named "${l}" under ${c}`),"ERR_NO_LINK");const u=w.asCID(o);u&&(c=u,o=await a(o))}yield{value:o,remainderPath:""}}const KD=(s,e)=>b((r,n)=>{const a=Pd(n);return async(o,c={})=>{if(c.path){const f=c.localResolve?await Hs(Cc(o,c.path,s,a,c)):await Ce(Cc(o,c.path,s,a,c));if(!f)throw y(new Error("Not found"),"ERR_NOT_FOUND");return f}const l=await s.getCodec(o.code),u=await a(o,c);return{value:l.decode(u),remainderPath:""}}})(e),VD=b(s=>{async function*e(t,r={}){const n=new AbortController,a=et(n.signal,r.signal),{headers:i,body:o}=await Ze(t,n,r.headers),c=await s.post("dag/import",{signal:a,headers:i,body:o,searchParams:m({"pin-roots":r.pinRoots})});for await(const{Root:l}of c.ndjson())if(l!==void 0){const{Cid:{"/":u},PinErrorMsg:d}=l;yield{root:{cid:w.parse(u),pinErrorMsg:d}}}}return e}),Ad=(s,e)=>b(r=>async(a,i={})=>{const o={storeCodec:"dag-cbor",hashAlg:"sha2-256",...i};let c;if(o.inputCodec){if(!(a instanceof Uint8Array))throw new Error("Can only inputCodec on raw bytes that can be decoded");c=a}else c=(await s.getCodec(o.storeCodec)).encode(a),o.inputCodec=o.storeCodec;const l=new AbortController,u=et(l.signal,o.signal),h=await(await r.post("dag/put",{timeout:o.timeout,signal:u,searchParams:m(o),...await Ze([c],l,o.headers)})).json();return w.parse(h.Cid["/"])})(e),WD=b(s=>async(t,r={})=>{const a=await(await s.post("dag/resolve",{signal:r.signal,searchParams:m({arg:`${t}${r.path?`/${r.path}`.replace(/\/[/]+/g,"/"):""}`,...r}),headers:r.headers})).json();return{cid:w.parse(a.Cid["/"]),remainderPath:a.RemPath}});function JD(s,e){return{export:qD(e),get:KD(s,e),import:VD(e),put:Ad(s,e),resolve:WD(e)}}const GD=0,QD=1,XD=2,YD=3,ZD=4,eS=5,tS=6,rS=7,lr=s=>{if(s.Type===GD)return{name:"SENDING_QUERY",type:s.Type};if(s.Type===QD)return{from:pe(s.ID),name:"PEER_RESPONSE",type:s.Type,messageType:0,messageName:"PUT_VALUE",closer:(s.Responses||[]).map(({ID:e,Addrs:t})=>({id:pe(e),multiaddrs:t.map(r=>ie(r)),protocols:[]})),providers:(s.Responses||[]).map(({ID:e,Addrs:t})=>({id:pe(e),multiaddrs:t.map(r=>ie(r)),protocols:[]}))};if(s.Type===XD){let e={id:s.ID??pe(s.ID),multiaddrs:[],protocols:[]};return s.Responses&&s.Responses.length&&(e={id:pe(s.Responses[0].ID),multiaddrs:s.Responses[0].Addrs.map(t=>ie(t)),protocols:[]}),{name:"FINAL_PEER",type:s.Type,peer:e}}if(s.Type===YD)return{name:"QUERY_ERROR",type:s.Type,error:new Error(s.Extra)};if(s.Type===ZD)return{name:"PROVIDER",type:s.Type,providers:s.Responses.map(({ID:e,Addrs:t})=>({id:pe(e),multiaddrs:t.map(r=>ie(r)),protocols:[]}))};if(s.Type===eS)return{name:"VALUE",type:s.Type,value:Q(s.Extra,"base64pad")};if(s.Type===tS){const e=s.Responses.map(({ID:t})=>pe(t));if(!e.length)throw new Error("No peer found");return{name:"ADDING_PEER",type:s.Type,peer:e[0]}}if(s.Type===rS)return{name:"DIALING_PEER",type:s.Type,peer:pe(s.ID)};throw new Error("Unknown DHT event type")},sS=b(s=>{async function*e(t,r={}){const n=await s.post("dht/findpeer",{signal:r.signal,searchParams:m({arg:t,...r}),headers:r.headers});for await(const a of n.ndjson())yield lr(a)}return e}),nS=b(s=>{async function*e(t,r={}){const n=await s.post("dht/findprovs",{signal:r.signal,searchParams:m({arg:t.toString(),...r}),headers:r.headers});for await(const a of n.ndjson())yield lr(a)}return e}),aS=b(s=>{async function*e(t,r={}){const n=await s.post("dht/get",{signal:r.signal,searchParams:m({arg:t instanceof Uint8Array?R(t):t.toString(),...r}),headers:r.headers});for await(const a of n.ndjson())yield lr(a)}return e}),iS=b(s=>{async function*e(t,r={recursive:!1}){const n=Array.isArray(t)?t:[t],a=await s.post("dht/provide",{signal:r.signal,searchParams:m({arg:n.map(i=>i.toString()),...r}),headers:r.headers});for await(const i of a.ndjson())yield lr(i)}return e}),oS=b(s=>{async function*e(t,r,n={}){const a=new AbortController,i=et(a.signal,n.signal),o=await s.post("dht/put",{signal:i,searchParams:m({arg:t instanceof Uint8Array?R(t):t.toString(),...n}),...await Ze([r],a,n.headers)});for await(const c of o.ndjson())yield lr(c)}return e}),cS=b(s=>{async function*e(t,r={}){const n=await s.post("dht/query",{signal:r.signal,searchParams:m({arg:t.toString(),...r}),headers:r.headers});for await(const a of n.ndjson())yield lr(a)}return e});function lS(s){return{findPeer:sS(s),findProvs:nS(s),get:aS(s),provide:iS(s),put:oS(s),query:cS(s)}}const uS=b(s=>{async function e(t={}){return(await s.post("diag/cmds",{signal:t.signal,searchParams:m(t),headers:t.headers})).json()}return e}),dS=b(s=>{async function e(t={}){return(await s.post("diag/net",{signal:t.signal,searchParams:m(t),headers:t.headers})).json()}return e}),hS=b(s=>{async function e(t={}){return(await s.post("diag/sys",{signal:t.signal,searchParams:m(t),headers:t.headers})).json()}return e});function fS(s){return{cmds:uS(s),net:dS(s),sys:hS(s)}}const pS=b(s=>{async function e(t,r,n={}){await(await s.post("files/chmod",{signal:n.signal,searchParams:m({arg:t,mode:r,...n}),headers:n.headers})).text()}return e}),yS=b(s=>{async function e(t,r,n={}){const a=Array.isArray(t)?t:[t];await(await s.post("files/cp",{signal:n.signal,searchParams:m({arg:a.concat(r).map(o=>w.asCID(o)?`/ipfs/${o}`:o),...n}),headers:n.headers})).text()}return e}),wS=b(s=>{async function e(t,r={}){if(!t||typeof t!="string")throw new Error("ipfs.files.flush requires a path");const a=await(await s.post("files/flush",{signal:r.signal,searchParams:m({arg:t,...r}),headers:r.headers})).json();return w.parse(a.Cid)}return e});function Qa(s){const e=we(s);return Object.prototype.hasOwnProperty.call(e,"mode")&&(e.mode=parseInt(e.mode,8)),Object.prototype.hasOwnProperty.call(e,"mtime")&&(e.mtime={secs:e.mtime,nsecs:e.mtimeNsecs||0},delete e.mtimeNsecs),e}const gS=b(s=>{async function*e(t,r={}){if(!t)throw new Error("ipfs.files.ls requires a path");const n=await s.post("files/ls",{signal:r.signal,searchParams:m({arg:w.asCID(t)?`/ipfs/${t}`:t,long:!0,...r,stream:!0}),headers:r.headers});for await(const a of n.ndjson())if("Entries"in a)for(const i of a.Entries||[])yield Ic(Qa(i));else yield Ic(Qa(a))}return e});function Ic(s){return s.hash&&(s.cid=w.parse(s.hash)),delete s.hash,s.type=s.type===1?"directory":"file",s}const bS=b(s=>{async function e(t,r={}){await(await s.post("files/mkdir",{signal:r.signal,searchParams:m({arg:t,...r}),headers:r.headers})).text()}return e}),mS=b(s=>{async function e(t,r,n={}){Array.isArray(t)||(t=[t]),await(await s.post("files/mv",{signal:n.signal,searchParams:m({arg:t.concat(r),...n}),headers:n.headers})).text()}return e}),_S=b(s=>{async function*e(t,r={}){const n=await s.post("files/read",{signal:r.signal,searchParams:m({arg:t,count:r.length,...r}),headers:r.headers});yield*jh(n.body)}return e}),ES=b(s=>{async function e(t,r={}){const n=await s.post("files/rm",{signal:r.signal,searchParams:m({arg:t,...r}),headers:r.headers}),a=await n.text();if(a!==""){const i=new at.HTTPError(n);throw i.message=a,i}}return e}),Rd=b(s=>{async function e(t,r={}){const a=await(await s.post("files/stat",{signal:r.signal,searchParams:m({arg:t,...r}),headers:r.headers})).json();return a.WithLocality=a.WithLocality||!1,vS(Qa(a))}return e});function vS(s){return s.cid=w.parse(s.hash),delete s.hash,s}const DS=b(s=>{async function e(t,r={}){await(await s.post("files/touch",{signal:r.signal,searchParams:m({arg:t,...r}),headers:r.headers})).text()}return e}),SS=b(s=>{async function e(t,r,n={}){const a=new AbortController,i=et(a.signal,n.signal);await(await s.post("files/write",{signal:i,searchParams:m({arg:t,streamChannels:!0,count:n.length,...n}),...await Ze([{content:r,path:"arg",mode:Sd(n.mode),mtime:kd(n.mtime)}],a,n.headers)})).text()}return e});function kS(s){return{chmod:pS(s),cp:yS(s),flush:wS(s),ls:gS(s),mkdir:bS(s),mv:mS(s),read:_S(s),rm:ES(s),stat:Rd(s),touch:DS(s),write:SS(s)}}const $S=b(s=>async(t,r,n={})=>{throw y(new Error("Not implemented"),"ERR_NOT_IMPLEMENTED")}),PS=b(s=>{async function e(t,r){const n=r??{type:"Ed25519"},i=await(await s.post("key/gen",{signal:n.signal,searchParams:m({arg:t,...n}),headers:n.headers})).json();return we(i)}return e}),AS=b(s=>{async function e(t,r,n,a={}){const o=await(await s.post("key/import",{signal:a.signal,searchParams:m({arg:t,pem:r,password:n,...a}),headers:a.headers})).json();return we(o)}return e}),RS=b(s=>async(t,r={})=>{throw y(new Error("Not implemented"),"ERR_NOT_IMPLEMENTED")}),TS=b(s=>{async function e(t={}){return((await(await s.post("key/list",{signal:t.signal,searchParams:m(t),headers:t.headers})).json()).Keys||[]).map(a=>we(a))}return e}),OS=b(s=>{async function e(t,r,n={}){const a=await s.post("key/rename",{signal:n.signal,searchParams:m({arg:[t,r],...n}),headers:n.headers});return we(await a.json())}return e}),CS=b(s=>{async function e(t,r={}){const a=await(await s.post("key/rm",{signal:r.signal,searchParams:m({arg:t,...r}),headers:r.headers})).json();return we(a.Keys[0])}return e});function IS(s){return{export:$S(s),gen:PS(s),import:AS(s),info:RS(s),list:TS(s),rename:OS(s),rm:CS(s)}}const NS=b(s=>{async function e(t,r,n={}){const a=await s.post("log/level",{signal:n.signal,searchParams:m({arg:[t,r],...n}),headers:n.headers});return we(await a.json())}return e}),xS=b(s=>{async function e(t={}){return(await(await s.post("log/ls",{signal:t.signal,searchParams:m(t),headers:t.headers})).json()).Strings}return e}),LS=b(s=>{async function*e(t={}){yield*(await s.post("log/tail",{signal:t.signal,searchParams:m(t),headers:t.headers})).ndjson()}return e});function BS(s){return{level:NS(s),ls:xS(s),tail:LS(s)}}const jS=b(s=>{async function e(t,r={}){const n=await s.post("name/publish",{signal:r.signal,searchParams:m({arg:`${t}`,...r}),headers:r.headers});return we(await n.json())}return e}),MS=b(s=>{async function*e(t,r={}){const n=await s.post("name/resolve",{signal:r.signal,searchParams:m({arg:t,stream:!0,...r}),headers:r.headers});for await(const a of n.ndjson())yield a.Path}return e}),zS=b(s=>{async function e(t,r={}){const n=await s.post("name/pubsub/cancel",{signal:r.signal,searchParams:m({arg:t,...r}),headers:r.headers});return we(await n.json())}return e}),US=b(s=>{async function e(t={}){const r=await s.post("name/pubsub/state",{signal:t.signal,searchParams:m(t),headers:t.headers});return we(await r.json())}return e}),FS=b(s=>{async function e(t={}){return(await(await s.post("name/pubsub/subs",{signal:t.signal,searchParams:m(t),headers:t.headers})).json()).Strings||[]}return e});function HS(s){return{cancel:zS(s),state:US(s),subs:FS(s)}}function qS(s){return{publish:jS(s),resolve:MS(s),pubsub:HS(s)}}const KS=b(s=>{async function e(t,r={}){const a=await(await s.post("object/data",{signal:r.signal,searchParams:m({arg:`${t instanceof Uint8Array?w.decode(t):t}`,...r}),headers:r.headers})).arrayBuffer();return new Uint8Array(a,0,a.byteLength)}return e}),VS=b(s=>{async function e(t,r={}){const a=await(await s.post("object/get",{signal:r.signal,searchParams:m({arg:`${t instanceof Uint8Array?w.decode(t):t}`,dataEncoding:"base64",...r}),headers:r.headers})).json();return{Data:Q(a.Data,"base64pad"),Links:(a.Links||[]).map(i=>({Name:i.Name,Hash:w.parse(i.Hash),Tsize:i.Size}))}}return e}),WS=b(s=>{async function e(t,r={}){return((await(await s.post("object/links",{signal:r.signal,searchParams:m({arg:`${t instanceof Uint8Array?w.decode(t):t}`,...r}),headers:r.headers})).json()).Links||[]).map(i=>({Name:i.Name,Tsize:i.Size,Hash:w.parse(i.Hash)}))}return e}),JS=b(s=>{async function e(t={}){const r=await s.post("object/new",{signal:t.signal,searchParams:m({arg:t.template,...t}),headers:t.headers}),{Hash:n}=await r.json();return w.parse(n)}return e}),GS=(s,e)=>b(r=>{const n=Ad(s,e);async function a(i,o={}){return n(i,{...o,storeCodec:"dag-pb",hashAlg:"sha2-256",version:1})}return a})(e),QS=b(s=>{async function e(t,r={}){const a=await(await s.post("object/stat",{signal:r.signal,searchParams:m({arg:`${t}`,...r}),headers:r.headers})).json();return{...a,Hash:w.parse(a.Hash)}}return e}),XS=b(s=>{async function e(t,r,n={}){const a=await s.post("object/patch/add-link",{signal:n.signal,searchParams:m({arg:[`${t}`,r.Name||r.name||"",(r.Hash||r.cid||"").toString()||null],...n}),headers:n.headers}),{Hash:i}=await a.json();return w.parse(i)}return e}),YS=b(s=>{async function e(t,r,n={}){const a=new AbortController,i=et(a.signal,n.signal),o=await s.post("object/patch/append-data",{signal:i,searchParams:m({arg:`${t}`,...n}),...await Ze([r],a,n.headers)}),{Hash:c}=await o.json();return w.parse(c)}return e}),ZS=b(s=>{async function e(t,r,n={}){const a=await s.post("object/patch/rm-link",{signal:n.signal,searchParams:m({arg:[`${t}`,r.Name||r.name||null],...n}),headers:n.headers}),{Hash:i}=await a.json();return w.parse(i)}return e}),e0=b(s=>{async function e(t,r,n={}){const a=new AbortController,i=et(a.signal,n.signal),o=await s.post("object/patch/set-data",{signal:i,searchParams:m({arg:[`${t}`],...n}),...await Ze([r],a,n.headers)}),{Hash:c}=await o.json();return w.parse(c)}return e});function t0(s){return{addLink:XS(s),appendData:YS(s),rmLink:ZS(s),setData:e0(s)}}function r0(s,e){return{data:KS(e),get:VS(e),links:WS(e),new:JS(e),put:GS(s,e),stat:QS(e),patch:t0(e)}}const Td=b(s=>{async function*e(t,r={}){for await(const{path:n,recursive:a,metadata:i}of is(t)){const o=await s.post("pin/add",{signal:r.signal,searchParams:m({...r,arg:n,recursive:a,metadata:i?JSON.stringify(i):void 0,stream:!0}),headers:r.headers});for await(const c of o.ndjson()){if(c.Pins){for(const l of c.Pins)yield w.parse(l);continue}yield w.parse(c)}}}return e});function s0(s){const e=Td(s);return b(()=>{async function t(r,n={}){return Ce(e([{path:r,...n}],n))}return t})(s)}function Nc(s,e,t){const r={type:s,cid:w.parse(e)};return t&&(r.metadata=t),r}const n0=b(s=>{async function*e(t={}){let r=[];t.paths&&(r=Array.isArray(t.paths)?t.paths:[t.paths]);const n=await s.post("pin/ls",{signal:t.signal,searchParams:m({...t,arg:r.map(a=>`${a}`),stream:!0}),headers:t.headers});for await(const a of n.ndjson()){if(a.Keys){for(const i of Object.keys(a.Keys))yield Nc(a.Keys[i].Type,i,a.Keys[i].Metadata);return}yield Nc(a.Type,a.Cid,a.Metadata)}}return e}),Od=b(s=>{async function*e(t,r={}){for await(const{path:n,recursive:a}of is(t)){const i=new URLSearchParams(r.searchParams);i.append("arg",`${n}`),a!=null&&i.set("recursive",String(a));const o=await s.post("pin/rm",{signal:r.signal,headers:r.headers,searchParams:m({...r,arg:`${n}`,recursive:a})});for await(const c of o.ndjson()){if(c.Pins){yield*c.Pins.map(l=>w.parse(l));continue}yield w.parse(c)}}}return e}),a0=s=>{const e=Od(s);return b(()=>{async function t(r,n={}){return Ce(e([{path:r,...n}],n))}return t})(s)},Cd=({Name:s,Status:e,Cid:t})=>({cid:w.parse(t),name:s,status:e}),Id=s=>{if(typeof s=="string"&&s!=="")return s;throw new TypeError("service name must be passed")},Nd=s=>{if(w.asCID(s))return s.toString();throw new TypeError(`CID instance expected instead of ${typeof s}`)},Ji=({service:s,cid:e,name:t,status:r,all:n})=>{const a=m({service:Id(s),name:t,force:n?!0:void 0});if(e)for(const i of e)a.append("cid",Nd(i));if(r)for(const i of r)a.append("status",i);return a},i0=({cid:s,service:e,background:t,name:r,origins:n})=>{const a=m({arg:Nd(s),service:Id(e),name:r,background:t?!0:void 0});if(n)for(const i of n)a.append("origin",i.toString());return a};function o0(s){async function e(t,{timeout:r,signal:n,headers:a,...i}){const o=await s.post("pin/remote/add",{timeout:r,signal:n,headers:a,searchParams:i0({cid:t,...i})});return Cd(await o.json())}return e}function c0(s){async function*e({timeout:t,signal:r,headers:n,...a}){const i=await s.post("pin/remote/ls",{timeout:t,signal:r,headers:n,searchParams:Ji(a)});for await(const o of i.ndjson())yield Cd(o)}return e}function l0(s){async function e({timeout:t,signal:r,headers:n,...a}){await s.post("pin/remote/rm",{timeout:t,signal:r,headers:n,searchParams:Ji({...a,all:!1})})}return e}function u0(s){async function e({timeout:t,signal:r,headers:n,...a}){await s.post("pin/remote/rm",{timeout:t,signal:r,headers:n,searchParams:Ji({...a,all:!0})})}return e}function d0(s){const e=String(s);if(e==="undefined")throw Error("endpoint is required");return e[e.length-1]==="/"?e.slice(0,-1):e}function h0(s){return{service:s.Service,endpoint:new URL(s.ApiEndpoint),...s.Stat&&{stat:f0(s.Stat)}}}function f0(s){switch(s.Status){case"valid":{const{Pinning:e,Pinned:t,Queued:r,Failed:n}=s.PinCount;return{status:"valid",pinCount:{queued:r,pinning:e,pinned:t,failed:n}}}case"invalid":return{status:"invalid"};default:return{status:s.Status}}}function p0(s){async function e(t,r){const{endpoint:n,key:a,headers:i,timeout:o,signal:c}=r;await s.post("pin/remote/service/add",{timeout:o,signal:c,searchParams:m({arg:[t,d0(n),a]}),headers:i})}return e}function y0(s){async function e(t={}){const{stat:r,headers:n,timeout:a,signal:i}=t,o=await s.post("pin/remote/service/ls",{timeout:a,signal:i,headers:n,searchParams:r===!0?m({stat:r}):void 0}),{RemoteServices:c}=await o.json();return c.map(h0)}return e}function w0(s){async function e(t,r={}){await s.post("pin/remote/service/rm",{signal:r.signal,headers:r.headers,searchParams:m({arg:t})})}return e}function g0(s){const e=new Wi(s);return{add:p0(e),ls:y0(e),rm:w0(e)}}function b0(s){const e=new Wi(s);return{add:o0(e),ls:c0(e),rm:l0(e),rmAll:u0(e),service:g0(s)}}function m0(s){return{addAll:Td(s),add:s0(s),ls:n0(s),rmAll:Od(s),rm:a0(s),remote:b0(s)}}const _0=s=>Array.isArray(s)?s.map(Xa):s,Xa=s=>R(Nr(s)),Nr=s=>Dn.decode(s),E0=s=>BigInt(`0x${R(Dn.decode(s),"base16")}`),Gi=s=>Dn.encode(Q(s)),v0=b(s=>{async function e(t={}){const{Strings:r}=await(await s.post("pubsub/ls",{signal:t.signal,searchParams:m(t),headers:t.headers})).json();return _0(r)||[]}return e}),D0=b(s=>{async function e(t,r={}){const n=await s.post("pubsub/peers",{signal:r.signal,searchParams:m({arg:Gi(t),...r}),headers:r.headers}),{Strings:a}=await n.json();return a||[]}return e}),S0=b(s=>{async function e(t,r,n={}){const a=m({arg:Gi(t),...n}),i=new AbortController,o=et(i.signal,n.signal);await(await s.post("pubsub/pub",{signal:o,searchParams:a,...await Ze([r],i,n.headers)})).text()}return e}),k0=M("ipfs-http-client:pubsub:subscribe"),$0=(s,e)=>b(t=>{async function r(n,a,i={}){i.signal=e.subscribe(n,a,i.signal);let o,c;const l=new Promise((d,h)=>{o=d,c=h}),u=setTimeout(()=>o(),1e3);return t.post("pubsub/sub",{signal:i.signal,searchParams:m({arg:Gi(n),...i}),headers:i.headers}).catch(d=>{e.unsubscribe(n,a),c(d)}).then(d=>{clearTimeout(u),d&&(P0(d,{onMessage:h=>{if(a){if(typeof a=="function"){a(h);return}typeof a.handleEvent=="function"&&a.handleEvent(h)}},onEnd:()=>e.unsubscribe(n,a),onError:i.onError}),o())}),l}return r})(s);async function P0(s,{onMessage:e,onEnd:t,onError:r}){r=r||k0;try{for await(const n of s.ndjson())try{if(!n.from)continue;n.from!=null&&n.seqno!=null?e({type:"signed",from:pe(n.from),data:Nr(n.data),sequenceNumber:E0(n.seqno),topic:Xa(n.topicIDs[0]),key:Nr(n.key??"u"),signature:Nr(n.signature??"u")}):e({type:"unsigned",data:Nr(n.data),topic:Xa(n.topicIDs[0])})}catch(a){a.message=`Failed to parse pubsub message: ${a.message}`,r(a,!1,n)}}catch(n){A0(n)||r(n,!0)}finally{t()}}const A0=s=>{switch(s.type){case"aborted":return!0;case"abort":return!0;default:return s.name==="AbortError"}},R0=(s,e)=>{async function t(r,n){e.unsubscribe(r,n)}return t};class T0{constructor(){this._subs=new Map}subscribe(e,t,r){const n=this._subs.get(e)||[];if(n.find(i=>i.handler===t))throw new Error(`Already subscribed to ${e} with this handler`);const a=new AbortController;return this._subs.set(e,[{handler:t,controller:a}].concat(n)),r&&r.addEventListener("abort",()=>this.unsubscribe(e,t)),a.signal}unsubscribe(e,t){const r=this._subs.get(e)||[];let n;t?(this._subs.set(e,r.filter(a=>a.handler!==t)),n=r.filter(a=>a.handler===t)):(this._subs.set(e,[]),n=r),(this._subs.get(e)||[]).length||this._subs.delete(e),n.forEach(a=>a.controller.abort())}}function O0(s){const e=new T0;return{ls:v0(s),peers:D0(s),publish:S0(s),subscribe:$0(s,e),unsubscribe:R0(s,e)}}const C0=b(s=>{async function*e(t={}){yield*(await s.post("refs/local",{signal:t.signal,transform:we,searchParams:m(t),headers:t.headers})).ndjson()}return e}),I0=b((s,e)=>Object.assign(async function*(r,n={}){const a=Array.isArray(r)?r:[r];yield*(await s.post("refs",{signal:n.signal,searchParams:m({arg:a.map(o=>`${o instanceof Uint8Array?w.decode(o):o}`),...n}),headers:n.headers,transform:we})).ndjson()},{local:C0(e)})),N0=b(s=>{async function*e(t={}){yield*(await s.post("repo/gc",{signal:t.signal,searchParams:m(t),headers:t.headers,transform:n=>({err:n.Error?new Error(n.Error):null,cid:(n.Key||{})["/"]?w.parse(n.Key["/"]):null})})).ndjson()}return e}),xd=b(s=>{async function e(t={}){const n=await(await s.post("repo/stat",{signal:t.signal,searchParams:m(t),headers:t.headers})).json();return{numObjects:BigInt(n.NumObjects),repoSize:BigInt(n.RepoSize),repoPath:n.RepoPath,version:n.Version,storageMax:BigInt(n.StorageMax)}}return e}),x0=b(s=>{async function e(t={}){return(await(await s.post("repo/version",{signal:t.signal,searchParams:m(t),headers:t.headers})).json()).Version}return e});function L0(s){return{gc:N0(s),stat:xd(s),version:x0(s)}}const B0=b(s=>{async function*e(t={}){yield*(await s.post("stats/bw",{signal:t.signal,searchParams:m(t),headers:t.headers,transform:n=>({totalIn:BigInt(n.TotalIn),totalOut:BigInt(n.TotalOut),rateIn:parseFloat(n.RateIn),rateOut:parseFloat(n.RateOut)})})).ndjson()}return e});function j0(s){return{bitswap:$d(s),repo:xd(s),bw:B0(s)}}const M0=b(s=>{async function e(t={}){const r=await s.post("swarm/addrs",{signal:t.signal,searchParams:m(t),headers:t.headers}),{Addrs:n}=await r.json();return Object.keys(n).map(a=>({id:pe(a),addrs:(n[a]||[]).map(i=>ie(i))}))}return e}),z0=b(s=>{async function e(t,r={}){const n=await s.post("swarm/connect",{signal:r.signal,searchParams:m({arg:t,...r}),headers:r.headers}),{Strings:a}=await n.json();return a||[]}return e}),U0=b(s=>{async function e(t,r={}){const n=await s.post("swarm/disconnect",{signal:r.signal,searchParams:m({arg:t,...r}),headers:r.headers}),{Strings:a}=await n.json();return a||[]}return e}),F0=b(s=>{async function e(t={}){const r=await s.post("swarm/addrs/local",{signal:t.signal,searchParams:m(t),headers:t.headers}),{Strings:n}=await r.json();return(n||[]).map(a=>ie(a))}return e}),H0=b(s=>{async function e(t={}){const r=await s.post("swarm/peers",{signal:t.signal,searchParams:m(t),headers:t.headers}),{Peers:n}=await r.json();return(n||[]).map(a=>({addr:ie(a.Addr),peer:pe(a.Peer),muxer:a.Muxer,latency:a.Latency,streams:a.Streams,direction:a.Direction==null?void 0:a.Direction===0?"inbound":"outbound"}))}return e});function q0(s){return{addrs:M0(s),connect:z0(s),disconnect:U0(s),localAddrs:F0(s),peers:H0(s)}}const Ld=b(s=>{async function*e(t,r={}){const n=new AbortController,a=et(n.signal,r.signal),{headers:i,body:o,total:c,parts:l}=await Ze(t,n,r.headers),[u,d]=typeof r.progress=="function"?K0(c,l,r.progress):[void 0,void 0],h=await s.post("add",{searchParams:m({"stream-channels":!0,...r,progress:!!u}),onUploadProgress:d,signal:a,headers:i,body:o});for await(let f of h.ndjson())f=we(f),f.hash!==void 0?yield W0(f):u&&u(f.bytes||0,f.name)}return e}),K0=(s,e,t)=>e?[void 0,V0(s,e,t)]:[t,void 0],V0=(s,e,t)=>{let r=0;const n=e.length;return({loaded:a,total:i})=>{const o=Math.floor(a/i*s);for(;r<n;){const{start:c,end:l,name:u}=e[r];if(o<l){t(o-c,u);break}else t(l-c,u),r+=1}}};function W0({name:s,hash:e,size:t,mode:r,mtime:n,mtimeNsecs:a}){const i={path:s,cid:w.parse(e),size:parseInt(t)};return r!=null&&(i.mode=parseInt(r,8)),n!=null&&(i.mtime={secs:n,nsecs:a||0}),i}function J0(s){const e=Ld(s);return b(()=>{async function t(r,n={}){return await Ce(e($u(r),n))}return t})(s)}const G0=b(s=>{async function*e(t,r={}){yield*(await s.post("cat",{signal:r.signal,searchParams:m({arg:t.toString(),...r}),headers:r.headers})).iterator()}return e}),Q0=b(s=>async(t={})=>(await s.post("commands",{signal:t.signal,searchParams:m(t),headers:t.headers})).json()),X0=b(s=>async(t,r={})=>(await(await s.post("dns",{signal:r.signal,searchParams:m({arg:t,...r}),headers:r.headers})).json()).Path),Y0=b(s=>()=>{const e=new URL(s.opts.base||"");return{host:e.hostname,port:e.port,protocol:e.protocol,pathname:e.pathname,"api-path":e.pathname}}),Z0=b(s=>{async function*e(t,r={}){const n={arg:`${t instanceof Uint8Array?w.decode(t):t}`,...r};n.compressionLevel&&(n["compression-level"]=n.compressionLevel,delete n.compressionLevel),yield*(await s.post("get",{signal:r.signal,searchParams:m(n),headers:r.headers})).iterator()}return e}),Bd=b(s=>{async function e(t={}){const n=await(await s.post("id",{signal:t.signal,searchParams:m({arg:t.peerId?t.peerId.toString():void 0,...t}),headers:t.headers})).json(),a={...we(n)};return a.id=pe(a.id),a.addresses&&(a.addresses=a.addresses.map(i=>ie(i))),a}return e}),ek=s=>{const e=Bd(s);async function t(r={}){const n=await e(r);return!!(n&&n.addresses&&n.addresses.length)}return t},tk=b((s,e)=>{async function*t(r,n={}){const a=`${r instanceof Uint8Array?w.decode(r):r}`;async function i(c){let l=c.Hash;if(l.includes("/")){const d=l.startsWith("/ipfs/")?l:`/ipfs/${l}`;l=(await Rd(e)(d)).cid}else l=w.parse(l);const u={name:c.Name,path:a+(c.Name?`/${c.Name}`:""),size:c.Size,cid:l,type:rk(c)};return c.Mode&&(u.mode=parseInt(c.Mode,8)),c.Mtime!==void 0&&c.Mtime!==null&&(u.mtime={secs:c.Mtime},c.MtimeNsecs!==void 0&&c.MtimeNsecs!==null&&(u.mtime.nsecs=c.MtimeNsecs)),u}const o=await s.post("ls",{signal:n.signal,searchParams:m({arg:a,...n}),headers:n.headers});for await(let c of o.ndjson()){if(c=c.Objects,!c)throw new Error("expected .Objects in results");if(c=c[0],!c)throw new Error("expected one array in results.Objects");const l=c.Links;if(!Array.isArray(l))throw new Error("expected one array in results.Objects[0].Links");if(!l.length){yield i(c);return}yield*l.map(i)}}return t});function rk(s){switch(s.Type){case 1:case 5:return"dir";case 2:return"file";default:return"file"}}const sk=b(s=>{async function e(t={}){const r=await s.post("dns",{signal:t.signal,searchParams:m(t),headers:t.headers});return we(await r.json())}return e}),nk=b(s=>{async function*e(t,r={}){yield*(await s.post("ping",{signal:r.signal,searchParams:m({arg:`${t}`,...r}),headers:r.headers,transform:we})).ndjson()}return e}),ak=b(s=>{async function e(t,r={}){const n=await s.post("resolve",{signal:r.signal,searchParams:m({arg:t,...r}),headers:r.headers}),{Path:a}=await n.json();return a}return e}),ik=b(s=>async(t={})=>{throw y(new Error("Not implemented"),"ERR_NOT_IMPLEMENTED")}),ok=b(s=>{async function e(t={}){await(await s.post("shutdown",{signal:t.signal,searchParams:m(t),headers:t.headers})).text()}return e}),ck=b(s=>{async function e(t={}){const r=await s.post("version",{signal:t.signal,searchParams:m(t),headers:t.headers});return{...we(await r.json()),"ipfs-http-client":"1.0.0"}}return e}),lk={},uk=Object.freeze(Object.defineProperty({__proto__:null,default:lk},Symbol.toStringTag,{value:"Module"}));function oR(s={}){const e={name:Rt.name,code:Rt.code,encode:l=>l,decode:l=>l},t=Object.values(Sn);(s.ipld&&s.ipld.bases?s.ipld.bases:[]).forEach(l=>t.push(l));const r=new Ed({bases:t,loadBase:s.ipld&&s.ipld.loadBase}),n=Object.values(Bl);[Xe,Mr,gl,bl,e].concat(s.ipld&&s.ipld.codecs||[]).forEach(l=>n.push(l));const a=new vd({codecs:n,loadCodec:s.ipld&&s.ipld.loadCodec}),i=Object.values(Ll);(s.ipld&&s.ipld.hashers?s.ipld.hashers:[]).forEach(l=>i.push(l));const o=new Dd({hashers:i,loadHasher:s.ipld&&s.ipld.loadHasher});return{add:J0(s),addAll:Ld(s),bitswap:mD(s),block:AD(s),bootstrap:ND(s),cat:G0(s),commands:Q0(s),config:HD(s),dag:JD(a,s),dht:lS(s),diag:fS(s),dns:X0(s),files:kS(s),get:Z0(s),getEndpointConfig:Y0(s),id:Bd(s),isOnline:ek(s),key:IS(s),log:BS(s),ls:tk(s),mount:sk(s),name:qS(s),object:r0(a,s),pin:m0(s),ping:nk(s),pubsub:O0(s),refs:I0(s),repo:L0(s),resolve:ak(s),start:ik(s),stats:j0(s),stop:ok(s),swarm:q0(s),version:ck(s),bases:r,codecs:a,hashers:o}}const{code:dk}=ne("dnsaddr");async function cR(s,e={}){const t=new Mh;e.signal!=null&&e.signal.addEventListener("abort",()=>{t.cancel()});const r=s.getPeerId(),[,n]=s.stringTuples().find(([o])=>o===dk)??[];if(n==null)throw new Error("No hostname found in multiaddr");let i=(await t.resolveTxt(`_dnsaddr.${n}`)).flat().map(o=>o.split("=")[1]).filter(Boolean);return r!=null&&(i=i.filter(o=>o.includes(r))),i}const hk=$("dns4"),fk=$("dns6"),pk=$("dnsaddr"),Ct=$e($("dns"),pk,hk,fk),Fn=$e($("ip4"),$("ip6")),sr=$e(N(Fn,$("tcp")),N(Ct,$("tcp"))),Hn=N(Fn,$("udp")),yk=N(Hn,$("utp")),wk=N(Hn,$("quic")),gk=N(Hn,$("quic-v1")),Ya=$e(N(sr,$("ws")),N(Ct,$("ws"))),Za=$e(N(sr,$("wss")),N(Ct,$("wss")),N(sr,$("tls"),$("ws")),N(Ct,$("tls"),$("ws"))),ei=$e(N(sr,$("http")),N(Fn,$("http")),N(Ct,$("http"))),ti=$e(N(sr,$("https")),N(Fn,$("https")),N(Ct,$("https"))),xc=N(Hn,$("webrtc-direct"),$("certhash")),jd=$e(N(xc,$("p2p")),xc),Lc=N(gk,$("webtransport"),$("certhash"),$("certhash")),Md=$e(N(Lc,$("p2p")),Lc),zd=$e(N(Ya,$("p2p-webrtc-star"),$("p2p")),N(Za,$("p2p-webrtc-star"),$("p2p")),N(Ya,$("p2p-webrtc-star")),N(Za,$("p2p-webrtc-star"))),Ud=$e(N(ei,$("p2p-webrtc-direct"),$("p2p")),N(ti,$("p2p-webrtc-direct"),$("p2p")),N(ei,$("p2p-webrtc-direct")),N(ti,$("p2p-webrtc-direct"))),ri=$e(Ya,Za,ei,ti,zd,Ud,sr,yk,wk,Ct,jd,Md),wt=$e(N(ri,$("p2p")),zd,Ud,jd,Md,$("p2p")),Bc=$e(N(wt,$("p2p-circuit"),wt),N(wt,$("p2p-circuit")),N($("p2p-circuit"),wt),N(ri,$("p2p-circuit")),N($("p2p-circuit"),ri),$("p2p-circuit")),Fd=()=>$e(N(Bc,Fd),Bc),Dr=Fd(),lR=$e(N(Dr,wt,Dr),N(wt,Dr),N(Dr,wt),Dr,wt);function Hd(s){function e(t){let r;try{r=ss(t)}catch{return!1}const n=s(r.protoNames());return n===null?!1:n===!0||n===!1?n:n.length===0}return e}function N(...s){function e(t){if(t.length<s.length)return null;let r=t;return s.some(n=>(r=typeof n=="function"?n().partialMatch(t):n.partialMatch(t),Array.isArray(r)&&(t=r),r===null)),r}return{toString:function(){return"{ "+s.join(" ")+" }"},input:s,matches:Hd(e),partialMatch:e}}function $e(...s){function e(r){let n=null;return s.some(a=>{const i=typeof a=="function"?a().partialMatch(r):a.partialMatch(r);return i!=null?(n=i,!0):!1}),n}return{toString:function(){return"{ "+s.join(" ")+" }"},input:s,matches:Hd(e),partialMatch:e}}function $(s){const e=s;function t(n){let a;try{a=ss(n)}catch{return!1}const i=a.protoNames();return i.length===1&&i[0]===e}function r(n){return n.length===0?null:n[0]===e?n.slice(1):null}return{toString:function(){return e},matches:t,partialMatch:r}}const qd=_e.bind({ignoreUndefined:!0}),Br=M("ipfs:components:peer:storage");class Qi{constructor(e,t,r,n,a){this.print=n,this.peerId=e,this.keychain=t,this.repo=r,this.print=n,this.isNew=a}static async start(e,t,r){const{repoAutoMigrate:n,repo:a,onMigrationProgress:i}=r,o=typeof a=="string"||a==null?iv(e,t,{path:a,autoMigrate:n,onMigrationProgress:i}):a,{peerId:c,keychain:l,isNew:u}=await bk(e,o,r);return new Qi(c,l,o,e,u)}}const bk=async(s,e,t)=>{if(!e.closed)return{...await jc(e,t),isNew:!1};try{return await e.open(),{...await jc(e,t),isNew:!1}}catch(r){if(r.code!==Cr)throw r;if(t.init&&t.init.allowNew===!1)throw new ir("Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it");return{...await mk(s,e,t),isNew:!0}}},mk=async(s,e,t)=>{const r=t.init||{},n=await e.exists();if(Br("repo exists?",n),n===!0)throw new Error("repo already exists");const a=r.privateKey?await _k(r.privateKey):await Ek(s,r),i=vk(a);Br("peer identity: %s",i.PeerID);const o={...qd(Kd(Jt(),r.profiles),t.config),Identity:i};await e.init(o),await e.open(),Br("repo opened");const c={pass:t.pass};try{c.dek=await e.config.get("Keychain.DEK")}catch(u){if(u.code!=="ERR_NOT_FOUND")throw u}const l=await mi({options:void 0,multiaddrs:void 0,peerId:a,repo:e,config:o,keychainConfig:c});return await e.datastore.has(new ae("/info/self"))||await l.keychain.importPeer("self",a),await e.config.set("Keychain",{DEK:l.keychain.init.dek}),{peerId:a,keychain:l.keychain}},_k=async s=>{if(Br("using user-supplied private-key"),Lr(s))return s;const e=Q(s,"base64pad"),t=await bi(e);return await mn(t.public.bytes,t.bytes)},Ek=(s,{algorithm:e="Ed25519",bits:t=2048})=>{if(s("generating %s keypair...",e),e==="Ed25519")return Xh();if(e==="RSA")return Yh({bits:t});throw y(new Error("Unknown PeerId algorithm"),"ERR_UNKNOWN_PEER_ID_ALGORITHM")},vk=s=>{if(s.privateKey==null)throw y(new Error("Private key missing"),"ERR_MISSING_PRIVATE_KEY");return{PeerID:s.toString(),PrivKey:R(s.privateKey,"base64pad")}},jc=async(s,e)=>{const t=e.config,r=e.init&&e.init.profiles||[],n=e.pass,a=await s.config.getAll(),i=Dk(Kd(a,r),t);if(a!==i&&await s.config.replace(i),!i.Identity||!i.Identity.PrivKey)throw new ts("No private key was found in the config, please intialize the repo");const o=Q(i.Identity.PrivKey,"base64pad"),c=await bi(o),l=await mn(c.public.bytes,c.bytes),u=await mi({options:void 0,multiaddrs:void 0,peerId:l,repo:s,config:i,keychainConfig:{pass:n,...i.Keychain}});return{peerId:l,keychain:u.keychain}},Dk=(s,e)=>e?qd(s,e):s,Kd=(s,e)=>(e||[]).reduce((t,r)=>{const n=rn[r];if(!n)throw new Error(`Could not find profile with name '${r}'`);return Br("applying profile %s",r),n.transform(t)},s);function Sk(s){let e=new Uint8Array(s.reduce((r,n)=>r+j.encodingLength(n),0)),t=0;for(const r of s)e=zh.encode(r,e,t),t+=j.encodingLength(r);return e}class Vd{constructor(e,t,r){this._refCounter=1,this.cid=e,this.priority=t||1,this.wantType=r}inc(){this._refCounter+=1}dec(){this._refCounter=Math.max(0,this._refCounter-1)}hasRefs(){return this._refCounter>0}get[Symbol.toStringTag](){return`WantlistEntry <key: ${this.cid.toString(U)}, priority: ${this.priority}, refs: ${this._refCounter}>`}equals(e){return this._refCounter===e._refCounter&&this.cid.equals(e.cid)&&this.priority===e.priority&&this.wantType===e.wantType}}const Je=D.Reader,Sr=D.Writer,F=D.util,z=D.roots["ipfs-bitswap"]||(D.roots["ipfs-bitswap"]={}),Ke=z.Message=(()=>{function s(e){if(this.blocks=[],this.payload=[],this.blockPresences=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)e[t[r]]!=null&&(this[t[r]]=e[t[r]])}return s.prototype.wantlist=null,s.prototype.blocks=F.emptyArray,s.prototype.payload=F.emptyArray,s.prototype.blockPresences=F.emptyArray,s.prototype.pendingBytes=0,s.encode=function(t,r){if(r||(r=Sr.create()),t.wantlist!=null&&Object.hasOwnProperty.call(t,"wantlist")&&z.Message.Wantlist.encode(t.wantlist,r.uint32(10).fork()).ldelim(),t.blocks!=null&&t.blocks.length)for(var n=0;n<t.blocks.length;++n)r.uint32(18).bytes(t.blocks[n]);if(t.payload!=null&&t.payload.length)for(var n=0;n<t.payload.length;++n)z.Message.Block.encode(t.payload[n],r.uint32(26).fork()).ldelim();if(t.blockPresences!=null&&t.blockPresences.length)for(var n=0;n<t.blockPresences.length;++n)z.Message.BlockPresence.encode(t.blockPresences[n],r.uint32(34).fork()).ldelim();return t.pendingBytes!=null&&Object.hasOwnProperty.call(t,"pendingBytes")&&r.uint32(40).int32(t.pendingBytes),r},s.decode=function(t,r){t instanceof Je||(t=Je.create(t));for(var n=r===void 0?t.len:t.pos+r,a=new z.Message;t.pos<n;){var i=t.uint32();switch(i>>>3){case 1:{a.wantlist=z.Message.Wantlist.decode(t,t.uint32());break}case 2:{a.blocks&&a.blocks.length||(a.blocks=[]),a.blocks.push(t.bytes());break}case 3:{a.payload&&a.payload.length||(a.payload=[]),a.payload.push(z.Message.Block.decode(t,t.uint32()));break}case 4:{a.blockPresences&&a.blockPresences.length||(a.blockPresences=[]),a.blockPresences.push(z.Message.BlockPresence.decode(t,t.uint32()));break}case 5:{a.pendingBytes=t.int32();break}default:t.skipType(i&7);break}}return a},s.fromObject=function(t){if(t instanceof z.Message)return t;var r=new z.Message;if(t.wantlist!=null){if(typeof t.wantlist!="object")throw TypeError(".Message.wantlist: object expected");r.wantlist=z.Message.Wantlist.fromObject(t.wantlist)}if(t.blocks){if(!Array.isArray(t.blocks))throw TypeError(".Message.blocks: array expected");r.blocks=[];for(var n=0;n<t.blocks.length;++n)typeof t.blocks[n]=="string"?F.base64.decode(t.blocks[n],r.blocks[n]=F.newBuffer(F.base64.length(t.blocks[n])),0):t.blocks[n].length>=0&&(r.blocks[n]=t.blocks[n])}if(t.payload){if(!Array.isArray(t.payload))throw TypeError(".Message.payload: array expected");r.payload=[];for(var n=0;n<t.payload.length;++n){if(typeof t.payload[n]!="object")throw TypeError(".Message.payload: object expected");r.payload[n]=z.Message.Block.fromObject(t.payload[n])}}if(t.blockPresences){if(!Array.isArray(t.blockPresences))throw TypeError(".Message.blockPresences: array expected");r.blockPresences=[];for(var n=0;n<t.blockPresences.length;++n){if(typeof t.blockPresences[n]!="object")throw TypeError(".Message.blockPresences: object expected");r.blockPresences[n]=z.Message.BlockPresence.fromObject(t.blockPresences[n])}}return t.pendingBytes!=null&&(r.pendingBytes=t.pendingBytes|0),r},s.toObject=function(t,r){r||(r={});var n={};if((r.arrays||r.defaults)&&(n.blocks=[],n.payload=[],n.blockPresences=[]),r.defaults&&(n.wantlist=null,n.pendingBytes=0),t.wantlist!=null&&t.hasOwnProperty("wantlist")&&(n.wantlist=z.Message.Wantlist.toObject(t.wantlist,r)),t.blocks&&t.blocks.length){n.blocks=[];for(var a=0;a<t.blocks.length;++a)n.blocks[a]=r.bytes===String?F.base64.encode(t.blocks[a],0,t.blocks[a].length):r.bytes===Array?Array.prototype.slice.call(t.blocks[a]):t.blocks[a]}if(t.payload&&t.payload.length){n.payload=[];for(var a=0;a<t.payload.length;++a)n.payload[a]=z.Message.Block.toObject(t.payload[a],r)}if(t.blockPresences&&t.blockPresences.length){n.blockPresences=[];for(var a=0;a<t.blockPresences.length;++a)n.blockPresences[a]=z.Message.BlockPresence.toObject(t.blockPresences[a],r)}return t.pendingBytes!=null&&t.hasOwnProperty("pendingBytes")&&(n.pendingBytes=t.pendingBytes),n},s.prototype.toJSON=function(){return this.constructor.toObject(this,D.util.toJSONOptions)},s.getTypeUrl=function(t){return t===void 0&&(t="type.googleapis.com"),t+"/Message"},s.Wantlist=function(){function e(t){if(this.entries=[],t)for(var r=Object.keys(t),n=0;n<r.length;++n)t[r[n]]!=null&&(this[r[n]]=t[r[n]])}return e.prototype.entries=F.emptyArray,e.prototype.full=!1,e.encode=function(r,n){if(n||(n=Sr.create()),r.entries!=null&&r.entries.length)for(var a=0;a<r.entries.length;++a)z.Message.Wantlist.Entry.encode(r.entries[a],n.uint32(10).fork()).ldelim();return r.full!=null&&Object.hasOwnProperty.call(r,"full")&&n.uint32(16).bool(r.full),n},e.decode=function(r,n){r instanceof Je||(r=Je.create(r));for(var a=n===void 0?r.len:r.pos+n,i=new z.Message.Wantlist;r.pos<a;){var o=r.uint32();switch(o>>>3){case 1:{i.entries&&i.entries.length||(i.entries=[]),i.entries.push(z.Message.Wantlist.Entry.decode(r,r.uint32()));break}case 2:{i.full=r.bool();break}default:r.skipType(o&7);break}}return i},e.fromObject=function(r){if(r instanceof z.Message.Wantlist)return r;var n=new z.Message.Wantlist;if(r.entries){if(!Array.isArray(r.entries))throw TypeError(".Message.Wantlist.entries: array expected");n.entries=[];for(var a=0;a<r.entries.length;++a){if(typeof r.entries[a]!="object")throw TypeError(".Message.Wantlist.entries: object expected");n.entries[a]=z.Message.Wantlist.Entry.fromObject(r.entries[a])}}return r.full!=null&&(n.full=!!r.full),n},e.toObject=function(r,n){n||(n={});var a={};if((n.arrays||n.defaults)&&(a.entries=[]),n.defaults&&(a.full=!1),r.entries&&r.entries.length){a.entries=[];for(var i=0;i<r.entries.length;++i)a.entries[i]=z.Message.Wantlist.Entry.toObject(r.entries[i],n)}return r.full!=null&&r.hasOwnProperty("full")&&(a.full=r.full),a},e.prototype.toJSON=function(){return this.constructor.toObject(this,D.util.toJSONOptions)},e.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/Message.Wantlist"},e.WantType=function(){const t={},r=Object.create(t);return r[t[0]="Block"]=0,r[t[1]="Have"]=1,r}(),e.Entry=function(){function t(r){if(r)for(var n=Object.keys(r),a=0;a<n.length;++a)r[n[a]]!=null&&(this[n[a]]=r[n[a]])}return t.prototype.block=F.newBuffer([]),t.prototype.priority=0,t.prototype.cancel=!1,t.prototype.wantType=0,t.prototype.sendDontHave=!1,t.encode=function(n,a){return a||(a=Sr.create()),n.block!=null&&Object.hasOwnProperty.call(n,"block")&&a.uint32(10).bytes(n.block),n.priority!=null&&Object.hasOwnProperty.call(n,"priority")&&a.uint32(16).int32(n.priority),n.cancel!=null&&Object.hasOwnProperty.call(n,"cancel")&&a.uint32(24).bool(n.cancel),n.wantType!=null&&Object.hasOwnProperty.call(n,"wantType")&&a.uint32(32).int32(n.wantType),n.sendDontHave!=null&&Object.hasOwnProperty.call(n,"sendDontHave")&&a.uint32(40).bool(n.sendDontHave),a},t.decode=function(n,a){n instanceof Je||(n=Je.create(n));for(var i=a===void 0?n.len:n.pos+a,o=new z.Message.Wantlist.Entry;n.pos<i;){var c=n.uint32();switch(c>>>3){case 1:{o.block=n.bytes();break}case 2:{o.priority=n.int32();break}case 3:{o.cancel=n.bool();break}case 4:{o.wantType=n.int32();break}case 5:{o.sendDontHave=n.bool();break}default:n.skipType(c&7);break}}return o},t.fromObject=function(n){if(n instanceof z.Message.Wantlist.Entry)return n;var a=new z.Message.Wantlist.Entry;switch(n.block!=null&&(typeof n.block=="string"?F.base64.decode(n.block,a.block=F.newBuffer(F.base64.length(n.block)),0):n.block.length>=0&&(a.block=n.block)),n.priority!=null&&(a.priority=n.priority|0),n.cancel!=null&&(a.cancel=!!n.cancel),n.wantType){case"Block":case 0:a.wantType=0;break;case"Have":case 1:a.wantType=1;break}return n.sendDontHave!=null&&(a.sendDontHave=!!n.sendDontHave),a},t.toObject=function(n,a){a||(a={});var i={};return a.defaults&&(a.bytes===String?i.block="":(i.block=[],a.bytes!==Array&&(i.block=F.newBuffer(i.block))),i.priority=0,i.cancel=!1,i.wantType=a.enums===String?"Block":0,i.sendDontHave=!1),n.block!=null&&n.hasOwnProperty("block")&&(i.block=a.bytes===String?F.base64.encode(n.block,0,n.block.length):a.bytes===Array?Array.prototype.slice.call(n.block):n.block),n.priority!=null&&n.hasOwnProperty("priority")&&(i.priority=n.priority),n.cancel!=null&&n.hasOwnProperty("cancel")&&(i.cancel=n.cancel),n.wantType!=null&&n.hasOwnProperty("wantType")&&(i.wantType=a.enums===String?z.Message.Wantlist.WantType[n.wantType]:n.wantType),n.sendDontHave!=null&&n.hasOwnProperty("sendDontHave")&&(i.sendDontHave=n.sendDontHave),i},t.prototype.toJSON=function(){return this.constructor.toObject(this,D.util.toJSONOptions)},t.getTypeUrl=function(n){return n===void 0&&(n="type.googleapis.com"),n+"/Message.Wantlist.Entry"},t}(),e}(),s.Block=function(){function e(t){if(t)for(var r=Object.keys(t),n=0;n<r.length;++n)t[r[n]]!=null&&(this[r[n]]=t[r[n]])}return e.prototype.prefix=F.newBuffer([]),e.prototype.data=F.newBuffer([]),e.encode=function(r,n){return n||(n=Sr.create()),r.prefix!=null&&Object.hasOwnProperty.call(r,"prefix")&&n.uint32(10).bytes(r.prefix),r.data!=null&&Object.hasOwnProperty.call(r,"data")&&n.uint32(18).bytes(r.data),n},e.decode=function(r,n){r instanceof Je||(r=Je.create(r));for(var a=n===void 0?r.len:r.pos+n,i=new z.Message.Block;r.pos<a;){var o=r.uint32();switch(o>>>3){case 1:{i.prefix=r.bytes();break}case 2:{i.data=r.bytes();break}default:r.skipType(o&7);break}}return i},e.fromObject=function(r){if(r instanceof z.Message.Block)return r;var n=new z.Message.Block;return r.prefix!=null&&(typeof r.prefix=="string"?F.base64.decode(r.prefix,n.prefix=F.newBuffer(F.base64.length(r.prefix)),0):r.prefix.length>=0&&(n.prefix=r.prefix)),r.data!=null&&(typeof r.data=="string"?F.base64.decode(r.data,n.data=F.newBuffer(F.base64.length(r.data)),0):r.data.length>=0&&(n.data=r.data)),n},e.toObject=function(r,n){n||(n={});var a={};return n.defaults&&(n.bytes===String?a.prefix="":(a.prefix=[],n.bytes!==Array&&(a.prefix=F.newBuffer(a.prefix))),n.bytes===String?a.data="":(a.data=[],n.bytes!==Array&&(a.data=F.newBuffer(a.data)))),r.prefix!=null&&r.hasOwnProperty("prefix")&&(a.prefix=n.bytes===String?F.base64.encode(r.prefix,0,r.prefix.length):n.bytes===Array?Array.prototype.slice.call(r.prefix):r.prefix),r.data!=null&&r.hasOwnProperty("data")&&(a.data=n.bytes===String?F.base64.encode(r.data,0,r.data.length):n.bytes===Array?Array.prototype.slice.call(r.data):r.data),a},e.prototype.toJSON=function(){return this.constructor.toObject(this,D.util.toJSONOptions)},e.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/Message.Block"},e}(),s.BlockPresenceType=function(){const e={},t=Object.create(e);return t[e[0]="Have"]=0,t[e[1]="DontHave"]=1,t}(),s.BlockPresence=function(){function e(t){if(t)for(var r=Object.keys(t),n=0;n<r.length;++n)t[r[n]]!=null&&(this[r[n]]=t[r[n]])}return e.prototype.cid=F.newBuffer([]),e.prototype.type=0,e.encode=function(r,n){return n||(n=Sr.create()),r.cid!=null&&Object.hasOwnProperty.call(r,"cid")&&n.uint32(10).bytes(r.cid),r.type!=null&&Object.hasOwnProperty.call(r,"type")&&n.uint32(16).int32(r.type),n},e.decode=function(r,n){r instanceof Je||(r=Je.create(r));for(var a=n===void 0?r.len:r.pos+n,i=new z.Message.BlockPresence;r.pos<a;){var o=r.uint32();switch(o>>>3){case 1:{i.cid=r.bytes();break}case 2:{i.type=r.int32();break}default:r.skipType(o&7);break}}return i},e.fromObject=function(r){if(r instanceof z.Message.BlockPresence)return r;var n=new z.Message.BlockPresence;switch(r.cid!=null&&(typeof r.cid=="string"?F.base64.decode(r.cid,n.cid=F.newBuffer(F.base64.length(r.cid)),0):r.cid.length>=0&&(n.cid=r.cid)),r.type){case"Have":case 0:n.type=0;break;case"DontHave":case 1:n.type=1;break}return n},e.toObject=function(r,n){n||(n={});var a={};return n.defaults&&(n.bytes===String?a.cid="":(a.cid=[],n.bytes!==Array&&(a.cid=F.newBuffer(a.cid))),a.type=n.enums===String?"Have":0),r.cid!=null&&r.hasOwnProperty("cid")&&(a.cid=n.bytes===String?F.base64.encode(r.cid,0,r.cid.length):n.bytes===Array?Array.prototype.slice.call(r.cid):r.cid),r.type!=null&&r.hasOwnProperty("type")&&(a.type=n.enums===String?z.Message.BlockPresenceType[r.type]:r.type),a},e.prototype.toJSON=function(){return this.constructor.toObject(this,D.util.toJSONOptions)},e.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/Message.BlockPresence"},e}(),s})(),Mc={Block:Ke.Wantlist.WantType.Block,Have:Ke.Wantlist.WantType.Have},kk=(s,e)=>Array.prototype.slice.call(e,0).sort((t,r)=>{const n=s(t),a=s(r);return n<a?-1:n>a?1:0});class ds{constructor(e,t){this.set=t?_n({name:"ipfs_bitswap_wantlist",metrics:t.metrics}):new Map,this._stats=e}get length(){return this.set.size}add(e,t,r){const n=e.toString(U),a=this.set.get(n);a?(a.inc(),a.priority=t,a.wantType===Mc.Have&&r===Mc.Block&&(a.wantType=r)):(this.set.set(n,new Vd(e,t,r)),this._stats&&this._stats.push(null,"wantListSize",1))}remove(e){const t=e.toString(U),r=this.set.get(t);r&&(r.dec(),!r.hasRefs()&&(this.set.delete(t),this._stats&&this._stats.push(null,"wantListSize",-1)))}removeForce(e){this.set.has(e)&&this.set.delete(e)}forEach(e){return this.set.forEach(e)}entries(){return this.set.entries()}sortedEntries(){return new Map(kk(e=>e[1].key,Array.from(this.set.entries())))}contains(e){const t=e.toString(U);return this.set.has(t)}get(e){const t=e.toString(U);return this.set.get(t)}}ds.Entry=Vd;const $k=ds.Entry;class on{constructor(e,t,r,n,a){this.entry=new $k(e,t,r),this.cancel=!!n,this.sendDontHave=!!a}get cid(){return this.entry.cid}set cid(e){this.entry.cid=e}get priority(){return this.entry.priority}set priority(e){this.entry.priority=e}get wantType(){return this.entry.wantType}set wantType(e){this.entry.wantType=e}get[Symbol.toStringTag](){return`BitswapMessageEntry ${this.cid.toString(U)} <cancel: ${this.cancel}, priority: ${this.priority}>`}equals(e){return this.cancel===e.cancel&&this.sendDontHave===e.sendDontHave&&this.wantType===e.wantType&&this.entry.equals(e.entry)}}const ur=(s,e)=>{const t=["bitswap"];return e&&t.push(e),s&&t.push(`${s.toString().slice(0,8)}`),M(t.join(":"))},fa=(s,e)=>{if(s.size!==e.size)return!1;for(const[t,r]of s){const n=e.get(t);if(n===void 0||r instanceof Uint8Array&&n instanceof Uint8Array&&!fn(r,n)||r instanceof on&&n instanceof on&&!r.equals(n))return!1}return!0};class Z{constructor(e){this.full=e,this.wantlist=new Map,this.blocks=new Map,this.blockPresences=new Map,this.pendingBytes=0}get empty(){return this.blocks.size===0&&this.wantlist.size===0&&this.blockPresences.size===0}addEntry(e,t,r,n,a){r==null&&(r=Z.WantType.Block);const i=e.toString(U),o=this.wantlist.get(i);o?(o.wantType===r&&(o.priority=t),n&&(o.cancel=!!n),a&&(o.sendDontHave=!!a),r===Z.WantType.Block&&o.wantType===Z.WantType.Have&&(o.wantType=r)):this.wantlist.set(i,new on(e,t,r,n,a))}addBlock(e,t){const r=e.toString(U);this.blocks.set(r,t)}addHave(e){const t=e.toString(U);this.blockPresences.has(t)||this.blockPresences.set(t,Z.BlockPresenceType.Have)}addDontHave(e){const t=e.toString(U);this.blockPresences.has(t)||this.blockPresences.set(t,Z.BlockPresenceType.DontHave)}cancel(e){const t=e.toString(U);this.wantlist.delete(t),this.addEntry(e,0,Z.WantType.Block,!0,!1)}setPendingBytes(e){this.pendingBytes=e}serializeToBitswap100(){const e={wantlist:{entries:Array.from(this.wantlist.values()).map(t=>({block:t.cid.bytes,priority:Number(t.priority),cancel:!!t.cancel})),full:this.full?!0:void 0},blocks:Array.from(this.blocks.values())};return Ke.encode(e).finish()}serializeToBitswap110(){const e={wantlist:{entries:Array.from(this.wantlist.values()).map(t=>({block:t.cid.bytes,priority:Number(t.priority),wantType:t.wantType,cancel:!!t.cancel,sendDontHave:!!t.sendDontHave})),full:this.full?!0:void 0},blockPresences:[],payload:[],pendingBytes:this.pendingBytes};for(const[t,r]of this.blocks.entries()){const n=w.parse(t),a=n.version,i=n.code,o=n.multihash.code,c=n.multihash.digest.length,l=Sk([a,i,o,c]);e.payload.push(new Ke.Block({prefix:l,data:r}))}for(const[t,r]of this.blockPresences)e.blockPresences.push(new Ke.BlockPresence({cid:w.parse(t).bytes,type:r}));return this.pendingBytes>0&&(e.pendingBytes=this.pendingBytes),Ke.encode(e).finish()}equals(e){return!(this.full!==e.full||this.pendingBytes!==e.pendingBytes||!fa(this.wantlist,e.wantlist)||!fa(this.blocks,e.blocks)||!fa(this.blockPresences,e.blockPresences))}get[Symbol.toStringTag](){const e=Array.from(this.wantlist.keys()),t=Array.from(this.blocks.keys());return`BitswapMessage <full: ${this.full}, list: ${e}, blocks: ${t}>`}}Z.deserialize=async(s,e)=>{const t=Ke.decode(s),r=t.wantlist&&t.wantlist.full||!1,n=new Z(r);return t.wantlist&&t.wantlist.entries&&t.wantlist.entries.forEach(a=>{if(!a.block)return;const i=w.decode(a.block);n.addEntry(i,a.priority||0,a.wantType,!!a.cancel,!!a.sendDontHave)}),t.blockPresences&&t.blockPresences.forEach(a=>{if(!a.cid)return;const i=w.decode(a.cid);a.type===Z.BlockPresenceType.Have?n.addHave(i):n.addDontHave(i)}),t.blocks.length>0?(await Promise.all(t.blocks.map(async a=>{const i=await me.digest(a),o=w.createV0(i);n.addBlock(o,a)})),n):(t.payload.length>0&&(await Promise.all(t.payload.map(async a=>{if(!a.prefix||!a.data)return;const i=Uh(a.prefix),o=i[0],c=i[1],l=i[2],u=l===me.code?me:e&&await e.getHasher(l);if(!u)throw new El("Unknown hash algorithm","ERR_UNKNOWN_HASH_ALG");const d=await u.digest(a.data),h=w.create(o,c,d);n.addBlock(h,a.data)})),n.setPendingBytes(t.pendingBytes)),n)};Z.blockPresenceSize=s=>s.bytes.length+1;Z.Entry=on;Z.WantType={Block:Ke.Wantlist.WantType.Block,Have:Ke.Wantlist.WantType.Have};Z.BlockPresenceType={Have:Ke.BlockPresenceType.Have,DontHave:Ke.BlockPresenceType.DontHave};const Pk=3,Ak=Math.pow(2,31)-1,Rk=1e3,Tk=1;class Ok{constructor(e,t,r){this.peerId=t,this.network=r,this.refcnt=1,this._entries=[],this._log=ur(e,"msgqueue"),this.sendEntries=Fh(this._sendEntries.bind(this),Tk)}addMessage(e){e.empty||this.send(e)}addEntries(e){this._entries=this._entries.concat(e),this.sendEntries()}_sendEntries(){if(!this._entries.length)return;const e=new Z(!1);this._entries.forEach(t=>{t.cancel?e.cancel(t.cid):e.addEntry(t.cid,t.priority)}),this._entries=[],this.addMessage(e)}async send(e){try{await this.network.connectTo(this.peerId)}catch(t){this._log.error("cant connect to peer %s: %s",this.peerId.toString(),t.message);return}this._log("sending message to peer %s",this.peerId.toString()),this.network.sendMessage(this.peerId,e).catch(t=>{this._log.error("send error: %s",t.message)})}}class Ck{constructor(e,t,r,n){this.peers=_n({name:"ipfs_bitswap_want_manager_peers",metrics:n.metrics}),this.wantlist=new ds(r,n),this.network=t,this._stats=r,this._peerId=e,this._log=ur(e,"want")}_addEntries(e,t,r){const n=e.map((a,i)=>new Z.Entry(a,Ak-i,Z.WantType.Block,t));n.forEach(a=>{a.cancel?r?this.wantlist.removeForce(a.cid.toString(U)):this.wantlist.remove(a.cid):(this._log("adding to wl"),this.wantlist.add(a.cid,a.priority))});for(const a of this.peers.values())a.addEntries(n)}_startPeerHandler(e){let t=this.peers.get(e.toString());if(t){t.refcnt++;return}t=new Ok(this._peerId,e,this.network);const r=new Z(!0);for(const n of this.wantlist.entries())r.addEntry(n[1].cid,n[1].priority);return t.addMessage(r),this.peers.set(e.toString(),t),t}_stopPeerHandler(e){const t=this.peers.get(e.toString());t&&(t.refcnt--,!(t.refcnt>0)&&this.peers.delete(e.toString()))}wantBlocks(e,t={}){this._addEntries(e,!1),t&&t.signal&&t.signal.addEventListener("abort",()=>{this.cancelWants(e)})}unwantBlocks(e){this._log("unwant blocks: %s",e.length),this._addEntries(e,!0,!0)}cancelWants(e){this._log("cancel wants: %s",e.length),this._addEntries(e,!0)}connectedPeers(){return Array.from(this.peers.keys())}connected(e){this._startPeerHandler(e)}disconnected(e){this._stopPeerHandler(e)}start(){}stop(){this.peers.forEach(e=>this.disconnected(e.peerId))}}const si="/ipfs/bitswap/1.0.0",ni="/ipfs/bitswap/1.1.0",ai="/ipfs/bitswap/1.2.0",Ik=32,Nk=128,xk=3e4;let Lk=class{constructor(e,t,r,n={}){this._log=ur(e.peerId,"network"),this._libp2p=e,this._bitswap=t,this._protocols=[si],n.b100Only||(this._protocols.unshift(ni),this._protocols.unshift(ai)),this._stats=r,this._running=!1,this._onPeerConnect=this._onPeerConnect.bind(this),this._onPeerDisconnect=this._onPeerDisconnect.bind(this),this._onConnection=this._onConnection.bind(this),this._hashLoader=n.hashLoader,this._maxInboundStreams=n.maxInboundStreams??Ik,this._maxOutboundStreams=n.maxOutboundStreams??Nk,this._incomingStreamTimeout=n.incomingStreamTimeout??xk}async start(){this._running=!0,await this._libp2p.handle(this._protocols,this._onConnection,{maxInboundStreams:this._maxInboundStreams,maxOutboundStreams:this._maxOutboundStreams});const e=Zh({onConnect:this._onPeerConnect,onDisconnect:this._onPeerDisconnect});this._registrarIds=[];for(const t of this._protocols)this._registrarIds.push(await this._libp2p.register(t,e));this._libp2p.getConnections().forEach(t=>{this._onPeerConnect(t.remotePeer)})}async stop(){if(this._running=!1,await this._libp2p.unhandle(this._protocols),this._registrarIds!=null){for(const e of this._registrarIds)this._libp2p.unregister(e);this._registrarIds=[]}}_onConnection({stream:e,connection:t}){if(!this._running)return;const r=new Jr.TimeoutController(this._incomingStreamTimeout);Promise.resolve().then(async()=>{this._log("incoming new bitswap %s connection from %p",e.stat.protocol,t.remotePeer),await it(qh(e.source,r.signal),Hh(),async n=>{for await(const a of n){try{const i=await Z.deserialize(a.subarray(),this._hashLoader);await this._bitswap._receiveMessage(t.remotePeer,i)}catch(i){this._bitswap._receiveError(i);break}r.reset()}})}).catch(n=>{this._log(n),e.abort(n)}).finally(()=>{r.clear(),e.close()})}_onPeerConnect(e){this._bitswap._onPeerConnected(e)}_onPeerDisconnect(e){this._bitswap._onPeerDisconnected(e)}findProviders(e,t={}){return this._libp2p.contentRouting.findProviders(e,t)}async findAndConnect(e,t){const r=[];let n=0;for await(const a of this.findProviders(e,t))if(this._log(`connecting to provider ${a.id}`),r.push(this.connectTo(a.id,t).catch(i=>{this._log.error(i)})),n++,n===Pk)break;await Promise.all(r)}async provide(e,t){await this._libp2p.contentRouting.provide(e,t)}async sendMessage(e,t){if(!this._running)throw new Error("network isn't running");const r=e.toString();this._log("sendMessage to %s",r,t);const a=await(await this._libp2p.dial(e)).newStream([ai,ni,si]);await Bk(a,t,this._log),this._updateSentStats(e,t.blocks)}async connectTo(e,t){if(!this._running)throw new Error("network isn't running");return this._libp2p.dial(e,t)}_updateSentStats(e,t){const r=e.toString();if(this._stats){for(const n of t.values())this._stats.push(r,"dataSent",n.length);this._stats.push(r,"blocksSent",t.size)}}};async function Bk(s,e,t){try{let r;switch(s.stat.protocol){case si:r=e.serializeToBitswap100();break;case ni:case ai:r=e.serializeToBitswap110();break;default:throw new Error("Unknown protocol: "+s.stat.protocol)}await it([r],Kh(),s)}catch(r){t(r)}finally{s.close()}}class jk{constructor(e){this.partner=e,this.wantlist=new ds,this.exchangeCount=0,this.sentToPeer=new Map,this.accounting={bytesSent:0,bytesRecv:0}}sentBytes(e){this.exchangeCount++,this.lastExchange=new Date().getTime(),this.accounting.bytesSent+=e}receivedBytes(e){this.exchangeCount++,this.lastExchange=new Date().getTime(),this.accounting.bytesRecv+=e}wants(e,t,r){this.wantlist.add(e,t,r)}cancelWant(e){this.wantlist.remove(e)}wantlistContains(e){return this.wantlist.get(e)}debtRatio(){return this.accounting.bytesSent/(this.accounting.bytesRecv+1)}}class Wd extends Map{constructor(e,t){super(),this._cmp=t||this._defaultSort,this._keys=[];for(const[r,n]of e||[])this.set(r,n)}update(e){if(e<0||e>=this._keys.length)return;const t=this._keys[e];this._keys.splice(e,1);const r=this._find(t);this._keys.splice(r,0,t)}set(e,t){if(this.has(e)){const n=this.indexOf(e);this._keys.splice(n,1)}super.set(e,t);const r=this._find(e);return this._keys.splice(r,0,e),this}clear(){super.clear(),this._keys=[]}delete(e){if(!this.has(e))return!1;const t=this.indexOf(e);return this._keys.splice(t,1),super.delete(e)}indexOf(e){if(!this.has(e))return-1;const t=this._find(e);if(this._keys[t]===e)return t;for(let r=1;r<this._keys.length;r++){if(this._keys[t+r]===e)return t+r;if(this._keys[t-r]===e)return t-r}return-1}_find(e){let t=0,r=this._keys.length;for(;t<r;){const n=t+r>>>1,a=this._kCmp(this._keys[n],e);if(a<0)t=n+1;else if(a>0)r=n;else return n}return t}*keys(){for(const e of this._keys)yield e}*values(){for(const e of this._keys)yield this.get(e)}*entries(){for(const e of this._keys)yield[e,this.get(e)]}*[Symbol.iterator](){yield*this.entries()}forEach(e,t){if(e)for(const r of this._keys)e.apply(t,[[r,this.get(r)]])}_defaultSort(e,t){return e[0]<t[0]?-1:t[0]<e[0]?1:0}_kCmp(e,t){return this._cmp([e,this.get(e)],[t,this.get(t)])}}const Mk={hasNewInfo(){return!1},merge(){}};class zk{constructor(e=Mk){this._taskMerger=e,this._byPeer=new Wd([],zc.compare)}pushTasks(e,t){let r=this._byPeer.get(e.toString());r||(r=new zc(e,this._taskMerger)),r.pushTasks(t),this._byPeer.set(e.toString(),r)}popTasks(e){const t=this._head();if(t===void 0)return{tasks:[],pendingSize:0};const{tasks:r,pendingSize:n}=t.popTasks(e);if(r.length===0)return{tasks:r,pendingSize:n};const a=t.peerId;return t.isIdle()?this._byPeer.delete(a.toString()):this._byPeer.update(0),{peerId:a,tasks:r,pendingSize:n}}_head(){if(this._byPeer.size!==0)for(const[,e]of this._byPeer)return e}remove(e,t){const r=this._byPeer.get(t.toString());r&&r.remove(e)}tasksDone(e,t){const r=this._byPeer.get(e.toString());if(!r)return;const n=this._byPeer.indexOf(e.toString());for(const a of t)r.taskDone(a);this._byPeer.update(n)}}class zc{constructor(e,t){this.peerId=e,this._taskMerger=t,this._activeTotalSize=0,this._pending=new Uk,this._active=new Set}pushTasks(e){for(const t of e)this._pushTask(t)}_pushTask(e){if(!this._taskHasMoreInfoThanActiveTasks(e))return;const t=this._pending.get(e.topic);if(t){e.priority>t.priority&&this._pending.updatePriority(e.topic,e.priority),this._taskMerger.merge(e,t);return}this._pending.add(e)}_taskHasMoreInfoThanActiveTasks(e){const t=[];for(const r of this._active)r.topic===e.topic&&t.push(r);return t.length===0?!0:this._taskMerger.hasNewInfo(e,t)}popTasks(e){let t=0;const r=[],n=this._pending.tasks();for(let a=0;a<n.length&&t<e;a++){const i=n[a];r.push(i),t+=i.size,this._pending.delete(i.topic),this._activeTotalSize+=i.size,this._active.add(i)}return{tasks:r,pendingSize:this._pending.totalSize}}taskDone(e){this._active.has(e)&&(this._activeTotalSize-=e.size,this._active.delete(e))}remove(e){this._pending.delete(e)}isIdle(){return this._pending.length===0&&this._active.size===0}static compare(e,t){return e[1]._pending.length===0?1:t[1]._pending.length===0?-1:e[1]._activeTotalSize===t[1]._activeTotalSize?t[1]._pending.length-e[1]._pending.length:e[1]._activeTotalSize-t[1]._activeTotalSize}}class Uk{constructor(){this._tasks=new Wd([],this._compare)}get length(){return this._tasks.size}get totalSize(){return[...this._tasks.values()].reduce((e,t)=>e+t.task.size,0)}get(e){return(this._tasks.get(e)||{}).task}add(e){this._tasks.set(e.topic,{created:Date.now(),task:e})}delete(e){this._tasks.delete(e)}tasks(){return[...this._tasks.values()].map(e=>e.task)}updatePriority(e,t){const r=this._tasks.get(e);if(!r)return;const n=this._tasks.indexOf(e);r.task.priority=t,this._tasks.update(n)}_compare(e,t){return e[1].task.priority===t[1].task.priority?e[1].created-t[1].created:t[1].task.priority-e[1].task.priority}}const Fk={hasNewInfo(s,e){let t=!1,r=!1;for(const n of e)n.data.haveBlock&&(t=!0),n.data.isWantBlock&&(r=!0);return!!(!r&&s.data.isWantBlock||!t&&s.data.haveBlock)},merge(s,e){const t=s.data,r=e.data;!r.haveBlock&&t.haveBlock&&(r.haveBlock=t.haveBlock,r.blockSize=t.blockSize),!r.isWantBlock&&t.isWantBlock&&(r.isWantBlock=!0,(!r.haveBlock||t.haveBlock)&&(r.haveBlock=t.haveBlock,e.size=s.size)),r.isWantBlock&&r.haveBlock&&(e.size=r.blockSize)}},Uc=Z.WantType,Hk=16*1024,qk=1024;class Kk{constructor(e,t,r,n,a,i={}){this._log=ur(e,"engine"),this.blockstore=t,this.network=r,this._stats=n,this._opts=this._processOpts(i),this.ledgerMap=_n({name:"ipfs_bitswap_ledger_map",metrics:a.metrics}),this._running=!1,this._requestQueue=new zk(Fk)}_processOpts(e){return{maxSizeReplaceHasWithBlock:qk,targetMessageSize:Hk,...e}}_scheduleProcessTasks(){setTimeout(()=>{this._processTasks()})}async _processTasks(){if(!this._running)return;const{peerId:e,tasks:t,pendingSize:r}=this._requestQueue.popTasks(this._opts.targetMessageSize);if(t.length===0)return;const n=new Z(!1);n.setPendingBytes(r);const a=[],i=new Map;for(const c of t){const l=w.parse(c.topic);c.data.haveBlock?c.data.isWantBlock?(a.push(l),i.set(c.topic,c.data)):n.addHave(l):n.addDontHave(l)}const o=await this._getBlocks(a);for(const[c,l]of i){const u=w.parse(c),d=o.get(c);d?n.addBlock(u,d):l.sendDontHave&&n.addDontHave(u)}if(n.empty){e&&this._requestQueue.tasksDone(e,t),this._scheduleProcessTasks();return}try{e&&await this.network.sendMessage(e,n);for(const[c,l]of o.entries())e&&this.messageSent(e,w.parse(c),l)}catch(c){this._log.error(c)}e&&this._requestQueue.tasksDone(e,t),this._scheduleProcessTasks()}wantlistForPeer(e){const t=e.toString(),r=this.ledgerMap.get(t);return r?r.wantlist.sortedEntries():new Map}ledgerForPeer(e){const t=e.toString(),r=this.ledgerMap.get(t);return r?{peer:r.partner,value:r.debtRatio(),sent:r.accounting.bytesSent,recv:r.accounting.bytesRecv,exchanged:r.exchangeCount}:null}peers(){return Array.from(this.ledgerMap.values()).map(e=>e.partner)}receivedBlocks(e){if(e.length){for(const t of this.ledgerMap.values())for(const r of e){const n=t.wantlistContains(r.cid);if(!n)continue;const a=r.data.length,i=this._sendAsBlock(n.wantType,a);let o=a;i||(o=Z.blockPresenceSize(n.cid)),this._requestQueue.pushTasks(t.partner,[{topic:n.cid.toString(U),priority:n.priority,size:o,data:{blockSize:a,isWantBlock:i,haveBlock:!0,sendDontHave:!1}}])}this._scheduleProcessTasks()}}async messageReceived(e,t){const r=this._findOrCreate(e);if(t.empty)return;if(t.full&&(r.wantlist=new ds),this._updateBlockAccounting(t.blocks,r),t.wantlist.size===0){this._scheduleProcessTasks();return}const n=[],a=[];t.wantlist.forEach(i=>{i.cancel?(r.cancelWant(i.cid),n.push(i.cid)):(r.wants(i.cid,i.priority,i.wantType),a.push(i))}),this._cancelWants(e,n),await this._addWants(e,a),this._scheduleProcessTasks()}_cancelWants(e,t){for(const r of t)this._requestQueue.remove(r.toString(U),e)}async _addWants(e,t){const r=await this._getBlockSizes(t.map(a=>a.cid)),n=[];for(const a of t){const i=a.cid.toString(U),o=r.get(i);if(o==null)a.sendDontHave&&n.push({topic:i,priority:a.priority,size:Z.blockPresenceSize(a.cid),data:{isWantBlock:a.wantType===Uc.Block,blockSize:0,haveBlock:!1,sendDontHave:a.sendDontHave}});else{const c=this._sendAsBlock(a.wantType,o);let l=o;c||(l=Z.blockPresenceSize(a.cid)),n.push({topic:i,priority:a.priority,size:l,data:{isWantBlock:c,blockSize:o,haveBlock:!0,sendDontHave:a.sendDontHave}})}this._requestQueue.pushTasks(e,n)}}_sendAsBlock(e,t){return e===Uc.Block||t<=this._opts.maxSizeReplaceHasWithBlock}async _getBlockSizes(e){const t=await this._getBlocks(e);return new Map([...t].map(([r,n])=>[r,n.length]))}async _getBlocks(e){const t=new Map;return await Promise.all(e.map(async r=>{try{const n=await this.blockstore.get(r);t.set(r.toString(U),n)}catch(n){n.code!=="ERR_NOT_FOUND"&&this._log.error("failed to query blockstore for %s: %s",r,n)}})),t}_updateBlockAccounting(e,t){for(const r of e.values())this._log("got block (%s bytes)",r.length),t.receivedBytes(r.length)}messageSent(e,t,r){const n=this._findOrCreate(e);n.sentBytes(r.length),n.wantlist.remove(t)}numBytesSentTo(e){return this._findOrCreate(e).accounting.bytesSent}numBytesReceivedFrom(e){return this._findOrCreate(e).accounting.bytesRecv}peerDisconnected(e){this.ledgerMap.delete(e.toString())}_findOrCreate(e){const t=e.toString(),r=this.ledgerMap.get(t);if(r)return r;const n=new jk(e);return this.ledgerMap.set(t,n),this._stats&&this._stats.push(t,"peerCount",1),n}start(){this._running=!0}stop(){this._running=!1}}const Fc=s=>`unwant:${R(s.multihash.bytes,"base64")}`,Hc=s=>`block:${R(s.multihash.bytes,"base64")}`;class Vk extends Yr.EventEmitter{constructor(e){super(),this.setMaxListeners(Rk),this._log=ur(e,"notif")}hasBlock(e,t){const r=Hc(e);this._log(r),this.emit(r,t)}wantBlock(e,t={}){if(!e)throw new Error("Not a valid cid");const r=Hc(e),n=Fc(e);return this._log(`wantBlock:${e}`),new Promise((a,i)=>{const o=()=>{this.removeListener(r,c),i(new Error(`Block for ${e} unwanted`))},c=l=>{this.removeListener(n,o),a(l)};this.once(n,o),this.once(r,c),t&&t.signal&&t.signal.addEventListener("abort",()=>{this.removeListener(r,c),this.removeListener(n,o),i(new Error(`Want for ${e} aborted`))})})}unwantBlock(e){const t=Fc(e);this._log(t),this.emit(t)}}class qc extends Yr.EventEmitter{constructor(e,t){super(),this._options=t,this._queue=[],this._stats={},this._frequencyLastTime=Date.now(),this._frequencyAccumulators={},this._movingAverages={},this._update=this._update.bind(this),e.forEach(r=>{this._stats[r]=BigInt(0),this._movingAverages[r]={},this._options.movingAverageIntervals.forEach(n=>{(this._movingAverages[r][n]=fo(n)).push(this._frequencyLastTime,0)})}),this._enabled=this._options.enabled}enable(){this._enabled=!0}disable(){this._disabled=!0}stop(){this._timeout&&clearTimeout(this._timeout)}get snapshot(){return Object.assign({},this._stats)}get movingAverages(){return Object.assign({},this._movingAverages)}push(e,t){this._enabled&&(this._queue.push([e,t,Date.now()]),this._resetComputeTimeout())}_resetComputeTimeout(){this._timeout&&clearTimeout(this._timeout),this._timeout=setTimeout(this._update,this._nextTimeout())}_nextTimeout(){const e=this._queue.length/this._options.computeThrottleMaxQueueSize;return Math.max(this._options.computeThrottleTimeout*(1-e),0)}_update(){if(this._timeout=null,this._queue.length){let e;for(;this._queue.length;){const t=e=this._queue.shift();t&&this._applyOp(t)}e&&this._updateFrequency(e[2]),this.emit("update",this._stats)}}_updateFrequency(e){const t=e-this._frequencyLastTime;t&&Object.keys(this._stats).forEach(r=>{this._updateFrequencyFor(r,t,e)}),this._frequencyLastTime=e}_updateFrequencyFor(e,t,r){const n=this._frequencyAccumulators[e]||0;this._frequencyAccumulators[e]=0;const a=n/t*1e3;let i=this._movingAverages[e];i||(i=this._movingAverages[e]={}),this._options.movingAverageIntervals.forEach(o=>{let c=i[o];c||(c=i[o]=fo(o)),c.push(r,a)})}_applyOp(e){const t=e[0],r=e[1];if(typeof r!="number")throw new Error(`invalid increment number: ${r}`);Object.prototype.hasOwnProperty.call(this._stats,t)||(this._stats[t]=BigInt(0)),this._stats[t]=BigInt(this._stats[t])+BigInt(r),this._frequencyAccumulators[t]||(this._frequencyAccumulators[t]=0),this._frequencyAccumulators[t]+=r}}const Kc={enabled:!1,computeThrottleTimeout:1e3,computeThrottleMaxQueueSize:1e3,movingAverageIntervals:[60*1e3,5*60*1e3,15*60*1e3]};class Wk extends Yr.EventEmitter{constructor(e,t=[],r=Kc){super();const n=Object.assign({},Kc,r);if(typeof n.computeThrottleTimeout!="number")throw new Error("need computeThrottleTimeout");if(typeof n.computeThrottleMaxQueueSize!="number")throw new Error("need computeThrottleMaxQueueSize");this._initialCounters=t,this._options=n,this._enabled=this._options.enabled,this._global=new qc(t,n),this._global.on("update",a=>this.emit("update",a)),this._peers=_n({name:"ipfs_bitswap_stats_peers",metrics:e.metrics})}enable(){this._enabled=!0,this._options.enabled=!0,this._global.enable()}disable(){this._enabled=!1,this._options.enabled=!1,this._global.disable()}stop(){this._enabled=!1,this._global.stop();for(const e of this._peers)e[1].stop()}get snapshot(){return this._global.snapshot}get movingAverages(){return this._global.movingAverages}forPeer(e){const t=typeof e!="string"&&e.toString?e.toString():`${e}`;return this._peers.get(t)}push(e,t,r){if(this._enabled&&(this._global.push(t,r),e)){let n=this._peers.get(e);n||(n=new qc(this._initialCounters,this._options),this._peers.set(e,n)),n.push(t,r)}}disconnected(e){const t=e.toString(),r=this._peers.get(t);r&&(r.stop(),this._peers.delete(t))}}const Jk={statsEnabled:!1,statsComputeThrottleTimeout:1e3,statsComputeThrottleMaxQueueSize:1e3},Gk=["blocksReceived","dataReceived","dupBlksReceived","dupDataReceived","blocksSent","dataSent","providesBufferLength","wantListLength","peerCount"];class Qk extends ml{constructor(e,t,r={}){super(),this._libp2p=e,this._log=ur(this.peerId),this._options=Object.assign({},Jk,r),this._stats=new Wk(e,Gk,{enabled:this._options.statsEnabled,computeThrottleTimeout:this._options.statsComputeThrottleTimeout,computeThrottleMaxQueueSize:this._options.statsComputeThrottleMaxQueueSize}),this.network=new Lk(e,this,this._stats,{hashLoader:r.hashLoader,maxInboundStreams:r.maxInboundStreams,maxOutboundStreams:r.maxOutboundStreams,incomingStreamTimeout:r.incomingStreamTimeout}),this.blockstore=t,this.engine=new Kk(this.peerId,t,this.network,this._stats,e),this.wm=new Ck(this.peerId,this.network,this._stats,e),this.notifications=new Vk(this.peerId),this.started=!1}isStarted(){return this.started}get peerId(){return this._libp2p.peerId}async _receiveMessage(e,t){try{await this.engine.messageReceived(e,t)}catch{this._log("failed to receive message",t)}if(t.blocks.size===0)return;const r=[];for(const[n,a]of t.blocks.entries()){const i=w.parse(n);r.push({wasWanted:this.wm.wantlist.contains(i),cid:i,data:a})}this.wm.cancelWants(r.filter(({wasWanted:n})=>n).map(({cid:n})=>n)),await Promise.all(r.map(({cid:n,wasWanted:a,data:i})=>this._handleReceivedBlock(e,n,i,a)))}async _handleReceivedBlock(e,t,r,n){this._log("received block");const a=await this.blockstore.has(t);this._updateReceiveCounters(e.toString(),t,r,a),n&&await this.put(t,r)}_updateReceiveCounters(e,t,r,n){this._stats.push(e,"blocksReceived",1),this._stats.push(e,"dataReceived",r.length),n&&(this._stats.push(e,"dupBlksReceived",1),this._stats.push(e,"dupDataReceived",r.length))}_receiveError(e){this._log.error("ReceiveError: %s",e.message)}_onPeerConnected(e){this.wm.connected(e)}_onPeerDisconnected(e){this.wm.disconnected(e),this.engine.peerDisconnected(e),this._stats.disconnected(e)}enableStats(){this._stats.enable()}disableStats(){this._stats.disable()}wantlistForPeer(e,t){return this.engine.wantlistForPeer(e)}ledgerForPeer(e){return this.engine.ledgerForPeer(e)}async get(e,t={}){const r=(c,l)=>(this.wm.wantBlocks([c],l),this.notifications.wantBlock(c,l));let n=!1;const a=async(c,l)=>{try{return await this.blockstore.get(c,l)}catch(u){if(u.code!=="ERR_NOT_FOUND")throw u;return n||(n=!0,this.network.findAndConnect(c,l).catch(d=>this._log.error(d))),r(c,l)}},i=new AbortController,o=t.signal?yn([t.signal,i.signal]):i.signal;try{return await Promise.race([this.notifications.wantBlock(e,{signal:o}),a(e,{signal:o})])}finally{i.abort()}}async*getMany(e,t={}){for await(const r of e)yield this.get(r,t)}unwant(e){const t=Array.isArray(e)?e:[e];this.wm.unwantBlocks(t),t.forEach(r=>this.notifications.unwantBlock(r))}cancelWants(e){this.wm.cancelWants(Array.isArray(e)?e:[e])}async put(e,t,r){await this.blockstore.put(e,t),this._sendHaveBlockNotifications(e,t)}async*putMany(e,t){for await(const{key:r,value:n}of this.blockstore.putMany(e,t))this._sendHaveBlockNotifications(r,n),yield{key:r,value:n}}_sendHaveBlockNotifications(e,t){this.notifications.hasBlock(e,t),this.engine.receivedBlocks([{cid:e,data:t}]),this.network.provide(e).catch(r=>{this._log.error("Failed to provide: %s",r.message)})}getWantlist(){return this.wm.wantlist.entries()}peers(){return this.engine.peers()}stat(){return this._stats}async start(){this.wm.start(),await this.network.start(),this.engine.start(),this.started=!0}async stop(){this._stats.stop(),this.wm.stop(),await this.network.stop(),this.engine.stop(),this.started=!1}unwrap(){return this.blockstore}has(e){return this.blockstore.has(e)}}const Xk=(s,e,t={})=>new Qk(s,e,t);class Yk extends ml{constructor(e,t){super(),this.child=e,this.bitswap=t}open(){return this.child.open()}close(){return this.child.close()}unwrap(){return this.child}async put(e,t,r={}){await this.has(e)||(this.bitswap.isStarted()?await this.bitswap.put(e,t,r):await this.child.put(e,t,r))}async*putMany(e,t={}){const r=gn(e,async({key:n})=>!await this.has(n));this.bitswap.isStarted()?yield*this.bitswap.putMany(r,t):yield*this.child.putMany(r,t)}async get(e,t={}){return!await this.has(e)&&this.bitswap.isStarted()?this.bitswap.get(e,t):this.child.get(e,t)}async*getMany(e,t={}){const r=Fs({objectMode:!0}),n=Fs({objectMode:!0});Promise.resolve().then(async()=>{for await(const a of e)!await this.has(a)&&this.bitswap.isStarted()?r.push(a):n.push(a);r.end(),n.end()}),yield*Ea(this.bitswap.getMany(r,t),this.child.getMany(n,t))}async delete(e,t){await this.child.delete(e,t)}async*deleteMany(e,t){yield*this.child.deleteMany(e,t)}async has(e,t={}){return this.child.has(e,t)}async*query(e,t={}){yield*this.child.query(e,t)}async*queryKeys(e,t={}){yield*this.child.queryKeys(e,t)}}class Xi{constructor(e,t,r,n,a){this.peerId=e,this.libp2p=t,this.bitswap=r,this.repo=n,this.blockstore=a}static async start({peerId:e,repo:t,print:r,hashers:n,options:a}){t.closed&&await t.open();const i=await t.config.getAll(),o=await mi({options:a,repo:t,peerId:e,multiaddrs:Zk(e,i),config:i,keychainConfig:void 0});await o.start();for(const u of o.getMultiaddrs())r(`Swarm listening on ${u.toString()}`);const c=Xk(o,t.blocks,{statsEnabled:!0,hashLoader:n,maxInboundStreams:1024,maxOutboundStreams:1024});await c.start();const l=new Yk(t.blocks,c);return t.blocks=l,t.pins.blockstore=l,new Xi(e,o,c,t,l)}static async stop(e){e.repo.blocks=e.blockstore.unwrap(),e.repo.pins.blockstore=e.blockstore.unwrap(),await e.bitswap.stop(),await e.libp2p.stop()}}const Zk=(s,e)=>{const t=s.toString(),r=[],n=e.Addresses&&e.Addresses.Swarm||[];for(const a of n){let i=ie(a);if(i.protoCodes().includes(e$))throw y(new Error("websocket-star swarm addresses are not supported. See https://github.com/ipfs/js-ipfs/issues/2779"),"ERR_WEBSOCKET_STAR_SWARM_ADDR_NOT_SUPPORTED");const o=i.getPeerId();o&&o!==t&&(i=i.encapsulate(`/p2p/${t}`)),r.push(i)}return r},e$=479;function t$({network:s}){async function e(t={}){const r=[],{libp2p:n}=await s.use(t);return await n.peerStore.forEach(a=>{r.push({id:a.id,addrs:a.addresses.map(i=>i.multiaddr)})}),r}return E(e)}function r$({network:s}){async function e(t,r={}){const{libp2p:n}=await s.use(r);await n.dial(t,r)}return E(e)}function s$({network:s}){async function e(t,r={}){const{libp2p:n}=await s.use(r);await n.hangUp(t)}return E(e)}function n$({network:s}){async function e(t={}){const{libp2p:r}=await s.use(t);return r.getMultiaddrs()}return E(e)}function a$({network:s}){async function e(t={}){const{libp2p:r}=await s.use(t);if(t.verbose){const a=[];for(const i of r.getConnections()){const o={addr:i.remoteAddr,peer:i.remotePeer};(t.verbose||t.direction)&&(o.direction=i.stat.direction),t.verbose&&(o.muxer=i.stat.multiplexer,o.latency="n/a",o.streams=[]),a.push(o)}return a}const n=new Map;for(const a of r.getConnections()){const i={addr:a.remoteAddr,peer:a.remotePeer};n.set(a.remotePeer.toString(),i)}return Array.from(n.values())}return E(e)}class i${constructor({network:e}){this.addrs=t$({network:e}),this.connect=r$({network:e}),this.disconnect=s$({network:e}),this.localAddrs=n$({network:e}),this.peers=a$({network:e})}}const kr={success:!0,time:0,text:""};function o$({network:s}){async function*e(t,r={}){const{libp2p:n}=await s.use();r.count=r.count||10;const a=await n.peerStore.get(t);let i=a&&a.id;if(!i){yield{...kr,text:`Looking up peer ${t}`};const l=await n.peerRouting.findPeer(t);i=l&&l.id}if(!i)throw new Error("Peer was not found");yield{...kr,text:`PING ${i.toString()}`};let o=0,c=0;for(let l=0;l<r.count;l++)try{const u=await n.ping(i);c+=u,o++,yield{...kr,time:u}}catch(u){yield{...kr,success:!1,text:u.toString()}}if(o){const l=c/o;yield{...kr,text:`Average latency: ${l}ms`}}}return E(e)}const pa="/ipns/";function Vc(s){s.startsWith(pa)&&(s=s.substring(pa.length));let e;if((s[0]==="1"||s[0]==="Q")&&(s=`z${s}`),s[0]==="z"&&(e=U.decode(s)),s[0]==="k"&&(e=Qs.decode(s)),!e)throw new Error("Could not parse string");if(e[0]!==1&&e[1]!==114&&(e=oe([[1,114],e])),e.length!==40)throw new Error("Incorrect length "+e.length);return oe([Q(pa),e.subarray(2)])}function c$({network:s,repo:e,peerId:t}){const{get:r,put:n,findProvs:a,findPeer:i,provide:o,query:c}={async*get(l,u={}){const{libp2p:d}=await zt(s,t,u),h=l instanceof Uint8Array?l:Vc(l);if(d.dht==null)throw y(new Error("dht not configured"),"ERR_DHT_NOT_CONFIGURED");yield*d.dht.get(h,u)},async*put(l,u,d){const{libp2p:h}=await zt(s,t,d),f=l instanceof Uint8Array?l:Vc(l);if(h.dht==null)throw y(new Error("dht not configured"),"ERR_DHT_NOT_CONFIGURED");yield*h.dht.put(f,u,d)},async*findProvs(l,u={}){const{libp2p:d}=await zt(s,t,u);if(d.dht==null)throw y(new Error("dht not configured"),"ERR_DHT_NOT_CONFIGURED");yield*d.dht.findProviders(l,{signal:u.signal})},async*findPeer(l,u={}){const{libp2p:d}=await zt(s,t,u);if(d.dht==null)throw y(new Error("dht not configured"),"ERR_DHT_NOT_CONFIGURED");yield*d.dht.findPeer(l,{signal:u.signal})},async*provide(l,u={recursive:!1}){const{libp2p:d}=await zt(s,t,u);if(!await e.blocks.has(l))throw y(new Error("block(s) not found locally, cannot provide"),"ERR_BLOCK_NOT_FOUND");if(u.recursive)throw y(new Error("not implemented yet"),"ERR_NOT_IMPLEMENTED_YET");if(d.dht==null)throw y(new Error("dht not configured"),"ERR_DHT_NOT_CONFIGURED");yield*d.dht.provide(l)},async*query(l,u={}){const{libp2p:d}=await zt(s,t,u);let h;const f=w.asCID(l);if(f!=null?h=f.multihash.bytes:h=pe(l.toString()).toBytes(),d.dht==null)throw y(new Error("dht not configured"),"ERR_DHT_NOT_CONFIGURED");yield*d.dht.getClosestPeers(h,u)}};return{get:E(r),put:E(n),findProvs:E(a),findPeer:E(i),provide:E(o),query:E(c)}}const zt=async(s,e,t)=>{const r=await s.use(t);if(r.libp2p.dht!=null)return r;{const n=async function*(){yield{from:e,name:"QUERY_ERROR",type:3,error:new ir("dht not enabled")}};return{libp2p:{dht:{get:n,put:n,findProviders:n,findPeer:n,provide:n,getClosestPeers:n}}}}};function l$({network:s,config:e}){const t=Tr(e||{},"Pubsub.Enabled",!0),r={};let n;return{subscribe:t?E(a):$r,unsubscribe:t?E(i):$r,publish:t?E(o):$r,ls:t?E(c):$r,peers:t?E(l):$r};async function a(u,d,h={}){const{libp2p:f}=await s.use(h);f.pubsub.subscribe(u),n==null&&(n=p=>{const g=p.detail;r[g.topic]&&r[g.topic].forEach(_=>{if(typeof _=="function"){_(g);return}_!=null&&_.handleEvent!=null&&_.handleEvent(g)})},f.pubsub.addEventListener("message",n)),d!=null&&(r[u]==null&&(r[u]=[]),r[u].push(d))}async function i(u,d,h={}){const{libp2p:f}=await s.use(h);d!=null&&r[u]!=null&&(r[u]=r[u].filter(p=>p!==d),r[u].length===0&&delete r[u]),typeof d!="function"&&delete r[u],r[u]==null&&f.pubsub.unsubscribe(u),Object.keys(r).length===0&&(f.pubsub.removeEventListener("message",n),n=void 0)}async function o(u,d,h={}){const{libp2p:f}=await s.use(h);if(!d)throw y(new Error('argument "data" is required'),"ERR_ARG_REQUIRED");await f.pubsub.publish(u,d)}async function c(u={}){const{libp2p:d}=await s.use(u);return d.pubsub.getTopics()}async function l(u,d={}){const{libp2p:h}=await s.use(d);return h.pubsub.getSubscribers(u)}}const $r=async()=>{throw new ir("pubsub not enabled")},u$=_e.bind({ignoreUndefined:!0}),ht=M("ipfs"),d$=3e4;class h${constructor({print:e,storage:t,codecs:r,options:n}){const{peerId:a,repo:i,keychain:o}=t,c=He.create(Xi),l=wm(n.preload),u=xw(),d=Lw({network:c}),h=new sg(n),f=Object.values(Ll);(n.ipld&&n.ipld.hashers?n.ipld.hashers:[]).forEach(ue=>f.push(ue)),this.hashers=new Dd({hashers:f,loadHasher:n.ipld&&n.ipld.loadHasher});const p=Object.values(Sn);(n.ipld&&n.ipld.bases?n.ipld.bases:[]).forEach(ue=>p.push(ue)),this.bases=new Ed({bases:p,loadBase:n.ipld&&n.ipld.loadBase});const g=new Vw({repo:i,codecs:r}),_=new Bg({codecs:r,hashers:this.hashers,preload:l,repo:i}),v=new fg({dns:u,ipns:h,repo:i,codecs:r,peerId:a,isOnline:d,keychain:o,options:n}),k=Bw({repo:i,codecs:r,bases:this.bases,name:v}),P=new lm({repo:i,codecs:r,hashers:this.hashers,preload:l}),T=Object.assign(yg({repo:i,codecs:r,resolve:k,preload:l}),{local:Eg({repo:t.repo})}),{add:I,addAll:x,cat:C,get:S,ls:L}=new Mb({preload:l,repo:i,options:n.EXPERIMENTAL,hashers:this.hashers}),Ie=k_({repo:i,preload:l,hashers:this.hashers,options:n}),tt=gm({files:Ie,preload:l,options:n.preload});this.preload=l,this.name=v,this.ipns=h,this.pin=g,this.resolve=k,this.block=_,this.refs=T,this.start=Yy({network:c,peerId:a,repo:i,preload:l,ipns:h,mfsPreload:tt,print:e,keychain:o,hashers:this.hashers,options:n}),this.stop=Zy({network:c,preload:l,mfsPreload:tt,ipns:h,repo:i}),this.dht=c$({network:c,repo:i,peerId:a}),this.pubsub=l$({network:c,config:n.config}),this.dns=u,this.isOnline=d,this.id=qb({network:c,peerId:a}),this.version=Fb({repo:i}),this.bitswap=new kg({network:c}),this.bootstrap=new Og({repo:i}),this.config=Jb({repo:i}),this.ping=o$({network:c}),this.add=I,this.addAll=x,this.cat=C,this.get=S,this.ls=L,this.dag=P,this.files=Ie,this.key=new I_({keychain:o}),this.object=new H_({preload:l,codecs:r,repo:i}),this.repo=new W_({repo:i,hashers:this.hashers}),this.stats=new G_({repo:i,network:c}),this.swarm=new i$({network:c}),Object.defineProperty(this,"libp2p",{get(){const ue=c.try();return ue?ue.libp2p:void 0}});const Ne=()=>Promise.reject(y(new Error("Not implemented"),"ERR_NOT_IMPLEMENTED")),H=async function*(){throw y(new Error("Not implemented"),"ERR_NOT_IMPLEMENTED")};this.commands=Ne,this.diag={cmds:Ne,net:Ne,sys:Ne},this.log={level:Ne,ls:Ne,tail:H},this.mount=Ne,this.codecs=r}async init(){throw new Tt}}const f$=async s=>{const e=J({Data:new G({type:"directory"}).marshal(),Links:[]}),t=await s.block.put(e,{mhtype:"sha2-256",format:"dag-pb"});return await s.pin.add(t),t},p$=()=>({start:!0,EXPERIMENTAL:{},preload:{enabled:!ot.isTest,addresses:["/dns4/node0.preload.ipfs.io/https","/dns4/node1.preload.ipfs.io/https","/dns4/node2.preload.ipfs.io/https","/dns4/node3.preload.ipfs.io/https"]}});async function y$(s={}){s=u$(p$(),s);const e=s.init||{},t={name:Rt.name,code:Rt.code,encode:l=>l,decode:l=>l},r=Object.values(Bl);[Xe,Mr,gl,bl,t].concat(s.ipld&&s.ipld.codecs||[]).forEach(l=>r.push(l));const n=new vd({codecs:r,loadCodec:s.ipld&&s.ipld.loadCodec}),a=s.silent?ht:console.log;ht("creating repo");const i=await Qi.start(a,n,s);ht("getting repo config");const o=await i.repo.config.getAll(),c=new h$({storage:i,print:a,codecs:n,options:{...s,config:o}});if(ht("starting preload"),await c.preload.start(),ht("starting storage"),c.ipns.startOffline(i),i.isNew&&!e.emptyRepo){const l=await f$(c);if(ht("adding default assets"),await(c.addAll,void 0),ht("initializing IPNS keyspace"),i.peerId.publicKey==null)throw y(new Error("Public key missing"),"ERR_MISSING_PUBLIC_KEY");const u=new Jr.TimeoutController(d$);try{await c.ipns.initializeKeyspace(i.peerId,Q(`/ipfs/${l}`),{signal:u.signal})}finally{u.clear()}}return s.start!==!1&&(ht("starting node"),await c.start()),c}const w$=y$,dR=w$;class g${constructor(e){this.id=e,this._index=[]}get(){return this._index}async updateIndex(e,t){this._index=e.values}}class b${constructor(e){}append(e){}merge(e){}get(e){}has(e){}get values(){}get length(){}}class ze{constructor(e,t){this.id=e,this.time=t||0}tick(){return new ze(this.id,++this.time)}merge(e){return this.time=Math.max(this.time,e.time),new ze(this.id,this.time)}clone(){return new ze(this.id,this.time)}static compare(e,t){const r=e.time-t.time;return r===0&&e.id!==t.id?e.id<t.id?-1:1:r}}const m$="sha2-256",Jd=U,Gd=()=>new Error("unsupported codec"),Yi=s=>s&&(Array.isArray(s)?s.map(Yi):w.parse(s)),ii=(s,e={})=>{if(!s||typeof s=="string")return s;if(Array.isArray(s))return s.map(ii);const t=e.base||Jd;return s.toString(t)},_$={[V]:Xe,[Xr]:Mr},E$={raw:Mr,"dag-pb":Xe,"dag-cbor":Mr};async function dr(s,e,t={}){e=Yi(ii(e));const r=_$[e.code];if(!r)throw Gd();const n=await s.block.get(e,{timeout:t.timeout}),a=await em({bytes:n,codec:r,hasher:me});if(a.cid.code===V)return JSON.parse(new TextDecoder().decode(a.value.Data));if(a.cid.code===Xr){const i=a.value;return(t.links||[]).forEach(c=>{i[c]&&(i[c]=ii(i[c],t))}),i}}async function Lt(s,e,t,r={}){r.format==="dag-pb"&&(e=r.format);const n=E$[e];if(!n)throw Gd();n.code===V&&(t=typeof t=="string"?t:JSON.stringify(t),t={Data:new TextEncoder().encode(t),Links:[]}),n.code===Xr&&(r.links||[]).forEach(c=>{t[c]&&(t[c]=Yi(t[c]))});const a=await Zb({value:t,codec:n,hasher:me});return await s.block.put(a.bytes,{cid:a.cid.bytes,version:a.cid.version,format:e,mhtype:m$,pin:r.pin,timeout:r.timeout}),(n.code===V?a.cid.toV0():a.cid).toString(r.base||Jd)}function v$(s,e,t){const r={},n={},a=o=>n[t?o[t]:o]=!0;s.forEach(a);const i=(o,c)=>{const l=n[t?c[t]:c]!==void 0,u=r[t?c[t]:c]!==void 0;return!l&&!u&&(o.push(c),r[t?c[t]:c]=!0),o};return e.reduce(i,[])}function oi(s,e){const t={},r=a=>t[a],n=a=>t[e?a[e]:a]=a;return s.forEach(n),Object.keys(t).map(r)}const W=s=>s!=null,ya=()=>new Error("Ipfs instance not defined"),ci=["next","refs"],Wc=s=>s===0?"dag-pb":"dag-cbor",Qd=s=>de.isEntry(s)?Wc(s.v):Wc(s);class de{static async create(e,t,r,n,a=[],i,o=[],c){if(!W(e))throw ya();if(!W(t))throw new Error("Identity is required, cannot create entry");if(!W(r))throw new Error("Entry requires an id");if(!W(n))throw new Error("Entry requires data");if(!W(a)||!Array.isArray(a))throw new Error("'next' argument is not an array");const l=f=>f.hash?f.hash:f,u=a.filter(W).map(l),d={hash:null,id:r,payload:n,next:u,refs:o,v:2,clock:i||new ze(t.publicKey)},h=await t.provider.sign(t,de.toBuffer(d));return d.key=t.publicKey,d.identity=t.toJSON(),d.sig=h,d.hash=await de.toMultihash(e,d,c),d}static async verify(e,t){if(!e)throw new Error("Identity-provider is required, cannot verify entry");if(!de.isEntry(t))throw new Error("Invalid Log entry");if(!t.key)throw new Error("Entry doesn't have a key");if(!t.sig)throw new Error("Entry doesn't have a signature");const r=de.toEntry(t,{presigned:!0}),n=t.v<1?"v0":"v1";return e.verify(t.sig,t.key,de.toBuffer(r),n)}static toBuffer(e){const t=e.v===0?JSON.stringify(e):Vh(e);return zr.Buffer.from(t)}static async toMultihash(e,t,r=!1){if(!e)throw ya();if(!de.isEntry(t))throw new Error("Invalid object format, cannot generate entry hash");const n=de.toEntry(t);return Lt(e,Qd(n.v),n,{links:ci,pin:r})}static toEntry(e,{presigned:t=!1,includeHash:r=!1}={}){const n={hash:r?e.hash:null,id:e.id,payload:e.payload,next:e.next},a=e.v;return a>1&&(n.refs=e.refs),n.v=e.v,n.clock=new ze(e.clock.id,e.clock.time),t||(n.key=e.key,a>0&&(n.identity=e.identity),n.sig=e.sig),n}static async fromMultihash(e,t){if(!e)throw ya();if(!t)throw new Error(`Invalid hash: ${t}`);const r=await dr(e,t,{links:ci}),n=de.toEntry(r);return n.hash=t,n}static isEntry(e){return e&&e.id!==void 0&&e.next!==void 0&&e.payload!==void 0&&e.v!==void 0&&e.hash!==void 0&&e.clock!==void 0&&(e.refs!==void 0||e.v<2)}static compare(e,t){const r=ze.compare(e.clock,t.clock);return r===0?e.clock.id<t.clock.id?-1:1:r}static isEqual(e,t){return e.hash===t.hash}static isParent(e,t){return t.next.indexOf(e.hash)>-1}static findChildren(e,t){let r=[],n=t.find(i=>de.isParent(e,i)),a=e;for(;n;)r.push(n),a=n,n=t.find(i=>de.isParent(a,i));return r=r.sort((i,o)=>i.clock.time>o.clock.time),r}}const{isEntry:D$,fromMultihash:S$}=de,k$=s=>s&&s.length>0;class Zi{static async fetchParallel(e,t,{length:r,exclude:n=[],shouldExclude:a,timeout:i,concurrency:o,onProgressCallback:c}){const l=async f=>Zi.fetchAll(e,f,{length:r,exclude:n,shouldExclude:a,timeout:i,onProgressCallback:c,concurrency:o}),u=(f,p)=>f.concat(p),d=f=>f.reduce(u,[]),h=await va(t,l,{concurrency:Math.max(o||t.length,1)});return d(h)}static async fetchAll(e,t,{length:r=-1,exclude:n=[],shouldExclude:a,timeout:i,onProgressCallback:o,onStartProgressCallback:c,concurrency:l=32,delay:u=0}={}){const d=[],h={},f={},p=Array.isArray(t)?{0:t.slice()}:{0:[t]};let g=0,_=0,v=0;a=a||(()=>!1);const k=()=>Object.values(p).find(k$)!==void 0,P=(S,L)=>{!f[S]&&!a(S)&&(p[L]||(p[L]=[]),p[L].includes(S)||p[L].push(S),f[S]=!0)},T=(S=1)=>{const L=(Ie,tt,Ne)=>{const H=p[tt];for(;H.length>0&&Ie.length<S;){const ue=H.shift();Ie.push(ue)}return H.length===0&&delete p[tt],Ie};return Object.keys(p).reduce(L,[])},I=S=>{h[S.hash||S]=!0},x=async S=>{if(!(!S||h[S]||a(S)))return new Promise(async(L,Ie)=>{const tt=i&&i>0?setTimeout(()=>{console.warn(`Warning: Couldn't fetch entry '${S}', request timed out (${i}ms)`),L()},i):null,Ne=H=>{if(D$(H)&&!h[H.hash]&&!a(H.hash)){const ue=H.clock.time;_=Math.max(_,ue),v=d.length>0?Math.min(d[d.length-1].clock.time,v):_;const Bt=d.length>=r&&ue>=v,vt=ut=>_-ue+(ut+1)*ut;(r<0||d.length<r||Bt)&&!a(H.hash)&&!h[H.hash]&&(d.push(H),h[H.hash]=!0,o&&o(H)),r<0?(H.next.forEach(P),H.refs&&H.refs.forEach(P)):((d.length<r||ue>v||ue===v&&!h[H.hash]&&!a(H.hash))&&H.next.forEach(ut=>P(ut,vt(0))),H.refs&&d.length+H.refs.length<=r&&H.refs.forEach((ut,lh)=>P(ut,vt(lh))))}};c&&c(S,null,0,d.length);try{const H=await S$(e,S);u>0&&await((Bt=0)=>new Promise(vt=>setTimeout(vt,Bt)))(u),Ne(H),L()}catch(H){Ie(H)}finally{clearTimeout(tt)}})},C=async()=>{if(g<l){const S=T(l);g+=S.length,await va(S,x,{concurrency:l}),g-=S.length}};return n.forEach(I),await Wh(C,k),d}}function $$(s,e){const t=(a,i)=>a,r=(a,i)=>to(a,i,t);return((a,i)=>eo(a,i,r))(s,e)}function P$(s,e){const t=(a,i)=>a.hash<i.hash?-1:1,r=(a,i)=>to(a,i,t);return((a,i)=>eo(a,i,r))(s,e)}function eo(s,e,t){const r=ze.compare(s.clock,e.clock);return r===0?t(s,e):r}function to(s,e,t){return s.clock.id===e.clock.id?t(s,e):s.clock.id<e.clock.id?-1:1}function A$(s){const e=`Your log's tiebreaker function, ${s.name}, has returned zero and therefore cannot be`;return(r,n)=>{const a=s(r,n);if(a===0)throw Error(e);return a}}const Xd={SortByClocks:eo,SortByClockId:to,LastWriteWins:$$,SortByEntryHash:P$,NoZeroes:A$},qt=()=>new Error("IPFS instance not defined"),Yd=()=>new Error("Log instance not defined"),Zd=()=>new Error("Given argument is not an instance of Log"),Jc=()=>new Error("lt or lte must be a string or array of Entries"),{LastWriteWins:Gc,NoZeroes:Qc}=Xd,{fetchAll:R$,fetchParallel:wa}=Zi,{compare:Xc,isEntry:T$}=de,Yc=["heads"],Zc=(s,e)=>s.slice(s.length-Math.min(s.length,e),s.length);class Pr{static async toMultihash(e,t,{format:r}={}){if(!W(e))throw qt();if(!W(t))throw Yd();if(W(r)||(r="dag-cbor"),t.values.length<1)throw new Error("Can't serialize an empty log");return Lt(e,r,t.toJSON(),{links:Yc})}static async fromMultihash(e,t,{length:r=-1,exclude:n=[],shouldExclude:a,timeout:i,concurrency:o,sortFn:c,onProgressCallback:l}){if(!W(e))throw qt();if(!W(t))throw new Error(`Invalid hash: ${t}`);const u=await dr(e,t,{links:Yc});if(!u.heads||!u.id)throw Zd();c=c||Qc(Gc);const d=_=>u.heads.includes(_.hash),h=await R$(e,u.heads,{length:r,exclude:n,shouldExclude:a,timeout:i,concurrency:o,onProgressCallback:l}),f=u.id,p=r>-1?Zc(h.sort(c),r):h,g=p.filter(d);return{logId:f,entries:p,heads:g}}static async fromEntryHash(e,t,{length:r=-1,exclude:n=[],shouldExclude:a,timeout:i,concurrency:o,sortFn:c,onProgressCallback:l}){if(!W(e))throw qt();if(!W(t))throw new Error("'hash' must be defined");const u=Array.isArray(t)?t:[t];r=r>-1?Math.max(r,1):r;const d=await wa(e,u,{length:r,exclude:n,shouldExclude:a,timeout:i,concurrency:o,onProgressCallback:l});return c=c||Qc(Gc),{entries:r>-1?Zc(d.sort(c),r):d}}static async fromJSON(e,t,{length:r=-1,timeout:n,concurrency:a,onProgressCallback:i}){if(!W(e))throw qt();const{id:o,heads:c}=t,l=c.map(h=>h.hash),d=(await wa(e,l,{length:r,timeout:n,concurrency:a,onProgressCallback:i})).sort(Xc);return{logId:o,entries:d,heads:c}}static async fromEntry(e,t,{length:r=-1,exclude:n=[],shouldExclude:a,timeout:i,concurrency:o,onProgressCallback:c}){if(!W(e))throw qt();if(!W(t))throw new Error("'sourceEntries' must be defined");if(!Array.isArray(t)&&!T$(t))throw new Error("'sourceEntries' argument must be an array of Entry instances or a single Entry");Array.isArray(t)||(t=[t]),r=r>-1?Math.max(r,t.length):r;const l=t.map(k=>k.hash),u=await wa(e,l,{length:r,exclude:n,shouldExclude:a,timeout:i,concurrency:o,onProgressCallback:c}),d=t.concat(u).concat(n),h=oi(d,"hash").sort(Xc),f=h.slice(r>-1?-r:-h.length),p=v$(f,t,"hash"),_=((k,P)=>{const T=k.slice(P.length,k.length);return P.concat(T)})(f,p);return{logId:_[_.length-1].id,entries:_}}}let O$=class{async canAppend(e,t){return!0}};class el{constructor(e={}){this._cache=e}set(e,t){this._cache[e]=t}get(e){return this._cache[e]}delete(e){return delete this._cache[e]}add(e){this._cache=Object.assign(this._cache,e)}get length(){return Object.values(this._cache).length}}const{LastWriteWins:C$,NoZeroes:I$}=Xd,N$=()=>new Date().getTime().toString(),tl=s=>s.hash,x$=(s,e)=>s.concat(e),L$=s=>s.next,Ts=(s,e)=>Math.max(s,e.clock.time),Ut=(s,e)=>(s[e.hash]=e,s);class ge extends b${constructor(e,t,{logId:r,access:n,entries:a,heads:i,clock:o,sortFn:c,concurrency:l}={}){if(!W(e))throw qt();if(!W(t))throw new Error("Identity is required");if(W(n)||(n=new O$),W(a)&&!Array.isArray(a))throw new Error("'entries' argument must be an array of Entry instances");if(W(i)&&!Array.isArray(i))throw new Error("'heads' argument must be an array");W(c)||(c=C$),super(),this._sortFn=I$(c),this._storage=e,this._id=r||N$(),this._access=n,this._identity=t;const u=(a||[]).reduce(Ut,{});this._entryIndex=new el(u),a=Object.values(u)||[],i=i||ge.findHeads(a),this._headsIndex=i.reduce(Ut,{}),this._nextsIndex={};const d=f=>f.next.forEach(p=>this._nextsIndex[p]=f.hash);a.forEach(d),this._length=a.length;const h=Math.max(o?o.time:0,this.heads.reduce(Ts,0));this._clock=new ze(this._identity.publicKey,h),this.joinConcurrency=l||16}get id(){return this._id}get clock(){return this._clock}get length(){return this._length}get values(){return Object.values(this.traverse(this.heads)).reverse()}get heads(){return Object.values(this._headsIndex).sort(this._sortFn).reverse()}get tails(){return ge.findTails(this.values)}get tailHashes(){return ge.findTailHashes(this.values)}setIdentity(e){this._identity=e;const t=Math.max(this.clock.time,this.heads.reduce(Ts,0));this._clock=new ze(this._identity.publicKey,t)}get(e){return this._entryIndex.get(e)}has(e){return this._entryIndex.get(e.hash||e)!==void 0}traverse(e,t=-1,r){let n=e.sort(this._sortFn).reverse(),a={};const i={};let o=0;const c=d=>this.get(d),l=d=>{!d||a[d.hash]||(n=[d,...n].sort(this._sortFn).reverse(),a[d.hash]=!0)},u=d=>{i[d.hash]=d,a[d.hash]=!0,o++};for(;n.length>0&&(o<t||t<0);){const d=n.shift();if(u(d),r&&r===d.hash)break;d.next.map(c).filter(W).forEach(l)}return n=[],a={},i}async append(e,t=1,r=!1){const n=Math.max(this.clock.time,this.heads.reduce(Ts,0))+1;this._clock=new ze(this.clock.id,n);const a=Object.values(this.traverse(this.heads,Math.max(t,this.heads.length))),o=(f=>{const p=new Set;for(let g=1;g<=f;g*=2){const _=Math.min(g-1,a.length-1);p.add(a[_])}return p})(Math.min(t,a.length));a.length<t&&a[a.length-1]&&o.add(a[a.length-1]);const c=Object.keys(this.heads.reverse().reduce(Ut,{})),l=f=>!c.includes(f),u=Array.from(o).map(tl).filter(l),d=await de.create(this._storage,this._identity,this.id,e,c,this.clock,u,r);if(!await this._access.canAppend(d,this._identity.provider))throw new Error(`Could not append entry, key "${this._identity.id}" is not allowed to write to the log`);return this._entryIndex.set(d.hash,d),c.forEach(f=>this._nextsIndex[f]=d.hash),this._headsIndex={},this._headsIndex[d.hash]=d,this._length++,d}iterator({gt:e=void 0,gte:t=void 0,lt:r=void 0,lte:n=void 0,amount:a=-1}={}){if(a===0)return function*(){}();if(typeof n=="string"&&(n=[this.get(n)]),typeof r=="string"&&(r=[this.get(this.get(r).next[0])]),n&&!Array.isArray(n)||r&&!Array.isArray(r))throw Jc();const i=(n||r||this.heads).filter(W),o=t?this.get(t).hash:e?this.get(e).hash:null,c=o?-1:a||-1,l=this.traverse(i,c,o);let u=Object.values(l);return e&&u.pop(),(e||t)&&a>-1&&(u=u.slice(u.length-a,u.length)),function*(){for(const d in u)yield u[d]}()}async join(e,t=-1){if(!W(e))throw Yd();if(!ge.isLog(e))throw Zd();if(this.id!==e.id)return;const r=ge.difference(e,this),n=this._identity.provider,a=async p=>{if(!await this._access.canAppend(p,n))throw new Error(`Could not append entry, key "${p.identity.id}" is not allowed to write to the log`)},i=async p=>{const g=await de.verify(n,p),_=p.identity?p.identity.publicKey:p.key;if(!g)throw new Error(`Could not validate signature "${p.sig}" for entry "${p.hash}" and key "${_}"`)},o=Object.values(r);await va(o,async p=>{await a(p),await i(p)},{concurrency:this.joinConcurrency});const c=p=>{this.get(p.hash)||this._length++,p.next.forEach(_=>this._nextsIndex[_]=p.hash)};Object.values(r).forEach(c),this._entryIndex.add(r);const l=p=>!d.find(g=>g===p.hash),u=p=>!this._nextsIndex[p.hash],d=Object.values(r).map(L$).reduce(x$,[]),h=ge.findHeads(Object.values(Object.assign({},this._headsIndex,e._headsIndex))).filter(l).filter(u).reduce(Ut,{});if(this._headsIndex=h,t>-1){let p=this.values;p=p.slice(-t),this._entryIndex=null,this._entryIndex=new el(p.reduce(Ut,{})),this._headsIndex=ge.findHeads(p).reduce(Ut,{}),this._length=this._entryIndex.length}const f=Object.values(this._headsIndex).reduce(Ts,0);return this._clock=new ze(this.clock.id,Math.max(this.clock.time,f)),this}toJSON(){return{id:this.id,heads:this.heads.sort(this._sortFn).reverse().map(tl)}}toSnapshot(){return{id:this.id,heads:this.heads,values:this.values}}toBuffer(){return zr.Buffer.from(JSON.stringify(this.toJSON()))}toString(e){return this.values.slice().reverse().map((t,r)=>{const a=de.findChildren(t,this.values).length;let i=new Array(Math.max(a-1,0));return i=a>1?i.fill("  "):i,i=a>0?i.concat(["└─"]):i,i.join("")+(e?e(t.payload):t.payload)}).join(`
`)}static isLog(e){return e.id!==void 0&&e.heads!==void 0&&e._entryIndex!==void 0}toMultihash({format:e}={}){return Pr.toMultihash(this._storage,this,{format:e})}static async fromMultihash(e,t,r,{access:n,length:a=-1,exclude:i=[],shouldExclude:o,timeout:c,concurrency:l,sortFn:u,onProgressCallback:d}={}){const{logId:h,entries:f,heads:p}=await Pr.fromMultihash(e,r,{length:a,exclude:i,shouldExclude:o,timeout:c,onProgressCallback:d,concurrency:l,sortFn:u});return new ge(e,t,{logId:h,access:n,entries:f,heads:p,sortFn:u})}static async fromEntryHash(e,t,r,{logId:n,access:a,length:i=-1,exclude:o=[],shouldExclude:c,timeout:l,concurrency:u,sortFn:d,onProgressCallback:h}={}){const{entries:f}=await Pr.fromEntryHash(e,r,{length:i,exclude:o,shouldExclude:c,timeout:l,concurrency:u,onProgressCallback:h});return new ge(e,t,{logId:n,access:a,entries:f,sortFn:d})}static async fromJSON(e,t,r,{access:n,length:a=-1,timeout:i,sortFn:o,onProgressCallback:c}={}){const{logId:l,entries:u}=await Pr.fromJSON(e,r,{length:a,timeout:i,onProgressCallback:c});return new ge(e,t,{logId:l,access:n,entries:u,sortFn:o})}static async fromEntry(e,t,r,{access:n,length:a=-1,exclude:i=[],timeout:o,concurrency:c,sortFn:l,onProgressCallback:u}={}){const{logId:d,entries:h}=await Pr.fromEntry(e,r,{length:a,exclude:i,timeout:o,concurrency:c,onProgressCallback:u});return new ge(e,t,{logId:d,access:n,entries:h,sortFn:l})}static findHeads(e){const t=(i,o,c,l)=>{const u=d=>i[d]=o.hash;return o.next.forEach(u),i},r=e.reduce(t,{}),n=i=>r[i.hash]===void 0,a=(i,o)=>i.clock.id>o.clock.id;return e.filter(n).sort(a)}static findTails(e){const t={},r=[],n={};let a=[];const i=d=>{d.next.length===0&&r.push(d);const h=f=>{t[f]||(t[f]=[]),t[f].push(d)};d.next.forEach(h),a=a.concat(d.next),n[d.hash]=!0};e.forEach(i);const o=(d,h,f,p)=>d.concat(oi(h,"hash")),c=d=>n[d]===void 0,l=d=>t[d],u=a.filter(c).map(l).reduce(o,[]).concat(r);return oi(u,"hash").sort(de.compare)}static findTailHashes(e){const t={},r=a=>t[a.hash]=!0,n=(a,i,o,c)=>{const l=u=>{t[u]===void 0&&a.splice(0,0,u)};return i.next.reverse().forEach(l),a};return e.forEach(r),e.reduce(n,[])}static difference(e,t){const r=Object.keys(e._headsIndex),n={},a={},i=o=>{!n[o]&&!t.get(o)&&(r.push(o),n[o]=!0)};for(;r.length>0;){const o=r.shift(),c=e.get(o);c&&!t.get(o)&&c.id===t.id&&(a[c.hash]=c,n[c.hash]=!0,c.next.concat(c.refs).forEach(i))}return a}}const B$=s=>[...new Set([...s.next,...s.refs])],j$=(s,e)=>s.concat(e),M$=32;class z${constructor(e,t){this._store=e,this._concurrency=t||M$,this._q=new Ue({concurrency:this._concurrency}),this._logs=[],this._fetching={},this._fetched={},this._q.on("idle",async()=>{const r=this._logs.slice();if(this._logs=[],this.onReplicationComplete&&r.length>0&&this._store._oplog)try{await this.onReplicationComplete(r),r.forEach(n=>n.values.forEach(a=>delete this._fetched[a.hash]))}catch(n){console.error(n)}})}get tasksRunning(){return this._q.pending}get tasksQueued(){return this._q.size}get unfinished(){return Object.keys(this._fetching)}async load(e){try{this._addToQueue(e)}catch(t){console.error(t)}}async _addToQueue(e){const t=n=>n&&this._store._oplog&&(this._store._oplog.has(n)||this._fetching[n]!==void 0||this._fetched[n]),r=n=>(this._fetching[n.hash||n]=!0,async()=>{n.hash&&this.onReplicationQueued&&this.onReplicationQueued(n);try{const a=await this._replicateLog(n);this._logs.push(a)}catch(a){throw console.error(a),a}delete this._fetching[n.hash||n]});if(e.length>0){const n=e.filter(a=>!t(a.hash||a)).map(a=>r(a));n.length>0&&this._q.addAll(n)}}async stop(){this._q.pause(),this._q.clear(),await this._q.onIdle(),this._logs=[],this._fetching={},this._fetched={}}async _replicateLog(e){const t=e.hash||e,r=o=>{this._fetched[o.hash]=!0,this.onReplicationProgress&&this.onReplicationProgress(o)},n=o=>o&&o!==t&&this._store._oplog&&(this._store._oplog.has(o)||this._fetching[o]!==void 0||this._fetched[o]!==void 0),a=await ge.fromEntryHash(this._store._ipfs,this._store.identity,t,{logId:this._store.id,access:this._store.access,length:-1,exclude:[],shouldExclude:n,concurrency:this._concurrency,onProgressCallback:r}),i=a.values.map(B$).reduce(j$,[]);try{this._addToQueue(i)}catch(o){throw console.error(o),o}return a}}class U${constructor(){this.progress=0,this.max=0}reset(){this.progress=0,this.max=0}}const ga=Ye.create("orbit-db.store",{color:Ye.Colors.Blue});Ye.setLogLevel("ERROR");const F$={Index:g$,maxHistory:-1,fetchEntryTimeout:null,referenceCount:32,replicationConcurrency:32,syncLocal:!1,sortFn:void 0};class H${constructor(e,t,r,n){if(!t)throw new Error("Identity required");const a=Object.assign({},F$);Object.assign(a,n),this.options=a,this._type="store",this.id=r.toString(),this.identity=t,this.address=r,this.dbname=r.path||"",this.events=new Yr.EventEmitter,this.remoteHeadsPath=ye.join(this.id,"_remoteHeads"),this.localHeadsPath=ye.join(this.id,"_localHeads"),this.snapshotPath=ye.join(this.id,"snapshot"),this.queuePath=ye.join(this.id,"queue"),this.manifestPath=ye.join(this.id,"_manifest"),this._ipfs=e,this._cache=n.cache;const i={canAppend:o=>o.identity.publicKey===t.publicKey};this.access=n.accessController||i,this._oplog=new ge(this._ipfs,this.identity,{logId:this.id,access:this.access,sortFn:this.options.sortFn}),this._queue=new Ue({concurrency:1}),this._index=new this.options.Index(this.address.root),this._replicationStatus=new U$,this._stats={snapshot:{bytesLoaded:-1},syncRequestsReceieved:0};try{const o=async u=>{this._recalculateReplicationMax(u.clock?u.clock.time:0),this.events.emit("replicate",this.address.toString(),u)},c=async u=>{const d=this.replicationStatus.progress,h=this.replicationStatus.max;this._recalculateReplicationStatus(u.clock.time),(this._oplog.length+1>this.replicationStatus.progress||this.replicationStatus.progress>d||this.replicationStatus.max>h)&&this.events.emit("replicate.progress",this.address.toString(),u.hash,u,this.replicationStatus.progress,this.replicationStatus.max)},l=async u=>{const d=async()=>{try{if(this._oplog&&u.length>0){for(const f of u)await this._oplog.join(f);const h=this._oplog.heads;await this._cache.set(this.remoteHeadsPath,h),ga.debug(`Saved heads ${h.length} [${h.map(f=>f.hash).join(", ")}]`),await this._updateIndex(),this._oplog.length>this.replicationStatus.progress&&this._recalculateReplicationStatus(this._oplog.length),this.events.emit("replicated",this.address.toString(),u.length,this)}}catch(h){console.error(h)}};await this._queue.add(d.bind(this))};this._replicator=new z$(this,this.options.replicationConcurrency),this._loader=this._replicator,this._replicator.onReplicationQueued=o,this._replicator.onReplicationProgress=c,this._replicator.onReplicationComplete=l}catch(o){console.error("Store Error:",o)}this.events.on("replicated.progress",(o,c,l,u,d)=>{this._procEntry(l)}),this.events.on("write",(o,c,l)=>{this._procEntry(c)})}get all(){return Array.isArray(this._index._index)?this._index._index:Object.keys(this._index._index).map(e=>this._index._index[e])}get index(){return this._index._index}get type(){return this._type}get key(){return this._key}get replicationStatus(){return this._replicationStatus}setIdentity(e){this.identity=e,this._oplog.setIdentity(e)}async close(){await this._replicator.stop(),await this._queue.onIdle(),this._replicationStatus.reset(),this._stats={snapshot:{bytesLoaded:-1},syncRequestsReceieved:0},this.options.onClose&&await this.options.onClose(this),this.access.close&&await this.access.close();for(const e in this.events._events)this.events.removeAllListeners(e);return this._oplog=null,this.events.emit("closed",this.address.toString()),Promise.resolve()}async drop(){this.options.onDrop&&await this.options.onDrop(this),await this._cache.del(this.localHeadsPath),await this._cache.del(this.remoteHeadsPath),await this._cache.del(this.snapshotPath),await this._cache.del(this.queuePath),await this._cache.del(this.manifestPath),await this.close(),this._index=new this.options.Index(this.address.root),this._oplog=new ge(this._ipfs,this.identity,{logId:this.id,access:this.access,sortFn:this.options.sortFn}),this._cache=this.options.cache}async load(e,t={}){typeof e=="object"&&(t=e,e=void 0),e=e||this.options.maxHistory;const r=t.fetchEntryTimeout||this.options.fetchEntryTimeout;this.options.onLoad&&await this.options.onLoad(this);const n=await this._cache.get(this.localHeadsPath)||[],a=await this._cache.get(this.remoteHeadsPath)||[],i=n.concat(a);i.length>0&&this.events.emit("load",this.address.toString(),i),i.forEach(c=>this._recalculateReplicationMax(c.clock.time));const o=await ge.fromEntryHash(this._ipfs,this.identity,i.map(c=>c.hash),{logId:this.id,access:this.access,sortFn:this.options.sortFn,length:e,onProgressCallback:this._onLoadProgress.bind(this),timeout:r,concurrency:this.options.replicationConcurrency});this._oplog=o,i.length>0&&await this._updateIndex(),this.events.emit("ready",this.address.toString(),this._oplog.heads)}async sync(e){return this._stats.syncRequestsReceieved+=1,ga.debug(`Sync request #${this._stats.syncRequestsReceieved} ${e.length}`),e.length===0?void 0:Jh(e,async r=>{if(!r)return console.warn("Warning: Given input entry was 'null'."),Promise.resolve(null);const n=this.identity.provider;if(!n)throw new Error("Identity-provider is required, cannot verify entry");if(!await this.access.canAppend(r,n))return console.warn("Warning: Given input entry is not allowed in this log and was discarded (no write access)."),Promise.resolve(null);const i=de.toEntry(r);return await Lt(this._ipfs,Qd(i),i,{links:ci,onlyHash:!0})!==r.hash&&console.warn(`"WARNING! Head hash didn't match the contents`),r}).then(async r=>this._replicator.load(r.filter(n=>n!==null)))}loadMoreFrom(e,t){this._replicator.load(t)}async saveSnapshot(){const e=this._replicator.unfinished,t=this._oplog.toSnapshot(),r=zr.Buffer.from(JSON.stringify({id:t.id,heads:t.heads,size:t.values.length,values:t.values,type:this.type})),n=await this._ipfs.add(r);return n.hash=n.cid.toString(),await this._cache.set(this.snapshotPath,n),await this._cache.set(this.queuePath,e),ga.debug(`Saved snapshot: ${n.hash}, queue length: ${e.length}`),[n]}async loadFromSnapshot(e){this.options.onLoad&&await this.options.onLoad(this),this.events.emit("load",this.address.toString());const t=(a,i)=>Math.max(a,i.clock.time),r=await this._cache.get(this.queuePath);this.sync(r||[]);const n=await this._cache.get(this.snapshotPath);if(n){const a=[];for await(const c of this._ipfs.cat(n.hash))a.push(c);const i=zr.Buffer.concat(a),o=JSON.parse(i.toString());this._recalculateReplicationMax(o.values.reduce(t,0)),o&&(this._oplog=await ge.fromJSON(this._ipfs,this.identity,o,{access:this.access,sortFn:this.options.sortFn,length:-1,timeout:1e3,onProgressCallback:this._onLoadProgress.bind(this)}),await this._updateIndex(),this.events.emit("replicated",this.address.toString())),this.events.emit("ready",this.address.toString(),this._oplog.heads)}else throw new Error(`Snapshot for ${this.address} not found!`);return this}async _updateIndex(){await this._index.updateIndex(this._oplog)}async syncLocal(){const e=await this._cache.get(this.localHeadsPath)||[],t=await this._cache.get(this.remoteHeadsPath)||[],r=e.concat(t);for(let n=0;n<r.length;n++){const a=r[n];if(!this._oplog.heads.includes(a)){await this.load();break}}}async _addOperation(e,{onProgressCallback:t,pin:r=!1}={}){async function n(){if(this._oplog){this.options.syncLocal&&await this.syncLocal();const a=await this._oplog.append(e,this.options.referenceCount,r);return this._recalculateReplicationStatus(a.clock.time),await this._cache.set(this.localHeadsPath,[a]),await this._updateIndex(),this.events.emit("write",this.address.toString(),a,this._oplog.heads),t&&t(a),a.hash}}return this._queue.add(n.bind(this))}_addOperationBatch(e,t,r,n){throw new Error("Not implemented!")}_procEntry(e){const{payload:t,hash:r}=e,{op:n}=t;n?this.events.emit(`log.op.${n}`,this.address.toString(),r,t):this.events.emit("log.op.none",this.address.toString(),r,t),this.events.emit("log.op",n,this.address.toString(),r,t)}_recalculateReplicationProgress(){this._replicationStatus.progress=Math.max(Math.min(this._replicationStatus.progress+1,this._replicationStatus.max),this._oplog?this._oplog.length:0)}_recalculateReplicationMax(e){this._replicationStatus.max=Math.max.apply(null,[this.replicationStatus.max,this._oplog?this._oplog.length:0,e||0])}_recalculateReplicationStatus(e){this._recalculateReplicationMax(e),this._recalculateReplicationProgress()}_onLoadProgress(e){this._recalculateReplicationStatus(e.clock.time),this.events.emit("load.progress",this.address.toString(),e.hash,e,this.replicationStatus.progress,this.replicationStatus.max)}}const rl=(s,e)=>new Set([...s].filter(t=>!e.has(t))),q$={start:!0,pollInterval:1e3};class eh extends _l{constructor(e,t,r){super(),this._pubsub=e,this._topic=t,this._options=Object.assign({},q$,r),this._peers=[],this._interval=null,this._options.start&&this.start()}get started(){return this._interval!==null}set started(e){throw new Error("'started' is read-only")}start(){this._interval&&this.stop(),this._interval=setInterval(this._pollPeers.bind(this),this._options.pollInterval),this._pollPeers()}stop(){clearInterval(this._interval),this._interval=null,this.removeAllListeners("error"),this.removeAllListeners("join"),this.removeAllListeners("leave")}async getPeers(){return this._peers=await this._pubsub.peers(this._topic),this._peers.slice()}hasPeer(e){return this._peers.includes(e)}async _pollPeers(){try{const e=await this._pubsub.peers(this._topic);eh._emitJoinsAndLeaves(new Set(this._peers),new Set(e),this),this._peers=e}catch(e){clearInterval(this._interval),this.emit("error",e)}}static _emitJoinsAndLeaves(e,t,r){const n=i=>r.emit("join",i),a=i=>r.emit("leave",i);rl(t,e).forEach(n),rl(e,t).forEach(a)}}function K$(s,e){if(s.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),r=0;r<t.length;r++)t[r]=255;for(var n=0;n<s.length;n++){var a=s.charAt(n),i=a.charCodeAt(0);if(t[i]!==255)throw new TypeError(a+" is ambiguous");t[i]=n}var o=s.length,c=s.charAt(0),l=Math.log(o)/Math.log(256),u=Math.log(256)/Math.log(o);function d(p){if(p instanceof Uint8Array||(ArrayBuffer.isView(p)?p=new Uint8Array(p.buffer,p.byteOffset,p.byteLength):Array.isArray(p)&&(p=Uint8Array.from(p))),!(p instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(p.length===0)return"";for(var g=0,_=0,v=0,k=p.length;v!==k&&p[v]===0;)v++,g++;for(var P=(k-v)*u+1>>>0,T=new Uint8Array(P);v!==k;){for(var I=p[v],x=0,C=P-1;(I!==0||x<_)&&C!==-1;C--,x++)I+=256*T[C]>>>0,T[C]=I%o>>>0,I=I/o>>>0;if(I!==0)throw new Error("Non-zero carry");_=x,v++}for(var S=P-_;S!==P&&T[S]===0;)S++;for(var L=c.repeat(g);S<P;++S)L+=s.charAt(T[S]);return L}function h(p){if(typeof p!="string")throw new TypeError("Expected String");if(p.length===0)return new Uint8Array;var g=0;if(p[g]!==" "){for(var _=0,v=0;p[g]===c;)_++,g++;for(var k=(p.length-g)*l+1>>>0,P=new Uint8Array(k);p[g];){var T=t[p.charCodeAt(g)];if(T===255)return;for(var I=0,x=k-1;(T!==0||I<v)&&x!==-1;x--,I++)T+=o*P[x]>>>0,P[x]=T%256>>>0,T=T/256>>>0;if(T!==0)throw new Error("Non-zero carry");v=I,g++}if(p[g]!==" "){for(var C=k-v;C!==k&&P[C]===0;)C++;for(var S=new Uint8Array(_+(k-C)),L=_;C!==k;)S[L++]=P[C++];return S}}}function f(p){var g=h(p);if(g)return g;throw new Error(`Non-${e} character`)}return{encode:d,decodeUnsafe:h,decode:f}}var V$=K$,W$=V$;const J$=(s,e)=>{if(s===e)return!0;if(s.byteLength!==e.byteLength)return!1;for(let t=0;t<s.byteLength;t++)if(s[t]!==e[t])return!1;return!0},qn=s=>{if(s instanceof Uint8Array&&s.constructor.name==="Uint8Array")return s;if(s instanceof ArrayBuffer)return new Uint8Array(s);if(ArrayBuffer.isView(s))return new Uint8Array(s.buffer,s.byteOffset,s.byteLength);throw new Error("Unknown type, must be binary type")},G$=s=>new TextEncoder().encode(s),Q$=s=>new TextDecoder().decode(s);class X${constructor(e,t,r){this.name=e,this.prefix=t,this.baseEncode=r}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}}class Y${constructor(e,t,r){if(this.name=e,this.prefix=t,t.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=t.codePointAt(0),this.baseDecode=r}decode(e){if(typeof e=="string"){if(e.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(e.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(e){return th(this,e)}}class Z${constructor(e){this.decoders=e}or(e){return th(this,e)}decode(e){const t=e[0],r=this.decoders[t];if(r)return r.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const th=(s,e)=>new Z$({...s.decoders||{[s.prefix]:s},...e.decoders||{[e.prefix]:e}});class eP{constructor(e,t,r,n){this.name=e,this.prefix=t,this.baseEncode=r,this.baseDecode=n,this.encoder=new X$(e,t,r),this.decoder=new Y$(e,t,n)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}}const Kn=({name:s,prefix:e,encode:t,decode:r})=>new eP(s,e,t,r),hs=({prefix:s,name:e,alphabet:t})=>{const{encode:r,decode:n}=W$(t,e);return Kn({prefix:s,name:e,encode:r,decode:a=>qn(n(a))})},tP=(s,e,t,r)=>{const n={};for(let u=0;u<e.length;++u)n[e[u]]=u;let a=s.length;for(;s[a-1]==="=";)--a;const i=new Uint8Array(a*t/8|0);let o=0,c=0,l=0;for(let u=0;u<a;++u){const d=n[s[u]];if(d===void 0)throw new SyntaxError(`Non-${r} character`);c=c<<t|d,o+=t,o>=8&&(o-=8,i[l++]=255&c>>o)}if(o>=t||255&c<<8-o)throw new SyntaxError("Unexpected end of data");return i},rP=(s,e,t)=>{const r=e[e.length-1]==="=",n=(1<<t)-1;let a="",i=0,o=0;for(let c=0;c<s.length;++c)for(o=o<<8|s[c],i+=8;i>t;)i-=t,a+=e[n&o>>i];if(i&&(a+=e[n&o<<t-i]),r)for(;a.length*t&7;)a+="=";return a},De=({name:s,prefix:e,bitsPerChar:t,alphabet:r})=>Kn({prefix:e,name:s,encode(n){return rP(n,r,t)},decode(n){return tP(n,r,t,s)}}),sP=Kn({prefix:"\0",name:"identity",encode:s=>Q$(s),decode:s=>G$(s)}),nP=Object.freeze(Object.defineProperty({__proto__:null,identity:sP},Symbol.toStringTag,{value:"Module"})),aP=De({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),iP=Object.freeze(Object.defineProperty({__proto__:null,base2:aP},Symbol.toStringTag,{value:"Module"})),oP=De({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),cP=Object.freeze(Object.defineProperty({__proto__:null,base8:oP},Symbol.toStringTag,{value:"Module"})),lP=hs({prefix:"9",name:"base10",alphabet:"0123456789"}),uP=Object.freeze(Object.defineProperty({__proto__:null,base10:lP},Symbol.toStringTag,{value:"Module"})),dP=De({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),hP=De({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),fP=Object.freeze(Object.defineProperty({__proto__:null,base16:dP,base16upper:hP},Symbol.toStringTag,{value:"Module"})),jr=De({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),pP=De({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),yP=De({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),wP=De({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),gP=De({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),bP=De({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),mP=De({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),_P=De({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),EP=De({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),vP=Object.freeze(Object.defineProperty({__proto__:null,base32:jr,base32hex:gP,base32hexpad:mP,base32hexpadupper:_P,base32hexupper:bP,base32pad:yP,base32padupper:wP,base32upper:pP,base32z:EP},Symbol.toStringTag,{value:"Module"})),DP=hs({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),SP=hs({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),kP=Object.freeze(Object.defineProperty({__proto__:null,base36:DP,base36upper:SP},Symbol.toStringTag,{value:"Module"})),st=hs({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),$P=hs({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),PP=Object.freeze(Object.defineProperty({__proto__:null,base58btc:st,base58flickr:$P},Symbol.toStringTag,{value:"Module"})),AP=De({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),RP=De({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),TP=De({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),OP=De({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),CP=Object.freeze(Object.defineProperty({__proto__:null,base64:AP,base64pad:RP,base64url:TP,base64urlpad:OP},Symbol.toStringTag,{value:"Module"})),rh=Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),IP=rh.reduce((s,e,t)=>(s[t]=e,s),[]),NP=rh.reduce((s,e,t)=>(s[e.codePointAt(0)]=t,s),[]);function xP(s){return s.reduce((e,t)=>(e+=IP[t],e),"")}function LP(s){const e=[];for(const t of s){const r=NP[t.codePointAt(0)];if(r===void 0)throw new Error(`Non-base256emoji character: ${t}`);e.push(r)}return new Uint8Array(e)}const BP=Kn({prefix:"🚀",name:"base256emoji",encode:xP,decode:LP}),jP=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:BP},Symbol.toStringTag,{value:"Module"}));var MP=sh,sl=128,zP=127,UP=~zP,FP=Math.pow(2,31);function sh(s,e,t){e=e||[],t=t||0;for(var r=t;s>=FP;)e[t++]=s&255|sl,s/=128;for(;s&UP;)e[t++]=s&255|sl,s>>>=7;return e[t]=s|0,sh.bytes=t-r+1,e}var HP=li,qP=128,nl=127;function li(s,r){var t=0,r=r||0,n=0,a=r,i,o=s.length;do{if(a>=o)throw li.bytes=0,new RangeError("Could not decode varint");i=s[a++],t+=n<28?(i&nl)<<n:(i&nl)*Math.pow(2,n),n+=7}while(i>=qP);return li.bytes=a-r,t}var KP=Math.pow(2,7),VP=Math.pow(2,14),WP=Math.pow(2,21),JP=Math.pow(2,28),GP=Math.pow(2,35),QP=Math.pow(2,42),XP=Math.pow(2,49),YP=Math.pow(2,56),ZP=Math.pow(2,63),eA=function(s){return s<KP?1:s<VP?2:s<WP?3:s<JP?4:s<GP?5:s<QP?6:s<XP?7:s<YP?8:s<ZP?9:10},tA={encode:MP,decode:HP,encodingLength:eA},cn=tA;const ui=(s,e=0)=>[cn.decode(s,e),cn.decode.bytes],ln=(s,e,t=0)=>(cn.encode(s,e,t),e),un=s=>cn.encodingLength(s),dn=(s,e)=>{const t=e.byteLength,r=un(s),n=r+un(t),a=new Uint8Array(n+t);return ln(s,a,0),ln(t,a,r),a.set(e,n),new ro(s,t,e,a)},rA=s=>{const e=qn(s),[t,r]=ui(e),[n,a]=ui(e.subarray(r)),i=e.subarray(r+a);if(i.byteLength!==n)throw new Error("Incorrect length");return new ro(t,n,i,e)},sA=(s,e)=>s===e?!0:s.code===e.code&&s.size===e.size&&J$(s.bytes,e.bytes);class ro{constructor(e,t,r,n){this.code=e,this.size=t,this.digest=r,this.bytes=n}}const nA=({name:s,code:e,encode:t})=>new aA(s,e,t);class aA{constructor(e,t,r){this.name=e,this.code=t,this.encode=r}digest(e){if(e instanceof Uint8Array){const t=this.encode(e);return t instanceof Uint8Array?dn(this.code,t):t.then(r=>dn(this.code,r))}else throw Error("Unknown type, must be binary type")}}const iA=s=>async e=>new Uint8Array(await crypto.subtle.digest(s,e)),fR=nA({name:"sha2-256",code:18,encode:iA("SHA-256")}),nh=0,oA="identity",ah=qn,cA=s=>dn(nh,ah(s)),pR={code:nh,name:oA,encode:ah,digest:cA};new TextEncoder;new TextDecoder;class se{constructor(e,t,r,n){this.code=t,this.version=e,this.multihash=r,this.bytes=n,this.byteOffset=n.byteOffset,this.byteLength=n.byteLength,this.asCID=this,this._baseCache=new Map,Object.defineProperties(this,{byteOffset:Cs,byteLength:Cs,code:Os,version:Os,multihash:Os,bytes:Os,_baseCache:Cs,asCID:Cs})}toV0(){switch(this.version){case 0:return this;default:{const{code:e,multihash:t}=this;if(e!==Ar)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==hA)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return se.createV0(t)}}}toV1(){switch(this.version){case 0:{const{code:e,digest:t}=this.multihash,r=dn(e,t);return se.createV1(this.code,r)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}equals(e){return e&&this.code===e.code&&this.version===e.version&&sA(this.multihash,e.multihash)}toString(e){const{bytes:t,version:r,_baseCache:n}=this;switch(r){case 0:return uA(t,n,e||st.encoder);default:return dA(t,n,e||jr.encoder)}}toJSON(){return{code:this.code,version:this.version,hash:this.multihash.bytes}}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return"CID("+this.toString()+")"}static isCID(e){return pA(/^0\.0/,yA),!!(e&&(e[il]||e.asCID===e))}get toBaseEncodedString(){throw new Error("Deprecated, use .toString()")}get codec(){throw new Error('"codec" property is deprecated, use integer "code" property instead')}get buffer(){throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead")}get multibaseName(){throw new Error('"multibaseName" property is deprecated')}get prefix(){throw new Error('"prefix" property is deprecated')}static asCID(e){if(e instanceof se)return e;if(e!=null&&e.asCID===e){const{version:t,code:r,multihash:n,bytes:a}=e;return new se(t,r,n,a||al(t,r,n.bytes))}else if(e!=null&&e[il]===!0){const{version:t,multihash:r,code:n}=e,a=rA(r);return se.create(t,n,a)}else return null}static create(e,t,r){if(typeof t!="number")throw new Error("String codecs are no longer supported");switch(e){case 0:{if(t!==Ar)throw new Error(`Version 0 CID must use dag-pb (code: ${Ar}) block encoding`);return new se(e,t,r,r.bytes)}case 1:{const n=al(e,t,r.bytes);return new se(e,t,r,n)}default:throw new Error("Invalid version")}}static createV0(e){return se.create(0,Ar,e)}static createV1(e,t){return se.create(1,e,t)}static decode(e){const[t,r]=se.decodeFirst(e);if(r.length)throw new Error("Incorrect length");return t}static decodeFirst(e){const t=se.inspectBytes(e),r=t.size-t.multihashSize,n=qn(e.subarray(r,r+t.multihashSize));if(n.byteLength!==t.multihashSize)throw new Error("Incorrect length");const a=n.subarray(t.multihashSize-t.digestSize),i=new ro(t.multihashCode,t.digestSize,a,n);return[t.version===0?se.createV0(i):se.createV1(t.codec,i),e.subarray(t.size)]}static inspectBytes(e){let t=0;const r=()=>{const[d,h]=ui(e.subarray(t));return t+=h,d};let n=r(),a=Ar;if(n===18?(n=0,t=0):n===1&&(a=r()),n!==0&&n!==1)throw new RangeError(`Invalid CID version ${n}`);const i=t,o=r(),c=r(),l=t+c,u=l-i;return{version:n,codec:a,multihashCode:o,digestSize:c,multihashSize:u,size:l}}static parse(e,t){const[r,n]=lA(e,t),a=se.decode(n);return a._baseCache.set(r,e),a}}const lA=(s,e)=>{switch(s[0]){case"Q":{const t=e||st;return[st.prefix,t.decode(`${st.prefix}${s}`)]}case st.prefix:{const t=e||st;return[st.prefix,t.decode(s)]}case jr.prefix:{const t=e||jr;return[jr.prefix,t.decode(s)]}default:{if(e==null)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[s[0],e.decode(s)]}}},uA=(s,e,t)=>{const{prefix:r}=t;if(r!==st.prefix)throw Error(`Cannot string encode V0 in ${t.name} encoding`);const n=e.get(r);if(n==null){const a=t.encode(s).slice(1);return e.set(r,a),a}else return n},dA=(s,e,t)=>{const{prefix:r}=t,n=e.get(r);if(n==null){const a=t.encode(s);return e.set(r,a),a}else return n},Ar=112,hA=18,al=(s,e,t)=>{const r=un(s),n=r+un(e),a=new Uint8Array(n+t.byteLength);return ln(s,a,0),ln(e,a,r),a.set(t,n),a},il=Symbol.for("@ipld/js-cid/CID"),Os={writable:!1,configurable:!1,enumerable:!0},Cs={writable:!1,enumerable:!1,configurable:!1},fA="0.0.0-dev",pA=(s,e)=>{if(s.test(fA))console.warn(e);else throw new Error(e)},yA=`CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`,yR={...nP,...iP,...cP,...uP,...fP,...vP,...kP,...PP,...CP,...jP},Is=({enumerable:s=!0,configurable:e=!1}={})=>({enumerable:s,configurable:e,writable:!1}),di=function*(s,e){if(s!=null&&!(s instanceof Uint8Array))for(const[t,r]of Object.entries(s)){const n=[...e,t];if(r!=null&&typeof r=="object")if(Array.isArray(r))for(const[a,i]of r.entries()){const o=[...n,a],c=se.asCID(i);c?yield[o.join("/"),c]:typeof i=="object"&&(yield*di(i,o))}else{const a=se.asCID(r);a?yield[n.join("/"),a]:yield*di(r,n)}}},hi=function*(s,e){if(s!=null)for(const[t,r]of Object.entries(s)){const n=[...e,t];if(yield n.join("/"),r!=null&&!(r instanceof Uint8Array)&&typeof r=="object"&&!se.asCID(r))if(Array.isArray(r))for(const[a,i]of r.entries()){const o=[...n,a];yield o.join("/"),typeof i=="object"&&!se.asCID(i)&&(yield*hi(i,o))}else yield*hi(r,n)}},wA=(s,e)=>{let t=s;for(const[r,n]of e.entries()){if(t=t[n],t==null)throw new Error(`Object has no property at ${e.slice(0,r+1).map(i=>`[${JSON.stringify(i)}]`).join("")}`);const a=se.asCID(t);if(a)return{value:a,remaining:e.slice(r+1).join("/")}}return{value:t}};class ih{constructor({cid:e,bytes:t,value:r}){if(!e||!t||typeof r>"u")throw new Error("Missing required argument");this.cid=e,this.bytes=t,this.value=r,this.asBlock=this,Object.defineProperties(this,{cid:Is(),bytes:Is(),value:Is(),asBlock:Is()})}links(){return di(this.value,[])}tree(){return hi(this.value,[])}get(e="/"){return wA(this.value,e.split("/").filter(Boolean))}}const wR=async({value:s,codec:e,hasher:t})=>{if(typeof s>"u")throw new Error('Missing required argument "value"');if(!e||!t)throw new Error("Missing required argument: codec or hasher");const r=e.encode(s),n=await t.digest(r),a=se.create(1,e.code,n);return new ih({value:s,bytes:r,cid:a})},gR=async({bytes:s,codec:e,hasher:t})=>{if(!s)throw new Error('Missing required argument "bytes"');if(!e||!t)throw new Error("Missing required argument: codec or hasher");const r=e.decode(s),n=await t.digest(s),a=se.create(1,e.code,n);return new ih({value:r,bytes:s,cid:a})};class Vn extends Yr.EventEmitter{static async create(e,t){}static get type(){throw new Error("'static get type ()' needs to be defined in the inheriting class")}get type(){return this.constructor.type}get address(){}async canAppend(e,t){}async grant(e,t){return!1}async revoke(e,t){return!1}async load(e){}async save(){}async close(){}}class Wr{constructor(e,t={}){this.type=e,this.params=t}static async resolve(e,t,r={}){if(r.skipManifest){if(!r.type)throw new Error("No manifest, access-controller type required");return new Wr(r.type,{address:t})}else{t.indexOf("/ipfs")===0&&(t=t.split("/")[2]);const{type:n,params:a}=await dr(e,t);return new Wr(n,a)}}static async create(e,t,r){return r.skipManifest?r.address:Lt(e,"dag-cbor",{type:t,params:r})}}const gA="legacy-ipfs";class so extends Vn{constructor(e,t){super(),this._ipfs=e,this._write=Array.from(t.write||[])}static get type(){return gA}get write(){return this._write}async canAppend(e,t){const r=e.key;return!!(this.write.includes(r)||this.write.includes("*"))}async load(e){e.indexOf("/ipfs")===0&&(e=e.split("/")[2]);try{const t=await dr(this._ipfs,e);this._write=t.write}catch(t){console.log("LegacyIPFSAccessController.load ERROR:",t)}}async save(e){let t;const r={admin:[],write:this.write,read:[]};try{t=await Lt(this._ipfs,"raw",Da.Buffer.from(JSON.stringify(r,null,2)),{format:"dag-pb"})}catch(n){console.log("LegacyIPFSAccessController.save ERROR:",n)}return{address:t,skipManifest:!0}}static async create(e,t={}){return t={...t,write:t.write||[e.identity.publicKey]},new so(e._ipfs,t)}}const bA=async(s,e,t={})=>{const r=await dr(s,e,t);return typeof r.write=="string"?JSON.parse(r.write):r.write},mA=Lt,_A="ipfs";class no extends Vn{constructor(e,t){super(),this._ipfs=e,this._write=Array.from(t.write||[])}static get type(){return _A}get write(){return this._write}async canAppend(e,t){const r=e.identity.id;return this.write.includes(r)||this.write.includes("*")?t.verifyIdentity(e.identity):!1}async load(e){e.indexOf("/ipfs")===0&&(e=e.split("/")[2]);try{this._write=await bA(this._ipfs,e)}catch(t){console.log("IPFSAccessController.load ERROR:",t)}}async save(){let e;try{e=await mA(this._ipfs,"dag-cbor",{write:JSON.stringify(this.write,null,2)})}catch(t){console.log("IPFSAccessController.save ERROR:",t)}return{address:e}}static async create(e,t={}){return t={...t,write:t.write||[e.identity.id]},new no(e._ipfs,t)}}const EA=s=>s.toString().split("/").pop()==="_access"?s:ye.join(s,"/_access"),vA="orbitdb";class ao extends Vn{constructor(e,t){super(),this._orbitdb=e,this._db=null,this._options=t||{}}static get type(){return vA}get address(){return this._db.address}async canAppend(e,t){const r=new Set([...this.get("write"),...this.get("admin")]);return r.has(e.identity.id)||r.has("*")?await t.verifyIdentity(e.identity):!1}get capabilities(){if(this._db){const e=this._db.index,t=r=>{const n=r[0];e[n]=new Set([...e[n]||[],...r[1]])};return Object.entries({...e,admin:new Set([...e.admin||[],...this._db.access.write])}).forEach(t),e}return{}}get(e){return this.capabilities[e]||new Set([])}async close(){await this._db.close()}async load(e){this._db&&await this._db.close(),this._db=await this._orbitdb.keyvalue(EA(e),{accessController:{type:"ipfs",write:this._options.admin||[this._orbitdb.identity.id]},sync:!0}),this._db.events.on("ready",this._onUpdate.bind(this)),this._db.events.on("write",this._onUpdate.bind(this)),this._db.events.on("replicated",this._onUpdate.bind(this)),await this._db.load()}async save(){return{address:this._db.address.toString()}}async hasCapability(e,t){const r=new Set(this.get(e));return r.has(t.id)||r.has("*")}async grant(e,t){const r=new Set([...this._db.get(e)||[],t]);await this._db.put(e,Array.from(r.values()))}async revoke(e,t){const r=new Set(this._db.get(e)||[]);r.delete(t),r.size>0?await this._db.put(e,Array.from(r.values())):await this._db.del(e)}_onUpdate(){this.emit("updated")}static async create(e,t={}){const r=new ao(e,t);return await r.load(t.address||t.name||"default-access-controller"),t.write&&!t.address&&await Gh(t.write,async n=>r.grant("write",n)),r}}const zs={"legacy-ipfs":so,ipfs:no,orbitdb:ao},ol=s=>{if(!oh.isSupported(s))throw new Error(`AccessController type '${s}' is not supported`);return zs[s]};let oh=class ch{static get AccessController(){return Vn}static isSupported(e){return Object.keys(zs).includes(e)}static addAccessController(e){if(!e.AccessController)throw new Error("AccessController class needs to be given as an option");if(!e.AccessController.type||typeof e.AccessController.type!="string")throw new Error("Given AccessController class needs to implement: static get type() { /* return a string */}.");zs[e.AccessController.type]=e.AccessController}static addAccessControllers(e){const t=e.AccessControllers;if(!t)throw new Error("AccessController classes need to be given as an option");t.forEach(r=>{ch.addAccessController({AccessController:r})})}static removeAccessController(e){delete zs[e]}static async resolve(e,t,r={}){const{type:n,params:a}=await Wr.resolve(e._ipfs,t,r),o=await ol(n).create(e,Object.assign({},r,a));return await o.load(a.address),o}static async create(e,t,r={}){const i=await(await ol(t).create(e,r)).save();return await Wr.create(e._ipfs,t,i)}};const DA=s=>s!==""&&s!==" ";class je{constructor(e,t){this.root=e,this.path=t}toString(){return je.join(this.root,this.path)}static isValid(e){e=e.toString().replace(/\\/g,"/");const t=(i,o)=>!((o===0||o===1)&&e.toString().indexOf("/orbit")===0&&i==="orbitdb"),r=e.toString().split("/").filter(t).filter(DA);let n;const a=i=>{const o=["zd","Qm","ba","k5"];for(const c of o)if(i.indexOf(c)>-1)return!0;return!1};try{n=a(r[0])?w.parse(r[0]).toString():null}catch{return!1}return n!==null}static parse(e){if(!e)throw new Error(`Not a valid OrbitDB address: ${e}`);if(!je.isValid(e))throw new Error(`Not a valid OrbitDB address: ${e}`);e=e.toString().replace(/\\/g,"/");const t=e.toString().split("/").filter((r,n)=>!((n===0||n===1)&&e.toString().indexOf("/orbit")===0&&r==="orbitdb")).filter(r=>r!==""&&r!==" ");return new je(t[0],t.slice(1,t.length).join("/"))}static join(...e){return(ye.posix||ye).join("/orbitdb",...e)}}const SA=async(s,e,t,r,n)=>{const a=Object.assign({name:e,type:t,accessController:(ye.posix||ye).join("/ipfs",r)},n.meta!==void 0?{meta:n.meta}:{});return Lt(s,n.format||"dag-cbor",a,n)},kA="ipfs-pubsub-direct-channel/v1",$A=s=>{let e=s;return Da.Buffer.isBuffer(e)||(e=Da.Buffer.from(e)),e},PA=async(s,e,t,r)=>{const n=async()=>{const a=await s.pubsub.peers(t),i=e.map(l=>String(l)),o=a.map(l=>String(l));return i.map(l=>o.includes(l)).filter(l=>l===!1).length===0};return await n()?Promise.resolve():new Promise((a,i)=>{const o=setInterval(async()=>{try{r()?clearInterval(o):await n()&&(clearInterval(o),a())}catch(c){i(c)}},100)})},AA=async s=>(await s.id()).id;class io extends _l{constructor(e,t){if(super(),this._ipfs=e,!e.pubsub)throw new Error("This IPFS node does not support pubsub.");if(this._closed=!1,this._isClosed=()=>this._closed,this._receiverID=t,!this._receiverID)throw new Error("Receiver ID was undefined")}get id(){return this._id}get peers(){return this._peers}async connect(){await PA(this._ipfs,[this._receiverID],this._id,this._isClosed)}async send(e){if(this._closed)return;const t=$A(e);await this._ipfs.pubsub.publish(this._id,t)}close(){this._closed=!0,this.removeAllListeners("message"),this._ipfs.pubsub.unsubscribe(this._id,this._messageHandler)}async _setup(){this._senderID=await AA(this._ipfs),this._peers=Array.from([this._senderID,this._receiverID]).sort(),this._id="/"+kA+"/"+this._peers.join("/"),this._messageHandler=e=>{e&&String(e.from)===String(this._receiverID)&&this.emit("message",e)}}async _openChannel(){this._closed=!1,await this._setup(),await this._ipfs.pubsub.subscribe(this._id,this._messageHandler)}static async open(e,t){const r=new io(e,t);return await r._openChannel(),r}}const Rr=Ye.create("exchange-heads",{color:Ye.Colors.Yellow});Ye.setLogLevel("ERROR");const RA=async s=>{if(!(s&&s._cache))return[];const e=await s._cache.get(s.localHeadsPath)||[],t=await s._cache.get(s.remoteHeadsPath)||[];return[...e,...t]},TA=async(s,e,t,r,n,a,i)=>{const o=u=>{const d=JSON.parse(zr.Buffer.from(u.data).toString()),{address:h,heads:f}=d;a(h,f)};let c=n(t);if(!c)try{Rr.debug(`Create a channel to ${t}`),c=await io.open(s,t),c.on("message",o),Rr.debug(`Channel created to ${t}`),i(c)}catch(u){Rr.error(u)}await c.connect(),Rr.debug(`Connected to ${t}`);const l=await RA(r(e));return Rr.debug(`Send latest heads of '${e}':
`,JSON.stringify(l.map(u=>u.hash),null,2)),l&&await c.send(JSON.stringify({address:e,heads:l})),c},ba=s=>s!=null,ma=!Qh&&(typeof window=="object"||typeof self=="object")?null:uk,cl=Ye.create("orbit-db");Ye.setLogLevel("ERROR");async function OA(s,e,t){let r=e.cache||(s.caches[e.directory]?s.caches[e.directory].cache:null),n;if(!r){const c=(ye.posix||ye).join(s.directory,t.root,t.path);if(ma&&ma.existsSync&&!ma.existsSync(c))return;n=await s.storage.createStore(c),r=new xs(n)}if(!await r.get("_localHeads"))return;const i=t.toString();cl.debug("Attempting to migrate from old cache location");const o=["_remoteHeads","_localHeads","snapshot","queue"];for(const c in o)try{const l=ye.join(i,o[c]),u=await r.get(o[c]);u&&await e.cache.set(l,u)}catch(l){cl.debug(l.message)}await e.cache.set(ye.join(i,"_manifest"),t.root),n&&await n.close()}const ll=[OA],CA=async(s,e,t)=>{for(let r=0;r<ll.length;r++)await ll[r](s,e,t)},Se=Ye.create("orbit-db");Ye.setLogLevel("ERROR");const Ft={counter:$l,eventlog:Dl,feed:Sl,docstore:Pl,keyvalue:kl},IA=3e4;let Kt=oh;class Pt{constructor(e,t,r={}){if(!ba(e))throw new Error("IPFS is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance");if(!ba(t))throw new Error("identity is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance");this._ipfs=e,this.identity=t,this.id=r.peerId,this._pubsub=r.offline?null:new(r.broker?r.broker:yo)(this._ipfs,this.id),this.directory=r.directory||"./orbitdb",this.storage=r.storage,this._directConnections={},this.caches={},this.caches[this.directory]={cache:r.cache,handlers:new Set},this.keystore=r.keystore,this.stores={},Kt=r.AccessControllers||Kt}static get Pubsub(){return yo}static get Cache(){return xs}static get Keystore(){return Sa}static get Identities(){return ka}static get AccessControllers(){return Kt}static get Storage(){return wo}static get OrbitDBAddress(){return je}static get Store(){return H$}static get EventStore(){return Dl}static get FeedStore(){return Sl}static get KeyValueStore(){return kl}static get CounterStore(){return $l}static get DocumentStore(){return Pl}get cache(){return this.caches[this.directory].cache}static async createInstance(e,t={}){if(!ba(e))throw new Error("IPFS is a required argument. See https://github.com/orbitdb/orbit-db/blob/master/API.md#createinstance");if(t.offline===void 0&&(t.offline=!1),t.offline&&!t.id)throw new Error("Offline mode requires passing an `id` in the options");const{id:r}=t.id||t.offline?{id:t.id}:await e.id();if(t.directory||(t.directory="./orbitdb"),!t.storage){const a={};t.storage=wo(null,a)}if(t.identity&&t.identity.provider.keystore&&(t.keystore=t.identity.provider.keystore),!t.keystore){const a=ye.join(t.directory,typeof r!="object"?r:r.toString(),"/keystore"),i=await t.storage.createStore(a);t.keystore=new Sa(i)}if(t.identity||(t.identity=await ka.createIdentity({id:r,keystore:t.keystore})),!t.cache){const a=ye.join(t.directory,typeof r!="object"?r:r.toString(),"/cache"),i=await t.storage.createStore(a);t.cache=new xs(i)}const n=Object.assign({},t,{peerId:typeof r!="object"?r:r.toString()});return new Pt(e,t.identity,n)}async feed(e,t={}){return t=Object.assign({create:!0,type:"feed"},t),this.open(e,t)}async log(e,t={}){return t=Object.assign({create:!0,type:"eventlog"},t),this.open(e,t)}async eventlog(e,t={}){return this.log(e,t)}async keyvalue(e,t={}){return t=Object.assign({create:!0,type:"keyvalue"},t),this.open(e,t)}async kvstore(e,t={}){return this.keyvalue(e,t)}async counter(e,t={}){return t=Object.assign({create:!0,type:"counter"},t),this.open(e,t)}async docs(e,t={}){return t=Object.assign({create:!0,type:"docstore"},t),this.open(e,t)}async docstore(e,t={}){return this.docs(e,t)}async disconnect(){for(const r of Object.values(this._directConnections))r.close();this._directConnections={},this._pubsub&&await this._pubsub.disconnect(),await this.keystore.close();const e=Object.values(this.stores);for(const r of e)await r.close();this.stores={};const t=Object.values(this.caches);for(const r of t)await r.cache.close();this.caches={},this.stores={}}async stop(){await this.disconnect()}async _createCache(e){const t=await this.storage.createStore(e);return new xs(t)}async _createStore(e,t,r){const n=Ft[e];if(!n)throw new Error(`Invalid database type '${e}'`);let a;r.accessControllerAddress&&(a=await Kt.resolve(this,r.accessControllerAddress,r.accessController));const i=Object.assign({replicate:!0},r,{accessController:a,cache:r.cache,onClose:this._onClose.bind(this),onDrop:this._onDrop.bind(this),onLoad:this._onLoad.bind(this)}),o=r.identity||this.identity,c=new n(this._ipfs,o,t,i);c.events.on("write",this._onWrite.bind(this));const l=t.toString();return this.stores[l]=c,i.replicate&&this._pubsub&&await this._pubsub.subscribe(l,this._onMessage.bind(this),this._onPeerConnected.bind(this)),c}_onWrite(e,t,r){if(!r)throw new Error("'heads' not defined");this._pubsub&&this._pubsub.publish(e,r)}async _onMessage(e,t,r){const n=this.stores[e];try{Se.debug(`Received ${t.length} heads for '${e}':
`,JSON.stringify(t.map(a=>a.hash),null,2)),n&&t&&(t.length>0&&await n.sync(t),n.events.emit("peer.exchanged",r,e,t))}catch(a){Se.error(a)}}async _onPeerConnected(e,t){Se.debug(`New peer '${t}' connected to '${e}'`);const r=o=>this.stores[o],n=o=>this._directConnections[o],a=o=>{this._directConnections[o._receiverID]=o},i=(o,c)=>this._onMessage(o,c,t);await TA(this._ipfs,e,t,r,n,i,a),r(e)&&r(e).events.emit("peer",t)}async _onClose(e){const t=e.address.toString();Se.debug(`Close ${t}`),this._pubsub&&await this._pubsub.unsubscribe(t);const r=e&&e.options.directory?e.options.directory:this.directory,n=this.caches[r];n&&n.handlers.has(t)&&(n.handlers.delete(t),n.handlers.size||await n.cache.close()),delete this.stores[t]}async _onDrop(e){const t=e.address.toString(),r=e&&e.options.directory?e.options.directory:this.directory;await this._requestCache(t,r,e._cache)}async _onLoad(e){const t=e.address.toString(),r=e&&e.options.directory?e.options.directory:this.directory;await this._requestCache(t,r,e._cache),this.stores[t]=e}async _determineAddress(e,t,r={}){if(!Pt.isValidType(t))throw new Error(`Invalid database type '${t}'`);if(je.isValid(e))throw new Error("Given database name is an address. Please give only the name of the database!");r.accessController=Object.assign({},{name:e,type:"ipfs"},r.accessController);const n=await Kt.create(this,r.accessController.type,r.accessController||{}),a=await SA(this._ipfs,e,t,n,r);return je.parse(je.join(a,e))}async create(e,t,r={}){Se.debug("create()"),Se.debug(`Creating database '${e}' as ${t}`);const n=await this._determineAddress(e,t,r);if(r.cache=await this._requestCache(n.toString(),r.directory),await this._haveLocalData(r.cache,n)&&!r.overwrite)throw new Error(`Database '${n}' already exists!`);return await this._migrate({...r,directory:this.directory},n),await this._addManifestToCache(r.cache,n),Se.debug(`Created database '${n}'`),this.open(n,r)}async determineAddress(e,t,r={}){const n=Object.assign({},{onlyHash:!0},r);return this._determineAddress(e,t,n)}async _requestCache(e,t,r){const n=t||this.directory;if(!this.caches[n]){const i=r||await this._createCache(n);this.caches[n]={cache:i,handlers:new Set}}this.caches[n].handlers.add(e);const a=this.caches[n].cache;return a&&await a.open(),a}async open(e,t={}){if(Se.debug("open()"),t=Object.assign({localOnly:!1,create:!1},t),Se.debug(`Open database '${e}'`),!je.isValid(e))if(t.create){if(t.create&&!t.type)throw new Error(`Database type not provided! Provide a type with 'options.type' (${Pt.databaseTypes.join("|")})`);return Se.warn(`Not a valid OrbitDB address '${e}', creating the database`),t.overwrite=t.overwrite?t.overwrite:!0,this.create(e,t.type,t)}else throw new Error("'options.create' set to 'false'. If you want to create a database, set 'options.create' to 'true'.");const r=je.parse(e);t.cache=await this._requestCache(r.toString(),t.directory);const n=await this._haveLocalData(t.cache,r);if(Se.debug((n?"Found":"Didn't find")+` database '${r}'`),t.localOnly&&!n)throw Se.warn(`Database '${r}' doesn't exist!`),new Error(`Database '${r}' doesn't exist!`);Se.debug(`Loading Manifest for '${r}'`);let a;try{a=await dr(this._ipfs,r.root,{timeout:t.timeout||IA}),Se.debug(`Manifest for '${r}':
${JSON.stringify(a,null,2)}`)}catch(i){throw i.name==="TimeoutError"&&i.code==="ERR_TIMEOUT"?(console.error(i),new Error("ipfs unable to find and fetch manifest for this address.")):i}if(a.name!==r.path&&Se.warn(`Manifest name '${a.name}' and path name '${r.path}' do not match`),t.type&&a.type!==t.type)throw new Error(`Database '${r}' is type '${a.type}' but was opened as '${t.type}'`);return await this._addManifestToCache(t.cache,r),t=Object.assign({},t,{accessControllerAddress:a.accessController,meta:a.meta}),this._createStore(t.type||a.type,r,t)}async _addManifestToCache(e,t){await e.set(ye.join(t.toString(),"_manifest"),t.root),Se.debug(`Saved manifest to IPFS as '${t.root}'`)}async _haveLocalData(e,t){if(!e)return!1;const r=t.toString(),n=await e.get(ye.join(r,"_manifest"));return n!=null}async _migrate(e,t){await CA(this,e,t)}static get databaseTypes(){return Object.keys(Ft)}static isValidType(e){return Object.keys(Ft).includes(e)}static addDatabaseType(e,t){if(Ft[e])throw new Error(`Type already exists: ${e}`);Ft[e]=t}static getDatabaseTypes(){return Ft}static isValidAddress(e){return je.isValid(e)}static parseAddress(e){return je.parse(e)}}Pt.prototype.AccessControllers=Kt;Pt.prototype.Identities=ka;Pt.prototype.Keystore=Sa;export{dR as A,Dn as B,w as C,Pf as D,bt as E,Af as F,iR as G,uk as H,eh as I,yR as J,wR as K,fR as L,pR as M,gR as N,Pt as O,lR as P,H$ as S,eu as W,he as a,U as b,Lf as c,Sn as d,Gs as e,Et as f,tf as g,my as h,Rt as i,WA as j,ie as k,Ys as l,ss as m,br as n,ne as o,VA as p,cR as q,py as r,me as s,Ya as t,Za as u,Uu as v,Ka as w,oR as x,lk as y,se as z};
//# sourceMappingURL=ipfs-modules-6140a6e2.js.map
